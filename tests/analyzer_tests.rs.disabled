//! Comprehensive tests for the async FHIRPath analyzer system
//!
//! This module tests all analyzer components with async ModelProvider integration,
//! ensuring proper type inference, diagnostics, completions, and symbol resolution.

use std::sync::Arc;
use tokio;

use octofhir_fhirpath::analyzer::{
    FhirPathAnalyzer, AnalyzerBuilder, AnalysisResult, AnalysisError,
    type_analyzer::{TypeAnalyzer, TypeAnalysisResult},
    expression_analyzer::{ExpressionAnalyzer, ExpressionAnalysisResult, PerformanceNoteType},
    diagnostics::{DiagnosticSystem, DiagnosticSeverity},
    completion_provider::{CompletionProvider, CompletionKind},
    symbol_resolver::{SymbolResolver, SymbolKind},
};
use octofhir_fhirpath::ast::{ExpressionNode, LiteralValue, BinaryOperator};
use octofhir_fhirpath::model::mock_provider::MockModelProvider;
use octofhir_fhirpath::model::provider::{ModelProvider, TypeReflectionInfo};

/// Test helper to create a mock provider with some predefined types
fn create_test_provider() -> Arc<MockModelProvider> {
    Arc::new(MockModelProvider::empty())
}

/// Test helper to create a sample type reflection info
fn create_sample_type_info(type_name: &str, is_collection: bool) -> TypeReflectionInfo {
    TypeReflectionInfo {
        type_name: type_name.to_string(),
        is_collection,
        is_required: false,
        description: Some(format!("Test type: {}", type_name)),
        cardinality: if is_collection { "0..*" } else { "0..1" }.to_string(),
        constraints: Vec::new(),
    }
}

#[tokio::test]
async fn test_analyzer_creation_and_configuration() {
    let provider = create_test_provider();
    
    // Test default analyzer creation
    let analyzer = FhirPathAnalyzer::new(provider.clone());
    assert!(analyzer.config().detailed_type_inference);
    assert!(analyzer.config().enable_completions);
    assert!(analyzer.config().enable_diagnostics);

    // Test builder pattern
    let custom_analyzer = AnalyzerBuilder::new(provider.clone())
        .detailed_type_inference(false)
        .completions(false)
        .max_depth(25)
        .symbol_tracking(false)
        .build();

    assert!(!custom_analyzer.config().detailed_type_inference);
    assert!(!custom_analyzer.config().enable_completions);
    assert_eq!(custom_analyzer.config().max_analysis_depth, 25);
    assert!(!custom_analyzer.config().enable_symbol_tracking);
}

#[tokio::test]
async fn test_type_analyzer_literal_inference() {
    let provider = create_test_provider();
    let analyzer = TypeAnalyzer::new(provider);

    // Test integer literal
    let integer_expr = ExpressionNode::literal(LiteralValue::Integer(42));
    let result = analyzer.analyze_expression(&integer_expr, None).await.unwrap();
    
    assert!(result.return_type.is_some());
    assert!(!result.is_collection);
    assert_eq!(result.confidence, 1.0);
    assert!(result.referenced_types.contains(&"Integer".to_string()));

    // Test string literal
    let string_expr = ExpressionNode::literal(LiteralValue::String("test".to_string()));
    let result = analyzer.analyze_expression(&string_expr, None).await.unwrap();
    
    assert!(result.return_type.is_some());
    assert!(!result.is_collection);
    assert_eq!(result.confidence, 1.0);
    assert!(result.referenced_types.contains(&"String".to_string()));

    // Test decimal literal
    let decimal_expr = ExpressionNode::literal(LiteralValue::Decimal("3.14".to_string()));
    let result = analyzer.analyze_expression(&decimal_expr, None).await.unwrap();
    
    assert!(result.return_type.is_some());
    assert!(!result.is_collection);
    assert_eq!(result.confidence, 1.0);
    assert!(result.referenced_types.contains(&"Decimal".to_string()));

    // Test quantity literal
    let quantity_expr = ExpressionNode::literal(LiteralValue::Quantity {
        value: "70".to_string(),
        unit: "kg".to_string(),
    });
    let result = analyzer.analyze_expression(&quantity_expr, None).await.unwrap();
    
    assert!(result.return_type.is_some());
    assert!(!result.is_collection);
    assert_eq!(result.confidence, 1.0);
    assert!(result.referenced_types.contains(&"Quantity".to_string()));
}

#[tokio::test]
async fn test_type_analyzer_binary_operations() {
    let provider = create_test_provider();
    let analyzer = TypeAnalyzer::new(provider);

    // Test arithmetic operation
    let left = ExpressionNode::literal(LiteralValue::Integer(10));
    let right = ExpressionNode::literal(LiteralValue::Integer(20));
    let add_expr = ExpressionNode::binary_op(BinaryOperator::Add, left, right);
    
    let result = analyzer.analyze_expression(&add_expr, None).await.unwrap();
    assert!(result.return_type.is_some());
    assert!(!result.is_collection);
    assert!(result.confidence > 0.0);

    // Test comparison operation
    let left = ExpressionNode::literal(LiteralValue::Integer(10));
    let right = ExpressionNode::literal(LiteralValue::Integer(20));
    let eq_expr = ExpressionNode::binary_op(BinaryOperator::Equal, left, right);
    
    let result = analyzer.analyze_expression(&eq_expr, None).await.unwrap();
    assert!(result.return_type.is_some());
    assert!(!result.is_collection);
    // Should infer Boolean type for comparison
}

#[tokio::test]
async fn test_type_analyzer_function_calls() {
    let provider = create_test_provider();
    let analyzer = TypeAnalyzer::new(provider);

    // Test count function (should return Integer)
    let count_expr = ExpressionNode::function_call("count", vec![]);
    let result = analyzer.analyze_expression(&count_expr, None).await.unwrap();
    
    // Function calls have lower confidence due to unknown context
    assert!(result.confidence > 0.0);
    assert!(!result.is_collection);

    // Test empty function (should return Boolean)
    let empty_expr = ExpressionNode::function_call("empty", vec![]);
    let result = analyzer.analyze_expression(&empty_expr, None).await.unwrap();
    
    assert!(result.confidence > 0.0);
    assert!(!result.is_collection);

    // Test where function (should return collection)
    let condition = ExpressionNode::literal(LiteralValue::Boolean(true));
    let where_expr = ExpressionNode::function_call("where", vec![condition]);
    let result = analyzer.analyze_expression(&where_expr, None).await.unwrap();
    
    assert!(result.confidence > 0.0);
    // Where should return a collection
}

#[tokio::test]
async fn test_type_analyzer_path_navigation() {
    let provider = create_test_provider();
    let analyzer = TypeAnalyzer::new(provider);

    // Test simple path navigation
    let base = ExpressionNode::identifier("Patient");
    let path_expr = ExpressionNode::path(base, "name");
    
    let result = analyzer.analyze_expression(&path_expr, Some("Patient")).await.unwrap();
    
    // With MockModelProvider, this will have lower confidence
    assert!(result.confidence < 1.0);
    assert!(result.referenced_types.len() >= 1);
}

#[tokio::test]
async fn test_expression_analyzer_complexity_metrics() {
    let provider = create_test_provider();
    let analyzer = ExpressionAnalyzer::new(provider);

    // Test simple expression complexity
    let simple_expr = ExpressionNode::literal(LiteralValue::Integer(42));
    let result = analyzer.analyze(&simple_expr, None).await.unwrap();
    
    assert_eq!(result.complexity.node_count, 1);
    assert_eq!(result.complexity.depth, 1);
    assert_eq!(result.complexity.navigation_count, 0);
    assert_eq!(result.complexity.function_call_count, 0);
    assert!(result.complexity.estimated_cost < 10);

    // Test complex expression
    let base = ExpressionNode::identifier("Patient");
    let name_path = ExpressionNode::path(base, "name");
    let condition = ExpressionNode::literal(LiteralValue::Boolean(true));
    let where_call = ExpressionNode::method_call(name_path, "where", vec![condition]);
    let first_call = ExpressionNode::method_call(where_call, "first", vec![]);
    
    let result = analyzer.analyze(&first_call, Some("Patient")).await.unwrap();
    
    assert!(result.complexity.node_count > 3);
    assert!(result.complexity.depth > 2);
    assert!(result.complexity.navigation_count > 0);
    assert!(result.complexity.function_call_count > 1);
    assert!(result.complexity.estimated_cost > 10);
}

#[tokio::test]
async fn test_expression_analyzer_performance_notes() {
    let provider = create_test_provider();
    let analyzer = ExpressionAnalyzer::new(provider);

    // Create a complex expression that should trigger performance notes
    let base = ExpressionNode::identifier("Patient");
    let name_path = ExpressionNode::path(base, "name");
    let complex_condition = ExpressionNode::function_call("resolve", vec![]);
    let where_call = ExpressionNode::method_call(name_path, "where", vec![complex_condition]);
    
    let result = analyzer.analyze(&where_call, Some("Patient")).await.unwrap();
    
    // Should have performance notes
    assert!(!result.performance_notes.is_empty());
    
    // Check for specific performance note types
    let has_expensive_note = result.performance_notes.iter()
        .any(|note| note.note_type == PerformanceNoteType::Expensive);
    let has_warning_note = result.performance_notes.iter()
        .any(|note| note.note_type == PerformanceNoteType::Warning);
    
    assert!(has_expensive_note || has_warning_note);
}

#[tokio::test]
async fn test_diagnostic_system_literal_validation() {
    let provider = create_test_provider();
    let diagnostic_system = DiagnosticSystem::new(provider);

    // Test invalid decimal literal
    let invalid_decimal = ExpressionNode::literal(LiteralValue::Decimal("not-a-number".to_string()));
    let diagnostics = diagnostic_system.analyze_expression(&invalid_decimal, None).await.unwrap();
    
    assert!(!diagnostics.is_empty());
    assert!(diagnostics.iter().any(|d| d.code == "INVALID_DECIMAL"));
    assert!(diagnostics.iter().any(|d| d.severity == DiagnosticSeverity::Error));

    // Test invalid date literal
    let invalid_date = ExpressionNode::literal(LiteralValue::Date("invalid-date".to_string()));
    let diagnostics = diagnostic_system.analyze_expression(&invalid_date, None).await.unwrap();
    
    assert!(!diagnostics.is_empty());
    assert!(diagnostics.iter().any(|d| d.code == "INVALID_DATE_FORMAT"));

    // Test valid literal (should have no diagnostics)
    let valid_integer = ExpressionNode::literal(LiteralValue::Integer(42));
    let diagnostics = diagnostic_system.analyze_expression(&valid_integer, None).await.unwrap();
    
    assert!(diagnostics.is_empty());
}

#[tokio::test]
async fn test_diagnostic_system_function_validation() {
    let provider = create_test_provider();
    let diagnostic_system = DiagnosticSystem::new(provider);

    // Test unknown function
    let unknown_func = ExpressionNode::function_call("unknownFunction", vec![]);
    let diagnostics = diagnostic_system.analyze_expression(&unknown_func, None).await.unwrap();
    
    assert!(!diagnostics.is_empty());
    assert!(diagnostics.iter().any(|d| d.code == "UNKNOWN_FUNCTION"));

    // Test invalid function arity
    let invalid_count = ExpressionNode::function_call(
        "count", 
        vec![ExpressionNode::literal(LiteralValue::Integer(1))]
    );
    let diagnostics = diagnostic_system.analyze_expression(&invalid_count, None).await.unwrap();
    
    assert!(!diagnostics.is_empty());
    assert!(diagnostics.iter().any(|d| d.code == "INVALID_FUNCTION_ARITY"));

    // Test valid function call
    let valid_count = ExpressionNode::function_call("count", vec![]);
    let diagnostics = diagnostic_system.analyze_expression(&valid_count, None).await.unwrap();
    
    // Should have no diagnostics related to the function itself
    assert!(!diagnostics.iter().any(|d| d.code == "UNKNOWN_FUNCTION"));
    assert!(!diagnostics.iter().any(|d| d.code == "INVALID_FUNCTION_ARITY"));
}

#[tokio::test]
async fn test_diagnostic_system_type_validation() {
    let provider = create_test_provider();
    let diagnostic_system = DiagnosticSystem::new(provider);

    // Test invalid type check
    let expr = ExpressionNode::identifier("value");
    let type_check = ExpressionNode::type_check(expr, "UnknownType");
    let diagnostics = diagnostic_system.analyze_expression(&type_check, None).await.unwrap();
    
    // With MockModelProvider, unknown types will generate diagnostics
    assert!(diagnostics.iter().any(|d| d.code == "UNKNOWN_TYPE" || d.code == "UNKNOWN_IDENTIFIER"));

    // Test invalid type cast
    let expr = ExpressionNode::identifier("value");
    let type_cast = ExpressionNode::type_cast(expr, "UnknownType");
    let diagnostics = diagnostic_system.analyze_expression(&type_cast, None).await.unwrap();
    
    assert!(diagnostics.iter().any(|d| d.code == "UNKNOWN_TYPE" || d.code == "UNKNOWN_IDENTIFIER"));
}

#[tokio::test]
async fn test_completion_provider_function_completions() {
    let provider = create_test_provider();
    let completion_provider = CompletionProvider::new(provider);

    let completions = completion_provider.get_function_completions();
    
    assert!(!completions.is_empty());
    
    // Check for built-in functions
    assert!(completions.iter().any(|c| c.label == "count" && c.kind == CompletionKind::Function));
    assert!(completions.iter().any(|c| c.label == "empty" && c.kind == CompletionKind::Function));
    assert!(completions.iter().any(|c| c.label == "first" && c.kind == CompletionKind::Function));
    assert!(completions.iter().any(|c| c.label == "where" && c.kind == CompletionKind::Function));

    // Check for FHIR functions
    assert!(completions.iter().any(|c| c.label == "resolve" && c.kind == CompletionKind::Function));
    assert!(completions.iter().any(|c| c.label == "extension" && c.kind == CompletionKind::Function));

    // Check that functions have proper snippets
    let count_completion = completions.iter().find(|c| c.label == "count").unwrap();
    assert_eq!(count_completion.insert_text, "count()");

    let where_completion = completions.iter().find(|c| c.label == "where").unwrap();
    assert!(where_completion.insert_text.contains("$"));
}

#[tokio::test]
async fn test_completion_provider_keyword_completions() {
    let provider = create_test_provider();
    let completion_provider = CompletionProvider::new(provider);

    let completions = completion_provider.get_keyword_completions();
    
    assert!(!completions.is_empty());
    
    // Check for logical operators
    assert!(completions.iter().any(|c| c.label == "and" && c.kind == CompletionKind::Keyword));
    assert!(completions.iter().any(|c| c.label == "or" && c.kind == CompletionKind::Keyword));
    
    // Check for type operators
    assert!(completions.iter().any(|c| c.label == "is" && c.kind == CompletionKind::Keyword));
    assert!(completions.iter().any(|c| c.label == "as" && c.kind == CompletionKind::Keyword));
    
    // Check for collection operators
    assert!(completions.iter().any(|c| c.label == "in" && c.kind == CompletionKind::Keyword));
    assert!(completions.iter().any(|c| c.label == "contains" && c.kind == CompletionKind::Keyword));
}

#[tokio::test]
async fn test_completion_provider_basic_completions() {
    let provider = create_test_provider();
    let completion_provider = CompletionProvider::new(provider);

    // Test completions for a simple expression
    let expr = ExpressionNode::identifier("Patient");
    let completions = completion_provider.get_completions(&expr, Some("Patient"), 0).await.unwrap();

    assert!(!completions.is_empty());
    
    // Should include functions, keywords, and other completions
    let has_functions = completions.iter().any(|c| c.kind == CompletionKind::Function);
    let has_keywords = completions.iter().any(|c| c.kind == CompletionKind::Keyword);
    
    assert!(has_functions);
    assert!(has_keywords);
}

#[tokio::test]
async fn test_symbol_resolver_identifier_resolution() {
    let provider = create_test_provider();
    let resolver = SymbolResolver::new(provider);

    // Test identifier resolution
    let expr = ExpressionNode::identifier("Patient");
    let symbols = resolver.resolve_symbols(&expr, Some("Patient")).await.unwrap();

    assert!(!symbols.is_empty());
    
    let patient_symbol = symbols.iter().find(|s| s.name == "Patient").unwrap();
    assert_eq!(patient_symbol.kind, SymbolKind::Type);
}

#[tokio::test]
async fn test_symbol_resolver_function_resolution() {
    let provider = create_test_provider();
    let resolver = SymbolResolver::new(provider);

    // Test function symbol resolution
    let expr = ExpressionNode::function_call("count", vec![]);
    let symbols = resolver.resolve_symbols(&expr, None).await.unwrap();

    assert!(!symbols.is_empty());
    
    let count_symbol = symbols.iter().find(|s| s.name == "count").unwrap();
    assert_eq!(count_symbol.kind, SymbolKind::Function);
    assert!(count_symbol.documentation.is_some());
    assert!(count_symbol.definition_location.is_some());
}

#[tokio::test]
async fn test_symbol_resolver_variable_resolution() {
    let provider = create_test_provider();
    let resolver = SymbolResolver::new(provider);

    // Test system variable resolution
    let expr = ExpressionNode::variable("$this");
    let symbols = resolver.resolve_symbols(&expr, Some("Patient")).await.unwrap();

    assert!(!symbols.is_empty());
    
    let this_symbol = symbols.iter().find(|s| s.name == "$this").unwrap();
    assert_eq!(this_symbol.kind, SymbolKind::SystemVariable);
    assert!(this_symbol.documentation.is_some());

    // Test $index variable
    let index_expr = ExpressionNode::variable("$index");
    let symbols = resolver.resolve_symbols(&index_expr, None).await.unwrap();

    let index_symbol = symbols.iter().find(|s| s.name == "$index").unwrap();
    assert_eq!(index_symbol.kind, SymbolKind::SystemVariable);
}

#[tokio::test]
async fn test_symbol_resolver_path_resolution() {
    let provider = create_test_provider();
    let resolver = SymbolResolver::new(provider);

    // Test path navigation symbol resolution
    let base = ExpressionNode::identifier("Patient");
    let path_expr = ExpressionNode::path(base, "name");
    let symbols = resolver.resolve_symbols(&path_expr, Some("Patient")).await.unwrap();

    assert!(symbols.len() >= 2); // Base identifier + property
    
    // Should have symbols for both base and property
    let has_base_symbol = symbols.iter().any(|s| s.name == "Patient");
    let has_property_symbol = symbols.iter().any(|s| s.name == "name");
    
    assert!(has_base_symbol);
    // Property symbol may not be found with MockModelProvider, but that's expected
}

#[tokio::test]
async fn test_symbol_resolver_hover_info() {
    let provider = create_test_provider();
    let resolver = SymbolResolver::new(provider);

    // Test hover info for function
    let expr = ExpressionNode::function_call("count", vec![]);
    let hover = resolver.get_hover_info(&expr, None, 0).await.unwrap();

    assert!(hover.is_some());
    
    if let Some(hover_info) = hover {
        assert!(hover_info.contents.contains("count"));
        assert!(hover_info.contents.contains("function"));
    }
}

#[tokio::test]
async fn test_full_analyzer_integration() {
    let provider = create_test_provider();
    let analyzer = FhirPathAnalyzer::new(provider);

    // Test complete analysis of a complex expression
    let base = ExpressionNode::identifier("Patient");
    let name_path = ExpressionNode::path(base, "name");
    let condition = ExpressionNode::function_call("exists", vec![]);
    let where_call = ExpressionNode::method_call(name_path, "where", vec![condition]);
    let first_call = ExpressionNode::method_call(where_call, "first", vec![]);

    let result = analyzer.analyze(&first_call, Some("Patient")).await.unwrap();

    // Should have comprehensive analysis results
    assert!(result.referenced_types.len() > 0);
    
    // Should have some symbols (even with MockModelProvider)
    assert!(result.symbols.len() > 0);
    
    // May have diagnostics depending on MockModelProvider behavior
    // Diagnostics presence is not required but acceptable
}

#[tokio::test]
async fn test_analyzer_with_completions() {
    let provider = create_test_provider();
    let analyzer = FhirPathAnalyzer::new(provider);

    // Test analysis with completions
    let expr = ExpressionNode::identifier("Patient");
    let result = analyzer.analyze_with_completions(&expr, Some("Patient"), 0).await.unwrap();

    assert!(!result.completions.is_empty());
    
    // Should have various types of completions
    let completion_kinds: std::collections::HashSet<_> = result.completions.iter()
        .map(|c| &c.kind)
        .collect();
    
    assert!(completion_kinds.len() > 1); // Should have multiple kinds
}

#[tokio::test]
async fn test_analyzer_error_handling() {
    let provider = create_test_provider();
    let analyzer = FhirPathAnalyzer::new(provider);

    // Test with very deeply nested expression to trigger max depth error
    let mut deep_expr = ExpressionNode::identifier("test");
    for _ in 0..60 {
        deep_expr = ExpressionNode::path(Box::new(deep_expr), "deep");
    }

    let result = analyzer.analyze(&deep_expr, None).await;
    
    // Should handle the deep nesting gracefully
    match result {
        Ok(_) => {
            // Acceptable - might not hit depth limit with current implementation
        }
        Err(AnalysisError::MaxDepthExceeded { max_depth }) => {
            assert!(max_depth > 0);
        }
        Err(_) => {
            panic!("Unexpected error type");
        }
    }
}

#[tokio::test]
async fn test_analyzer_builder_customization() {
    let provider = create_test_provider();

    // Test analyzer with disabled features
    let minimal_analyzer = AnalyzerBuilder::new(provider.clone())
        .detailed_type_inference(false)
        .completions(false)
        .diagnostics(false)
        .symbol_tracking(false)
        .build();

    let expr = ExpressionNode::literal(LiteralValue::Integer(42));
    let result = minimal_analyzer.analyze(&expr, None).await.unwrap();

    // With most features disabled, should have minimal results
    assert!(result.completions.is_empty());
    assert!(result.diagnostics.is_empty());
    assert!(result.symbols.is_empty());

    // Test analyzer with all features enabled
    let full_analyzer = AnalyzerBuilder::new(provider)
        .detailed_type_inference(true)
        .completions(true)
        .diagnostics(true)
        .symbol_tracking(true)
        .max_depth(100)
        .build();

    let result = full_analyzer.analyze(&expr, None).await.unwrap();
    
    // With all features enabled, should have comprehensive analysis
    // Even for a simple literal, some analysis should occur
}

#[tokio::test]
async fn test_concurrent_analysis() {
    let provider = create_test_provider();
    let analyzer = Arc::new(FhirPathAnalyzer::new(provider));

    // Test concurrent analysis of multiple expressions
    let expressions = vec![
        ExpressionNode::literal(LiteralValue::Integer(1)),
        ExpressionNode::literal(LiteralValue::String("test".to_string())),
        ExpressionNode::function_call("count", vec![]),
        ExpressionNode::identifier("Patient"),
    ];

    let mut handles = Vec::new();
    
    for expr in expressions {
        let analyzer_clone = analyzer.clone();
        let handle = tokio::spawn(async move {
            analyzer_clone.analyze(&expr, Some("Patient")).await
        });
        handles.push(handle);
    }

    // Wait for all analyses to complete
    let results: Vec<_> = futures::future::try_join_all(handles).await.unwrap();
    
    // All analyses should succeed
    for result in results {
        assert!(result.is_ok());
    }
}

/// Performance test for analyzer components
#[tokio::test]
async fn test_analyzer_performance() {
    let provider = create_test_provider();
    let analyzer = FhirPathAnalyzer::new(provider);

    let expr = ExpressionNode::function_call("count", vec![]);
    
    let start = std::time::Instant::now();
    
    // Run multiple analyses
    for _ in 0..100 {
        let _ = analyzer.analyze(&expr, None).await.unwrap();
    }
    
    let duration = start.elapsed();
    
    // Should complete reasonably quickly
    assert!(duration.as_millis() < 5000, "Analysis took too long: {:?}", duration);
}

#[cfg(test)]
mod async_test_helpers {
    use super::*;
    
    /// Helper for testing async operations with timeout
    pub async fn with_timeout<F, T>(future: F) -> T 
    where
        F: std::future::Future<Output = T>,
    {
        tokio::time::timeout(std::time::Duration::from_secs(10), future)
            .await
            .expect("Operation timed out")
    }
}

// Additional integration tests to ensure all components work together

#[tokio::test]
async fn test_end_to_end_analysis_workflow() {
    let provider = create_test_provider();
    let analyzer = FhirPathAnalyzer::new(provider);

    // Simulate a complete LSP workflow
    let expression_text = "Patient.name.where(given.exists()).first()";
    
    // In a real scenario, this would be parsed from text
    // For testing, we'll construct the AST manually
    let base = ExpressionNode::identifier("Patient");
    let name_path = ExpressionNode::path(base, "name");
    let given_path = ExpressionNode::path(
        ExpressionNode::identifier("given"), 
        "exists"
    );
    let exists_call = ExpressionNode::method_call(given_path, "exists", vec![]);
    let where_call = ExpressionNode::method_call(name_path, "where", vec![exists_call]);
    let first_call = ExpressionNode::method_call(where_call, "first", vec![]);

    // Complete analysis
    let result = analyzer.analyze_with_completions(&first_call, Some("Patient"), 0).await.unwrap();

    // Verify we got comprehensive results
    assert!(!result.referenced_types.is_empty());
    assert!(!result.symbols.is_empty());
    assert!(!result.completions.is_empty());
    
    // The analysis should identify this as a complex expression
    let function_symbols = result.symbols.iter()
        .filter(|s| s.kind == SymbolKind::Function || s.kind == SymbolKind::Method)
        .count();
    assert!(function_symbols > 0);
}

#[tokio::test] 
async fn test_lsp_integration_compatibility() {
    let provider = create_test_provider();
    let analyzer = FhirPathAnalyzer::new(provider);

    let expr = ExpressionNode::function_call("count", vec![]);
    let result = analyzer.analyze(&expr, None).await.unwrap();

    // Test LSP serialization compatibility
    for diagnostic in &result.diagnostics {
        let lsp_diagnostic = diagnostic.to_lsp_diagnostic();
        assert!(lsp_diagnostic.is_object());
        assert!(lsp_diagnostic.get("severity").is_some());
        assert!(lsp_diagnostic.get("message").is_some());
    }

    for symbol in &result.symbols {
        let lsp_symbol = symbol.to_lsp_symbol_info();
        assert!(lsp_symbol.is_object());
        assert!(lsp_symbol.get("name").is_some());
        assert!(lsp_symbol.get("kind").is_some());
    }
}

/// Test to ensure analyzer maintains backwards compatibility
#[tokio::test]
async fn test_backwards_compatibility() {
    let provider = create_test_provider();
    
    // Test that old-style analyzer creation still works
    let _analyzer = FhirPathAnalyzer::new(provider.clone());
    
    // Test that individual components can be used independently  
    let _type_analyzer = TypeAnalyzer::new(provider.clone());
    let _expr_analyzer = ExpressionAnalyzer::new(provider.clone());
    let _diagnostic_system = DiagnosticSystem::new(provider.clone());
    let _completion_provider = CompletionProvider::new(provider.clone());
    let _symbol_resolver = SymbolResolver::new(provider);
}