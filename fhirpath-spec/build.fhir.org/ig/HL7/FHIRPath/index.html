<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE HTML>
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
    <title>FHIRPath Specification - FHIRPath Specification v3.0.0-ballot</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="author" content="http://hl7.org/fhir"/>

    <link href="fhir.css" rel="stylesheet"/>

    <!-- Bootstrap core CSS -->
    <link href="assets/css/bootstrap-fhir.css" rel="stylesheet"/>

    <!-- Project extras -->
    <link href="assets/css/project.css" rel="stylesheet"/>
    <link href="assets/css/pygments-manni.css" rel="stylesheet"/>
    <link href="assets/css/jquery-ui.css" rel="stylesheet"/>
  	<link href="assets/css/prism.css" rel="stylesheet" />
    <!-- Placeholder for child template CSS declarations -->
    <link href="assets/css/hl7.css" rel="stylesheet"/>
    <link href="assets/css/fhirpath.css" rel="stylesheet"/>
    <link href="assets/css/prism-fhirpath.css" rel="stylesheet"/>

    <script type="text/javascript" src="fhir-table-scripts.js"> </script>

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="assets/js/html5shiv.js"></script>
    <script src="assets/js/respond.min.js"></script>
    <![endif]-->

    <!-- Favicons -->
    <link rel="fhir-logo" sizes="144x144" href="assets/ico/icon-fhir-144.png"/>
    <link rel="fhir-logo" sizes="114x114" href="assets/ico/icon-fhir-114.png"/>
    <link rel="fhir-logo" sizes="72x72" href="assets/ico/icon-fhir-72.png"/>
    <link rel="fhir-logo" href="assets/ico/icon-fhir-57.png"/>
    <link rel="shortcut icon" href="assets/ico/favicon.png"/>
  </head>
  <body onload="document.body.style.opacity='1'">

	  <script src="assets/js/prism.js"></script>

    <style type="text/css">h2{--heading-prefix:"1"}
    h3,h4,h5,h6{--heading-prefix:"1"}</style>
    <div id="segment-header" class="segment">  <!-- segment-header -->
      <div class="container">  <!-- container -->
        <!-- Placeholder for child template header declarations -->

      <div id="hl7-nav">
        <a id="hl7-logo" no-external="true" href="http://hl7.org">
          <img height="50" alt="Visit the HL7 website" src="assets/images/hl7-logo-header.png"/>
        </a>
      </div>
              <!-- fhirpath expression syntax highlighting -->
        <script src="assets/js/prism-fhirpath.js"></script>

        <div id="ig-status">
          <p><span style="font-size:12pt;font-weight:bold">FHIRPath Specification</span>
            <br/>
            <span style="display:inline-block;">3.0.0-ballot - R2 STU1



  <img alt="International flag" src="assets/images/001.svg" height="16" title="International"/>


            </span>
          </p>
        </div>
      </div> <!-- /container -->
    </div>  <!-- /segment-header -->

    <div id="segment-navbar" class="segment">  <!-- segment-navbar -->
      <div id="stripe"> </div>
      <div class="container">  <!-- container -->
        <!-- HEADER CONTENT -->

        <nav class="navbar navbar-inverse">
          <!--status-bar-->
          <div class="container">
            <button data-target=".navbar-inverse-collapse" class="navbar-toggle" data-toggle="collapse" type="button" aria-label="Show navigation menu" title="Show navigation menu">
              <span class="icon-bar"> </span>
              <span class="icon-bar"> </span>
              <span class="icon-bar"> </span>
            </button>
            <a class="navbar-brand hidden" href="http://hl7.org/fhir/R4/index.html">FHIR</a>
            <div class="nav-collapse collapse navbar-inverse-collapse">
              <ul xmlns="http://www.w3.org/1999/xhtml" class="nav navbar-nav">
    <li>
        <a href="index.html">Documentation</a>
    </li>
    <li>
        <a href="grammar.html">Grammar</a>
    </li>
    <li>
        <a href="tests.html">Tests</a>
    </li>
    <li>
        <a href="http://hl7.org/fhirpath/history.html">Version History</a>
    </li>
</ul>

            </div>  <!-- /.nav-collapse -->
          </div>  <!-- /.container -->
        </nav>  <!-- /.navbar -->
      <!-- /HEADER CONTENT -->
      </div>  <!-- /container -->
    </div>  <!-- /segment-navbar -->
    <!--status-bar-->


    <a name="top"> </a>
    <div id="segment-content" class="segment">  <!-- segment-content -->
      <div class="container">  <!-- container -->
        <div class="row">
          <div class="inner-wrapper">

<div class="col-12">
  <!--ReleaseHeader--><p id="publish-box">FHIRPath Specification, published by Implementable Technology Specifications WG. This guide is not an authorized publication; it is the continuous build for version 3.0.0-ballot built by the FHIR (HL7® FHIR® Standard) CI Build. This version is based on the current content of <a href="https://github.com/HL7/FHIRPath/">https://github.com/HL7/FHIRPath/</a> and changes regularly. See the <a href="http://hl7.org/fhirpath/history.html">Directory of published versions</a></p><!--EndReleaseHeader-->

  











    <p><!-- white space is critical inside of capture --></p>
<div class="markdown-toc">
<ul id="markdown-toc">
  <li><a href="#fhirpath-continuous-build" id="markdown-toc-fhirpath-continuous-build">FHIRPath (Continuous Build)</a>    <ul>
      <li><a href="#background" id="markdown-toc-background">Background</a>        <ul>
          <li><a href="#requirements" id="markdown-toc-requirements">Requirements</a></li>
          <li><a href="#features" id="markdown-toc-features">Features</a></li>
          <li><a href="#usage" id="markdown-toc-usage">Usage</a></li>
          <li><a href="#conventions" id="markdown-toc-conventions">Conventions</a></li>
        </ul>
      </li>
      <li><a href="#navigation-model" id="markdown-toc-navigation-model">Navigation model</a></li>
      <li><a href="#path-selection" id="markdown-toc-path-selection">Path selection</a>        <ul>
          <li><a href="#collections" id="markdown-toc-collections">Collections</a></li>
          <li><a href="#paths-and-polymorphic-items" id="markdown-toc-paths-and-polymorphic-items">Paths and polymorphic items</a></li>
        </ul>
      </li>
      <li><a href="#expressions" id="markdown-toc-expressions">Expressions</a>        <ul>
          <li><a href="#literals" id="markdown-toc-literals">Literals</a></li>
          <li><a href="#operators" id="markdown-toc-operators">Operators</a></li>
          <li><a href="#function-invocations" id="markdown-toc-function-invocations">Function Invocations</a></li>
          <li><a href="#null-and-empty" id="markdown-toc-null-and-empty">Null and empty</a></li>
          <li><a href="#singleton-evaluation-of-collections" id="markdown-toc-singleton-evaluation-of-collections">Singleton Evaluation of Collections</a></li>
        </ul>
      </li>
      <li><a href="#functions" id="markdown-toc-functions">Functions</a>        <ul>
          <li><a href="#existence" id="markdown-toc-existence">Existence</a></li>
          <li><a href="#filtering-and-projection" id="markdown-toc-filtering-and-projection">Filtering and projection</a></li>
          <li><a href="#subsetting" id="markdown-toc-subsetting">Subsetting</a></li>
          <li><a href="#combining" id="markdown-toc-combining">Combining</a></li>
          <li><a href="#conversion" id="markdown-toc-conversion">Conversion</a></li>
          <li><a href="#string-manipulation" id="markdown-toc-string-manipulation">String Manipulation</a></li>
          <li><a href="#additional-string-functions" id="markdown-toc-additional-string-functions">Additional String Functions</a></li>
          <li><a href="#math" id="markdown-toc-math">Math</a></li>
          <li><a href="#tree-navigation" id="markdown-toc-tree-navigation">Tree navigation</a></li>
          <li><a href="#utility-functions" id="markdown-toc-utility-functions">Utility functions</a></li>
        </ul>
      </li>
      <li><a href="#operations" id="markdown-toc-operations">Operations</a>        <ul>
          <li><a href="#equality" id="markdown-toc-equality">Equality</a></li>
          <li><a href="#comparison" id="markdown-toc-comparison">Comparison</a></li>
          <li><a href="#types" id="markdown-toc-types">Types</a></li>
          <li><a href="#collections-1" id="markdown-toc-collections-1">Collections</a></li>
          <li><a href="#boolean-logic" id="markdown-toc-boolean-logic">Boolean logic</a></li>
          <li><a href="#math-1" id="markdown-toc-math-1">Math</a></li>
          <li><a href="#datetime-arithmetic" id="markdown-toc-datetime-arithmetic">Date/Time Arithmetic</a></li>
          <li><a href="#operator-precedence" id="markdown-toc-operator-precedence">Operator precedence</a></li>
        </ul>
      </li>
      <li><a href="#aggregates" id="markdown-toc-aggregates">Aggregates</a>        <ul>
          <li><a href="#aggregateaggregator--expression--init--value--value" id="markdown-toc-aggregateaggregator--expression--init--value--value">aggregate(aggregator : expression [, init : value]) : value</a></li>
        </ul>
      </li>
      <li><a href="#lexical-elements" id="markdown-toc-lexical-elements">Lexical Elements</a>        <ul>
          <li><a href="#whitespace" id="markdown-toc-whitespace">Whitespace</a></li>
          <li><a href="#comments" id="markdown-toc-comments">Comments</a></li>
          <li><a href="#literals-1" id="markdown-toc-literals-1">Literals</a></li>
          <li><a href="#symbols" id="markdown-toc-symbols">Symbols</a></li>
          <li><a href="#keywords" id="markdown-toc-keywords">Keywords</a></li>
          <li><a href="#identifiers" id="markdown-toc-identifiers">Identifiers</a></li>
          <li><a href="#case-sensitivity" id="markdown-toc-case-sensitivity">Case-Sensitivity</a></li>
        </ul>
      </li>
      <li><a href="#environment-variables" id="markdown-toc-environment-variables">Environment variables</a></li>
      <li><a href="#types-and-reflection" id="markdown-toc-types-and-reflection">Types and Reflection</a>        <ul>
          <li><a href="#models" id="markdown-toc-models">Models</a></li>
          <li><a href="#reflection" id="markdown-toc-reflection">Reflection</a></li>
        </ul>
      </li>
      <li><a href="#type-safety-and-strict-evaluation" id="markdown-toc-type-safety-and-strict-evaluation">Type safety and strict evaluation</a></li>
      <li><a href="#formal-specifications" id="markdown-toc-formal-specifications">Formal Specifications</a>        <ul>
          <li><a href="#formal-syntax" id="markdown-toc-formal-syntax">Formal Syntax</a></li>
          <li><a href="#model-information" id="markdown-toc-model-information">Model Information</a></li>
          <li><a href="#uri-and-media-types" id="markdown-toc-uri-and-media-types">URI and Media Types</a></li>
        </ul>
      </li>
      <li><a href="#use-of-fhirpath-on-hl7-version-2-messages" id="markdown-toc-use-of-fhirpath-on-hl7-version-2-messages">Use of FHIRPath on HL7 Version 2 messages</a></li>
      <li><a href="#fhirpath-tooling-and-implementation" id="markdown-toc-fhirpath-tooling-and-implementation">FHIRPath Tooling and Implementation</a></li>
      <li><a href="#references" id="markdown-toc-references">References</a></li>
      <li><a href="#dependencies" id="markdown-toc-dependencies">Dependencies</a></li>
      <li><a href="#cross-version-analysis" id="markdown-toc-cross-version-analysis">Cross Version Analysis</a></li>
      <li><a href="#global-profiles" id="markdown-toc-global-profiles">Global Profiles</a></li>
      <li><a href="#ip-statements" id="markdown-toc-ip-statements">IP Statements</a></li>
    </ul>
  </li>
</ul>

</div>

<h1 id="fhirpath-continuous-build">FHIRPath (Continuous Build)</h1>

<p>FHIRPath is a path based navigation and extraction language, somewhat like XPath. Operations are expressed in terms of the logical content of hierarchical data models, and support traversal, selection and filtering of data. Its design was influenced by the needs for path navigation, selection and formulation of invariants in both HL7 Fast Healthcare Interoperability Resources (<a href="http://hl7.org/fhir">FHIR</a>) and HL7 Clinical Quality Language (<a href="http://cql.hl7.org/03-developersguide.html#using-fhirpath">CQL</a>).</p>

<p>Looking for implementations? See <a href="https://confluence.hl7.org/display/FHIRI/FHIRPath+Implementations" target="_blank">FHIRPath Implementations on the HL7 confluence</a></p>

<blockquote class="stu-note">
  <p><strong>Note:</strong> The following sections of this specification have not received significant implementation experience and are marked for Standard for Trial Use (STU):</p>

  <ul>
    <li><a href="#aggregates">Aggregates</a></li>
    <li><a href="#long">Literals - Long</a></li>
    <li><a href="#tolong--long">Conversions - toLong</a></li>
    <li><a href="#lastindexofsubstring--string--integer">Functions - String (lastIndexOf)</a></li>
    <li><a href="#matchesfullregex--string--boolean">Functions - String (matchesFull)</a></li>
    <li><a href="#trim--string">Functions - String (trim, split, join)</a></li>
    <li><a href="#additional-string-functions">Functions - String (encode, decode, escape, unescape)</a></li>
    <li><a href="#math">Functions - Math</a></li>
    <li><a href="#definevariable">Functions - Utility (defineVariable, lowBoundary, highBoundary)</a></li>
    <li><a href="#precision--integer">Functions - Utility (precision)</a></li>
    <li><a href="#extract-datedatetimetime-components">Functions - Extract Date/DateTime/Time components</a></li>
    <li><a href="#reflection">Types - Reflection</a></li>
  </ul>

  <p>In addition, the appendices are included as additional documentation and are informative content.</p>
</blockquote>

<h2 id="background">Background</h2>

<p>In Information Systems in general, and Healthcare Information Systems in particular, the need for formal representation of logic is both pervasive and critical. From low-level technical specifications, through intermediate logical architectures, up to the high-level conceptual descriptions of requirements and behavior, the ability to formally represent knowledge in terms of expressions and information models is essential to the specification and implementation of these systems.</p>

<h3 id="requirements">Requirements</h3>

<p>Of particular importance is the ability to easily and precisely express conditions of basic logic, such as those found in requirements constraints (e.g. Patients must have a name), decision support (e.g. if the patient has diabetes and has not had a recent comprehensive foot exam), cohort definitions (e.g. All male patients aged 60-75), protocol descriptions (e.g. if the specimen has tested positive for the presence of sodium), and numerous other environments.</p>

<p>Precisely because the need for such expressions is so pervasive, there is no shortage of existing languages for representing them. However, these languages tend to be tightly coupled to the data structures, and even the information models on which they operate, XPath being a typical example. To ensure that the knowledge captured by the representation of these expressions can survive technological drift, a representation that can be used independent of any underlying physical implementation is required.</p>

<p>Languages meeting these additional requirements also exist, such as Object Constraint Language (OCL), Java, JavaScript, C#, and others. However, these languages are both tightly coupled to the platforms in which they operate, and, because they are general-purpose development languages, come with much heavier tooling and technology dependencies than is warranted or desirable. Even constraining one of these grammars would be insufficient, resulting in the need to extend, defeating the purpose of basing it on an existing language in the first place.</p>

<p>Given these constraints, and the lack of a specific language that meets all of these requirements, there is a need for a simple, lightweight, platform- and structure-independent graph traversal language. FHIRPath meets these requirements, and can be used within various environments to provide for simple but effective formal representation of expressions.</p>

<h3 id="features">Features</h3>

<ul>
  <li>Graph-traversal: FHIRPath is a graph-traversal language; authors can clearly and concisely express graph traversal on hierarchical information models (e.g. Health Level 7 - Version 3 (HL7 V3), Fast Healthcare Interoperability Resources (FHIR), virtual Medical Record (vMR), Clinical Information Modeling Initiative (CIMI), and Quality Data Model (QDM)).</li>
  <li>Fluent: FHIRPath has a syntax based on the <a href="https://en.wikipedia.org/wiki/Fluent_interface">Fluent Interface</a> pattern</li>
  <li>Collection-centric: FHIRPath deals with all values as collections, allowing it to easily deal with information models with repeating elements.</li>
  <li>Platform-independent: FHIRPath is a conceptual and logical specification that can be implemented in any platform.</li>
  <li>Model-independent: FHIRPath deals with data as an abstract model, allowing it to be used with any information model.</li>
</ul>

<h3 id="usage">Usage</h3>

<p>In Fast Healthcare Interoperability Resources (<a href="http://hl7.org/fhir">FHIR</a>), FHIRPath is used within the specification to provide formal definitions for conditions such as validation invariants, search parameter paths, etc. Within Clinical Quality Language (<a href="http://cql.hl7.org">CQL</a>), FHIRPath is used to simplify graph-traversal for hierarchical information models.</p>

<p>In both FHIR and CQL, the model independence of FHIRPath means that expressions can be written that deal with the contents of the resources and data types as described in the Logical views, or the UML diagrams, rather than against the physical representation of those resources. JSON and XML specific features are not visible to the FHIRPath language (such as comments and the split representation of primitives (i.e. <code class="language-plaintext highlighter-rouge">value[x]</code>)).</p>

<p>The expressions can in theory be converted to equivalent expressions in XPath, OCL, or another similarly expressive language.</p>

<p>FHIRPath can be used against many other graphs as well. For example, <a href="#hl7v2">Use of FHIRPath on HL7 Version 2 messages</a> describes how FHIRPath is used in HL7 V2.</p>

<h3 id="conventions">Conventions</h3>

<p>Throughout this documentation, <code class="language-plaintext highlighter-rouge">monospace font</code> is used to delineate expressions of FHIRPath.</p>

<p>Optional parameters to functions are enclosed in square brackets in the definition of a function. Note that the brackets are only used to indicate optionality in the signature, they are not part of the actual syntax of FHIRPath.</p>

<p>All operations and functions return a collection, but if the operation or function will always produce a collection containing a single item of a predefined type, the description of the operation or function will specify its output type explicitly, instead of just stating <code class="language-plaintext highlighter-rouge">collection</code>, e.g. <code class="language-plaintext highlighter-rouge">all(...) : Boolean</code></p>

<p>Throughout this specification, formatting patterns for Date, Time, and DateTime values are described using an informal description with the following markers:</p>

<ul>
  <li><strong>YYYY</strong> - A full four digit year (0001..9999), padded with leading zeroes if necessary</li>
  <li><strong>MM</strong> - A full two digit month value (01..12), padded with leading zeroes if necessary</li>
  <li><strong>DD</strong> - A full two digit day value (01..31), padded with leading zeroes if necessary</li>
  <li><strong>hh</strong> - A full two digit hour value (00..24), padded with leading zeroes if necessary</li>
  <li><strong>mm</strong> - A full two digit minute value (00..59), padded with leading zeroes if necessary</li>
  <li><strong>ss</strong> - A full two digit second value (00..59), padded with leading zeroes if necessary</li>
  <li><strong>fff</strong> - A fractional millisecond value (0..999)</li>
</ul>

<p>These formatting patterns are set in <strong>bold</strong> to distinguish them typographically from literals or code and to make clear that they are not intended to be formally interpreted as regex patterns.</p>

<h4 id="conformance-language">Conformance Language</h4>

<p>This specification uses the conformance verbs SHALL, MUST, SHOULD, and MAY as defined in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>. Unlike RFC 2119, however, this specification allows that different applications might not be able to interoperate because of how they use optional features. In particular:</p>

<ul>
  <li>SHALL/MUST: An absolute requirement for all implementations</li>
  <li>SHALL/MUST NOT: An absolute prohibition against inclusion for all implementations</li>
  <li>SHOULD/SHOULD NOT: A best practice or recommendation to be considered by implementers within the context of their particular implementation; there may be valid reasons to ignore an item, but the full implications must be understood and carefully weighed before choosing a different course</li>
  <li>MAY: This is truly optional language for an implementation; can be included or omitted as the implementer decides with no implications.</li>
</ul>

<h2 id="navigation-model">Navigation model</h2>

<p>FHIRPath navigates and selects nodes from a tree that abstracts away and is independent of the actual underlying implementation of the source against which the FHIRPath query is run. This way, FHIRPath can be used on in-memory Plain Old Java Objects (POJOs), XML data or any other physical representation, so long as that representation can be viewed as classes that have properties. In somewhat more formal terms, FHIRPath operates on a directed acyclic graph of classes as defined by a Meta Object Facility (MOF)-equivalent <a href="#MOF">[MOF]</a> type system. In this specification, the structures on which FHIRPath operates are referred to as the Object Model.</p>

<p>Data are represented as a tree of labelled nodes, where each node may optionally carry a primitive value and have child nodes. Nodes need not have a unique label, and leaf nodes must carry a primitive value. For example, a (partial) representation of a FHIR Patient resource in this model looks like this:</p>

<p><img src="treestructure.png" alt="Tree representation of a Patient" height="375px" width="500px" style="float: unset; margin-bottom:0;" /></p>

<p>The diagram shows a tree with a repeating <code class="language-plaintext highlighter-rouge">name</code> node, which represents repeating members of the FHIR Object Model. Leaf nodes such as <code class="language-plaintext highlighter-rouge">use</code> and <code class="language-plaintext highlighter-rouge">family</code> carry a (string) value. It is also possible for internal nodes to carry a value, as is the case for the node labelled <code class="language-plaintext highlighter-rouge">active</code>: this allows the tree to represent FHIR "primitives", which may still have child extension data.</p>

<p>FHIRPath expressions are then <em>evaluated</em> with respect to a specific instance, such as the Patient one described above. This instance is referred to as the <em>context</em> (also called the <em>root</em>) and paths within the expression are evaluated in terms of this instance.</p>

<h2 id="path-selection">Path selection</h2>

<p>FHIRPath allows navigation through the tree by composing a path of concatenated labels, e.g.</p>

<pre><code class="language-fhirpath">name.given
</code></pre>

<p>This would result in a collection of nodes, one with the value <code class="language-plaintext highlighter-rouge">'Wouter'</code> and one with the value <code class="language-plaintext highlighter-rouge">'Gert'</code>. In fact, each step in such a path results in a collection of nodes by selecting nodes with the given label from the step before it. The input collection at the beginning of the evaluation contained all elements from Patient, and the path <code class="language-plaintext highlighter-rouge">name</code> selected just those named <code class="language-plaintext highlighter-rouge">name</code>. Since the <code class="language-plaintext highlighter-rouge">name</code> element repeats, the next step <code class="language-plaintext highlighter-rouge">given</code> along the path, will contain all nodes labeled <code class="language-plaintext highlighter-rouge">given</code> from all nodes <code class="language-plaintext highlighter-rouge">name</code> in the preceding step.</p>

<p>The path may start with the type of the root node (which otherwise does not have a name), but this is optional. To illustrate this point, the path <code class="language-plaintext highlighter-rouge">name.given</code> above can be evaluated as an expression on a set of data of any type. However the expression may be prefixed with the name of the type of the root:</p>

<pre><code class="language-fhirpath">Patient.name.given
</code></pre>

<p>The two expressions have the same outcome, but when evaluating the second, the evaluation will only produce results when used on data of type <code class="language-plaintext highlighter-rouge">Patient</code>. When resolving an identifier that is also the root of a FHIRPath expression, it is resolved as a type name first, and if it resolves to a type, it must resolve to the type of the context (or a supertype). Otherwise, it is resolved as a path on the context. If the identifier cannot be resolved, the evaluation will end and signal an error to the calling environment.</p>

<p>Syntactically, FHIRPath defines identifiers as any sequence of characters consisting only of letters, digits, and underscores, beginning with a letter or underscore. Paths may use backticks to include characters in path parts that would otherwise be interpreted as keywords or operators, e.g.:</p>

<pre><code class="language-fhirpath">Message.`PID-1`
</code></pre>

<h3 id="collections">Collections</h3>

<p>Collections are fundamental to FHIRPath, in that the result of every expression is a collection, even if that expression only results in a single element. This approach allows paths to be specified without having to care about the cardinality of any particular element, and is therefore ideally suited to graph traversal.</p>

<p>Within FHIRPath, a collection is:</p>

<ul>
  <li>Ordered - The order of items in the collection is important and is preserved through operations as much as possible. Operators and functions that do not preserve order will note that in their documentation.</li>
  <li>Non-Unique - Duplicate elements are allowed within a collection. Some operations and functions, such as <code class="language-plaintext highlighter-rouge">distinct()</code> and the union operator <code class="language-plaintext highlighter-rouge">|</code> produce collections of unique elements, but in general, duplicate elements are allowed.</li>
  <li>Indexed - Each item in a collection can be addressed by its index, i.e. ordinal position within the collection (e.g. <code class="language-plaintext highlighter-rouge">a[2]</code>).</li>
  <li>Unless specified otherwise by the underlying Object Model, the first item in a collection has index 0. Note that if the underlying model specifies that a collection is 1-based (the only reasonable alternative to 0-based collections), <em>any collections generated from operations on the 1-based list are 0-based</em>.</li>
  <li>Countable - The number of items in a given collection can always be determined using the <code class="language-plaintext highlighter-rouge">count()</code> function</li>
</ul>

<p>Note that the outcome of functions like <code class="language-plaintext highlighter-rouge">children()</code> and <code class="language-plaintext highlighter-rouge">descendants()</code> cannot be assumed to be in any meaningful order, and <code class="language-plaintext highlighter-rouge">first()</code>, <code class="language-plaintext highlighter-rouge">last()</code>, <code class="language-plaintext highlighter-rouge">tail()</code>, <code class="language-plaintext highlighter-rouge">skip()</code> and <code class="language-plaintext highlighter-rouge">take()</code> should not be used on collections derived from these paths. Note that some implementations may follow the logical order implied by the object model, and some may not, and some may be different depending on the underlying source. Implementations may decide to return an error if an attempt is made to perform an order-dependent operation on a list whose order is undefined.</p>

<h3 id="paths-and-polymorphic-items">Paths and polymorphic items</h3>

<p>In the underlying representation of data, nodes may be typed and represent polymorphic items. Paths may either ignore the type of a node, and continue along the path or may be explicit about the expected node and filter the set of nodes by type before navigating down child nodes:</p>

<pre><code class="language-fhirpath">Observation.value.unit // all kinds of value
Observation.value.ofType(Quantity).unit // only values that are of type Quantity
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">is</code> operator can be used to determine whether or not a given value is of a given type:</p>

<pre><code class="language-fhirpath">Observation.value is Quantity // returns true if the value is of type Quantity
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">as</code> operator can be used to treat a value as a specific type:</p>

<pre><code class="language-fhirpath">Observation.value as Quantity // returns value as a Quantity if it is of type Quantity, and an empty result otherwise
</code></pre>

<p>The list of available types that can be passed as an argument to the <code class="language-plaintext highlighter-rouge">ofType()</code> function and <code class="language-plaintext highlighter-rouge">is</code> and <code class="language-plaintext highlighter-rouge">as</code> operators is determined by the underlying object model. Within FHIRPath, they are just identifiers, either delimited or simple.</p>

<h2 id="expressions">Expressions</h2>

<p>FHIRPath expressions can consist of <em>paths</em>, <em>literals</em>, <em>operators</em>, and <em>function invocations</em>, and these elements can be chained together, so that the output of one operation or function is the input to the next. This is the core of the <em>fluent</em> <a href="#fluent">[Fluent]</a> syntactic style and allows complex paths and expressions to be built up from simpler components.</p>

<h3 id="literals">Literals</h3>

<p>In addition to paths, FHIRPath expressions may contain <em>literals</em>, <em>operators</em>, and <em>function invocations</em>. FHIRPath supports the following types of literals:</p>

<pre><code class="language-txt">Boolean: true, false
String: 'test string', 'urn:oid:3.4.5.6.7.8'
Integer: 0, 45
Long: 0L, 45L    // Long is defined as STU
Decimal: 0.0, 3.14159265
Date: @2015-02-04 (@ followed by ISO8601 compliant date)
DateTime: @2015-02-04T14:34:28+09:00 (@ followed by ISO8601 compliant date/time)
Time: @T14:34:28 (@ followed by ISO8601 compliant time beginning with T, no timezone offset)
Quantity: 10 'mg', 4 days
</code></pre>

<p>For each type of literal, FHIRPath defines a named system type to allow operations and functions to be defined, as well as an ultimate root type, <code class="language-plaintext highlighter-rouge">System.Any</code>. For example, the multiplication operator (<code class="language-plaintext highlighter-rouge">*</code>) is defined for the numeric types Integer and Decimal, as well as the Quantity type. See the discussion on <a href="#models">Models</a> for a more detailed discussion of how these types are used within evaluation contexts.</p>

<h4 id="boolean">Boolean</h4>

<p>The <code class="language-plaintext highlighter-rouge">Boolean</code> type represents the logical Boolean values <code class="language-plaintext highlighter-rouge">true</code> and <code class="language-plaintext highlighter-rouge">false</code>. These values are used as the result of comparisons, and can be combined using logical operators such as <code class="language-plaintext highlighter-rouge">and</code> and <code class="language-plaintext highlighter-rouge">or</code>.</p>

<pre><code class="language-fhirpath">true
false
</code></pre>

<h4 id="string">String</h4>

<p>The <code class="language-plaintext highlighter-rouge">String</code> type represents string values up to 2<sup>31</sup>-1 characters in length. String literals are surrounded by single-quotes and may use <code class="language-plaintext highlighter-rouge">\</code>-escapes to escape quotes and represent Unicode characters:</p>

<table class="grid">
  <thead>
    <tr>
      <th>Escape</th>
      <th>Character</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">\'</code></td>
      <td>Single-quote</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">\"</code></td>
      <td>Double-quote</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">\`</code></td>
      <td>Backtick</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">\r</code></td>
      <td>Carriage Return</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">\n</code></td>
      <td>Line Feed</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">\t</code></td>
      <td>Tab</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">\f</code></td>
      <td>Form Feed</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">\\</code></td>
      <td>Backslash</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">\uXXXX</code></td>
      <td>Unicode character, where XXXX is the hexadecimal representation of the character</td>
    </tr>
  </tbody>
</table>

<p>No other escape sequences besides those listed above are recognized.</p>

<p>Note that Unicode is supported in both string literals and delimited <a href="#identifiers">Identifiers</a>.</p>

<pre><code class="language-fhirpath">'test string'
'urn:oid:3.4.5.6.7.8'
</code></pre>

<p>If a <code class="language-plaintext highlighter-rouge">\</code> is used at the beginning of a non-escape sequence, it will be ignored and will not appear in the sequence.</p>

<pre><code class="language-txt">define TestEscape1: '\p' // 'p'
define TestEscape2: '\\p' // '\p'
define TestEscape3: '\3' // '3'
define TestEscape4: '\u005' // 'u005'
define TestEscape5: '\' // ''
</code></pre>

<h4 id="integer">Integer</h4>

<p>The <code class="language-plaintext highlighter-rouge">Integer</code> type represents whole numbers in the range -2<sup>31</sup> to 2<sup>31</sup>-1.</p>

<pre><code class="language-fhirpath">0
45
-5
</code></pre>

<blockquote>
  <p>Note that the minus sign (<code class="language-plaintext highlighter-rouge">-</code>) in the representation of a negative integer is not part of the literal, it is the unary negation operator defined as part of FHIRPath syntax.</p>
</blockquote>

<h5 id="long">Long</h5>
<blockquote class="stu-note">
  <p><strong>Note:</strong> The contents of this section are Standard for Trial Use (STU)</p>
</blockquote>

<p class="stu">The <code class="language-plaintext highlighter-rouge">Long</code> type represents whole numbers in the range -2<sup>63</sup> to 2<sup>63</sup>-1.</p>
<pre class="stu"><code class="language-fhirpath">0L
45L
-5L
</code></pre>

<p class="stu">This type corresponds to System.Long</p>

<h4 id="decimal">Decimal</h4>

<p>The <code class="language-plaintext highlighter-rouge">Decimal</code> type represents real values in the range (-10<sup>28</sup>+1)/10<sup>8</sup> to (10<sup>28</sup>-1)/10<sup>8</sup> with a step size of 10<sup>-8</sup>. This range is defined based on a survey of decimal-value implementations and is based on the most useful lowest common denominator. Implementations can provide support for larger decimals and higher precision, but must provide at least the range and precision defined here. In addition, implementations should use <a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">fixed-precision decimal</a> formats to ensure that decimal values are accurately represented.</p>

<pre><code class="language-fhirpath">0.0
3.14159265
</code></pre>

<p>Decimal literals cannot use exponential notation. There is enough additional complexity associated with enabling exponential notation that this is outside the scope of what FHIRPath is intended to support (namely graph traversal).</p>

<h4 id="date">Date</h4>

<p>The <code class="language-plaintext highlighter-rouge">Date</code> type represents date and partial date values in the range @0001-01-01 to @9999-12-31 with a 1 day step size.</p>

<p>The <code class="language-plaintext highlighter-rouge">Date</code> literal is a subset of <a href="#ISO8601">[ISO8601]</a>:</p>

<ul>
  <li>A date literal begins with an <code class="language-plaintext highlighter-rouge">@</code></li>
  <li>It uses the format <strong>YYYY-MM-DD</strong> format, though month and day parts are optional, and a separator is required between provided components</li>
  <li>Week dates and ordinal dates are not allowed</li>
  <li>Years must be present (e.g. <code class="language-plaintext highlighter-rouge">@-10-20</code> is not a valid Date in FHIRPath)</li>
  <li>Months must be present if a day is present</li>
  <li>To specify a date and time together, see the description of <code class="language-plaintext highlighter-rouge">DateTime</code> below</li>
</ul>

<p>The following examples illustrate the use of the <code class="language-plaintext highlighter-rouge">Date</code> literal:</p>

<pre><code class="language-fhirpath">@2014-01-25
@2014-01
@2014
</code></pre>

<p>Consult the <a href="grammar.html">formal grammar</a> for more details.</p>

<h4 id="time">Time</h4>

<p>The <code class="language-plaintext highlighter-rouge">Time</code> type represents time-of-day and partial time-of-day values in the range @T00:00:00.000 to @T23:59:59.999 with a step size of 1 millisecond. This range is defined based on a survey of time implementations and is based on the most useful lowest common denominator. Implementations can provide support for higher precision, but must provide at least the range and precision defined here. Time values in FHIRPath do not have a timezone or timezone offset.</p>

<p>The <code class="language-plaintext highlighter-rouge">Time</code> literal uses a subset of <a href="#ISO8601">[ISO8601]</a>:</p>

<ul>
  <li>A time begins with a <code class="language-plaintext highlighter-rouge">@T</code></li>
  <li>It uses the <strong>Thh:mm:ss.fff</strong> format</li>
</ul>

<p>The following examples illustrate the use of the <code class="language-plaintext highlighter-rouge">Time</code> literal:</p>

<pre><code class="language-fhirpath">@T12:00
@T14:30:14.559
</code></pre>

<p>Consult the <a href="grammar.html">formal grammar</a> for more details.</p>

<h4 id="datetime">DateTime</h4>

<p>The <code class="language-plaintext highlighter-rouge">DateTime</code> type represents date/time and partial date/time values in the range <code class="language-plaintext highlighter-rouge">@0001-01-01T00:00:00.000 to @9999-12-31T23:59:59.999</code> with a 1 millisecond step size. This range is defined based on a survey of datetime implementations and is based on the most useful lowest common denominator. Implementations can provide support for larger ranges and higher precision, but must provide at least the range and precision defined here.</p>

<p>The <code class="language-plaintext highlighter-rouge">DateTime</code> literal combines the <code class="language-plaintext highlighter-rouge">Date</code> and <code class="language-plaintext highlighter-rouge">Time</code> literals and is a subset of <a href="#ISO8601">[ISO8601]</a>:</p>

<ul>
  <li>A datetime literal begins with an <code class="language-plaintext highlighter-rouge">@</code></li>
  <li>It uses the <strong>YYYY-MM-DDThh:mm:ss.fff(+|-)hh:mm</strong> format</li>
  <li>Timezone offset is optional, but if present the notation <strong>(+|-)hh:mm</strong> is used (so must include both minutes and hours)</li>
  <li><strong>Z</strong> is allowed as a synonym for the zero (+00:00) UTC offset.</li>
  <li>A <code class="language-plaintext highlighter-rouge">T</code> can be used at the end of any date (year, year-month, or year-month-day) to indicate a partial DateTime.</li>
</ul>

<p>The following example illustrates the use of the <code class="language-plaintext highlighter-rouge">DateTime</code> literal:</p>

<pre><code class="language-fhirpath">@2014-01-25T14:30:14.559
@2014-01-25T14:30:14.559Z // A date time with UTC timezone offset
@2014-01-25T14:30 // A partial DateTime with year, month, day, hour, and minute
@2014-03-25T // A partial DateTime with year, month, and day
@2014-01T // A partial DateTime with year and month
@2014T // A partial DateTime with only the year
</code></pre>

<p>The suffix <code class="language-plaintext highlighter-rouge">T</code> is allowed after a year, year-month, or year-month-day literal because without it, there would be no way to specify a partial DateTime with only a year, month, or day; the literal would always result in a Date value.</p>

<p>Consult the <a href="grammar.html">formal grammar</a> for more details.</p>

<h4 id="quantity">Quantity</h4>

<p>The <code class="language-plaintext highlighter-rouge">Quantity</code> type represents quantities with a specified unit, where the <code class="language-plaintext highlighter-rouge">value</code> component is defined as a <code class="language-plaintext highlighter-rouge">Decimal</code>, and the <code class="language-plaintext highlighter-rouge">unit</code> element is represented as a <code class="language-plaintext highlighter-rouge">String</code> that is required to be either a valid Unified Code for Units of Measure <a href="#UCUM">[UCUM]</a> unit or one of the calendar duration keywords, singular or plural.</p>

<p>The <code class="language-plaintext highlighter-rouge">Quantity</code> literal is a number (integer or decimal), followed by a (single-quoted) string representing a valid Unified Code for Units of Measure <a href="#UCUM">[UCUM]</a> unit or calendar duration keyword. If the value literal is an Integer, it will be implicitly converted to a Decimal in the resulting Quantity value:</p>

<pre><code class="language-fhirpath">4.5 'mg'
100 '[degF]'
</code></pre>

<blockquote>
  <p>Implementations must respect UCUM units, meaning that they must not ignore UCUM units in calculations involving quantities, including comparison, conversion, and arithmetic operations. For implementations that do not support unit conversion, this means that the calculation need only be supported if the units are the same value, case-sensitively.</p>

  <p>When using <a href="#UCUM">[UCUM]</a> units within FHIRPath, implementations shall use case-sensitive comparisons.</p>

  <p>Implementations shall support comparison and arithmetic operations on quantities with units where the units are the same.</p>

  <p>Implementations should support other unit functionality as specified by UCUM, including unit conversion.</p>

  <p>Implementations that do not support complete UCUM functionality may return empty (<code class="language-plaintext highlighter-rouge">{ }</code>) for calculations involving quantities with units where the units are different.</p>
</blockquote>

<h5 id="time-valued-quantities">Time-valued Quantities</h5>

<p>For time-valued quantities, in addition to the definite duration UCUM units, FHIRPath defines calendar duration keywords for calendar duration units:</p>

<table class="grid">
  <thead>
    <tr>
      <th>Calendar Duration</th>
      <th>Unit Representation</th>
      <th>Relationship to Definite Duration UCUM Unit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">year</code>/<code class="language-plaintext highlighter-rouge">years</code></td>
      <td><code class="language-plaintext highlighter-rouge">'year'</code></td>
      <td><code class="language-plaintext highlighter-rouge">~ 1 'a'</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">month</code>/<code class="language-plaintext highlighter-rouge">months</code></td>
      <td><code class="language-plaintext highlighter-rouge">'month'</code></td>
      <td><code class="language-plaintext highlighter-rouge">~ 1 'mo'</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">week</code>/<code class="language-plaintext highlighter-rouge">weeks</code></td>
      <td><code class="language-plaintext highlighter-rouge">'week'</code></td>
      <td><code class="language-plaintext highlighter-rouge">~ 1 'wk'</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">day</code>/<code class="language-plaintext highlighter-rouge">days</code></td>
      <td><code class="language-plaintext highlighter-rouge">'day'</code></td>
      <td><code class="language-plaintext highlighter-rouge">~ 1 'd'</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">hour</code>/<code class="language-plaintext highlighter-rouge">hours</code></td>
      <td><code class="language-plaintext highlighter-rouge">'hour'</code></td>
      <td><code class="language-plaintext highlighter-rouge">~ 1 'h'</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">minute</code>/<code class="language-plaintext highlighter-rouge">minutes</code></td>
      <td><code class="language-plaintext highlighter-rouge">'minute'</code></td>
      <td><code class="language-plaintext highlighter-rouge">~ 1 'min'</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">second</code>/<code class="language-plaintext highlighter-rouge">seconds</code></td>
      <td><code class="language-plaintext highlighter-rouge">'second'</code></td>
      <td><code class="language-plaintext highlighter-rouge">= 1 's'</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">millisecond</code>/<code class="language-plaintext highlighter-rouge">milliseconds</code></td>
      <td><code class="language-plaintext highlighter-rouge">'millisecond'</code></td>
      <td><code class="language-plaintext highlighter-rouge">= 1 'ms'</code></td>
    </tr>
  </tbody>
</table>

<p>For example, the following quantities are <em>calendar duration</em> quantities:</p>

<pre><code class="language-fhirpath">1 year
4 days
</code></pre>

<p>Whereas the following quantities are <em>definite duration</em> quantities:</p>

<pre><code class="language-fhirpath">1 'a'
4 'd'
</code></pre>

<p>The table above defines the equality/equivalence relationship between calendar and definite duration quantities. For example, <code class="language-plaintext highlighter-rouge">1 year</code> is not equal to <code class="language-plaintext highlighter-rouge">1 'a'</code>, but it is equivalent to <code class="language-plaintext highlighter-rouge">1 'a'</code>. See <a href="#datetime-arithmetic">Date/Time Arithmetic</a> for more information on using time-valued quantities in FHIRPath.</p>

<h3 id="operators">Operators</h3>

<p>Expressions can also contain <em>operators</em>, like those for mathematical operations and boolean logic:</p>

<pre><code class="language-fhirpath">Appointment.minutesDuration / 60 &gt; 5
MedicationAdministration.wasNotGiven implies MedicationAdministration.reasonNotGiven.exists()
name.given | name.family // union of given and family names
'sir ' + name.given
</code></pre>

<p>Operators available in FHIRPath are covered in detail in the <a href="#operations">Operations</a> section.</p>

<h3 id="function-invocations">Function Invocations</h3>

<p>Finally, FHIRPath supports the notion of functions, which operate on a collection of values (referred to as the <em>input collection</em>), optionally taking arguments, and return another collection (referred to as the <em>output collection</em>). For example:</p>

<pre><code class="language-fhirpath">name.given.substring(0,4)
identifier.where(use = 'official')
</code></pre>

<p>Since all functions work on input collections, constants will first be converted to a collection when functions are invoked on constants:</p>

<pre><code class="language-fhirpath">(4+5).count()
</code></pre>

<p>will return <code class="language-plaintext highlighter-rouge">1</code>, since the input collection is implicitly a collection with one constant number <code class="language-plaintext highlighter-rouge">9</code>.</p>

<p>In general, functions in FHIRPath operate on collections and return new collections. This property, combined with the syntactic style of <em>dot invocation</em> enables functions to be chained together, creating a <em>fluent</em>-style syntax:</p>

<pre><code class="language-fhirpath">Patient.telecom.where(use = 'official').union(Patient.contact.telecom.where(use = 'official')).exists().not()
</code></pre>

<p>For a complete listing of the functions defined in FHIRPath, refer to the <a href="#functions">Functions</a> section.</p>

<h3 id="null-and-empty">Null and empty</h3>

<p>There is no literal representation for <em>null</em> in FHIRPath. This means that when, in an underlying data object (i.e. they physical data on which the implementation is operating) a member is null or missing, there will simply be no corresponding node for that member in the tree, e.g. <code class="language-plaintext fhirpath highlighter-rouge">Patient.name</code> will return an empty collection (not null) if there are no name elements in the instance.</p>

<p>In expressions, the empty collection is represented as <code class="language-plaintext highlighter-rouge">{ }</code>.</p>

<h4 id="propagation-of-empty-results-in-expressions">Propagation of empty results in expressions</h4>

<p>FHIRPath functions and operators both propagate empty results, but the behavior is in general different when the argument to the function or operator expects a collection (e.g. <code class="language-plaintext highlighter-rouge">select()</code>, <code class="language-plaintext highlighter-rouge">where()</code> and <code class="language-plaintext highlighter-rouge">|</code> (union)) versus when the argument to the function or operator takes a single value as input (e.g. <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">substring()</code>).</p>

<p>For functions or operators that take a single values as input, this means in general if the input is empty, then the result will be empty as well. More specifically:</p>

<ul>
  <li>If a single-input operator or function operates on an empty collection, the result is an empty collection</li>
  <li>If a single-input operator or function is passed an empty collection as an argument, the result is an empty collection</li>
  <li>If any operand to a single-input operator or function is an empty collection, the result is an empty collection.</li>
</ul>

<p>For operator or function arguments that expect collections, in general the empty collection is treated as any other collection would be. For example, the union (<code class="language-plaintext highlighter-rouge">|</code>) of an empty collection with some non-empty collection is that non-empty collection.</p>

<p>When functions or operators behave differently from these general principles, (for example the <code class="language-plaintext highlighter-rouge">count()</code> and <code class="language-plaintext highlighter-rouge">empty()</code> functions), this is clearly documented in the next sections.</p>

<h3 id="singleton-evaluation-of-collections">Singleton Evaluation of Collections</h3>

<p>In general, when a collection is passed as an argument to a function or operator that expects a single item as input, the collection is implicitly converted to a singleton as follows:</p>

<pre><code class="language-txt">IF the collection contains a single node AND the node's value can be implicitly converted to the expected input type THEN
  The collection evaluates to the value of that single node
ELSE IF the collection contains a single node AND the expected input type is Boolean THEN
  The collection evaluates to true
ELSE IF the collection is empty THEN
  The collection evaluates to an empty collection
ELSE
  The evaluation will end and signal an error to the calling environment
</code></pre>

<p>For example:</p>

<pre><code class="language-fhirpath">Patient.name.family + ', ' + Patient.name.given
</code></pre>

<p>If the <code class="language-plaintext highlighter-rouge">Patient</code> instance has a single <code class="language-plaintext highlighter-rouge">name</code>, and that name has a single <code class="language-plaintext highlighter-rouge">given</code>, then this will evaluate without any issues. However, if the <code class="language-plaintext highlighter-rouge">Patient</code> has multiple <code class="language-plaintext highlighter-rouge">name</code> elements, or the single name has multiple <code class="language-plaintext highlighter-rouge">given</code> elements, then it's ambiguous which of the elements should be used as the input to the <code class="language-plaintext highlighter-rouge">+</code> operator, and the result is an error.</p>

<p>As another example:</p>

<pre><code class="language-fhirpath">Patient.active and Patient.gender and Patient.telecom
</code></pre>

<p>Assuming the <code class="language-plaintext highlighter-rouge">Patient</code> instance has an <code class="language-plaintext highlighter-rouge">active</code> value of <code class="language-plaintext highlighter-rouge">true</code>, a <code class="language-plaintext highlighter-rouge">gender</code> of <code class="language-plaintext highlighter-rouge">female</code> and a single <code class="language-plaintext highlighter-rouge">telecom</code> element, this expression will result in true. However, consider a different instance of <code class="language-plaintext highlighter-rouge">Patient</code> that has an <code class="language-plaintext highlighter-rouge">active</code> value of <code class="language-plaintext highlighter-rouge">true</code>, a <code class="language-plaintext highlighter-rouge">gender</code> of <code class="language-plaintext highlighter-rouge">male</code>, and multiple <code class="language-plaintext highlighter-rouge">telecom</code> elements, then this expression will result in an error because of the multiple telecom elements.</p>

<p>Note that for repeating elements like <code class="language-plaintext highlighter-rouge">telecom</code> in the above example, the logic <em>looks</em> like an existence check. To avoid confusion and reduce unintended errors, authors should use the explicit form of these checks when appropriate. For example, a more explicit rendering of the same logic that more clearly indicates the actual intent and avoids the run-time error is:</p>

<pre><code class="language-fhirpath">Patient.active and Patient.gender and Patient.telecom.count() = 1
</code></pre>

<h2 id="functions">Functions</h2>

<p>Functions are distinguished from path navigation names by the fact that they are followed by a <code class="language-plaintext highlighter-rouge">()</code> with zero or more arguments. Throughout this specification, the word <em>parameter</em> is used to refer to the definition of a parameter as part of the function definition, while the word <em>argument</em> is used to refer to the values passed as part of a function invocation. With a few minor exceptions (e.g. <a href="#current-date-and-time-functions">current date and time functions</a>), functions in FHIRPath operate on a collection of values (referred to as the <em>input collection</em>) and produce another collection as output (referred to as the <em>output collection</em>). However, for many functions, passing an input collection with more than one item is defined as an error condition. Each function definition should define its behavior for input collections of any cardinality (0, 1, or many).</p>

<p>Correspondingly, arguments to the functions can be any FHIRPath expression, though functions taking a single item as input require these expressions to evaluate to a collection containing a single item of a specific type. This approach allows functions to be chained, successively operating on the results of the previous function in order to produce the desired final result.</p>

<p>The following sections describe the functions supported in FHIRPath, detailing the expected types of parameters and type of collection returned by the function:</p>

<ul>
  <li>If the function expects the argument passed to a parameter to be a single value (e.g. <code class="language-plaintext highlighter-rouge">startsWith(prefix: String)</code>) and it is passed an argument that evaluates to a collection with multiple items, or to a collection with an item that is not of the required type (or cannot be converted to the required type), the evaluation of the expression will end and an error will be signaled to the calling environment.</li>
  <li>If the function takes an <code class="language-plaintext highlighter-rouge">expression</code> as a parameter, the function will evaluate the expression passed for the parameter with respect to each of the items in the input collection. These expressions may refer to the special <code class="language-plaintext highlighter-rouge">$this</code> and <code class="language-plaintext highlighter-rouge">$index</code> elements, which represent the item from the input collection currently under evaluation, and its index in the collection, respectively. For example, in <code class="language-plaintext fhirpath highlighter-rouge">name.given.where($this &gt; 'ba' and $this &lt; 'bc')</code> the <code class="language-plaintext highlighter-rouge">where()</code> function will iterate over each item in the input collection (elements named <code class="language-plaintext highlighter-rouge">given</code>) and <code class="language-plaintext highlighter-rouge">$this</code> will be set to each item when the expression passed to <code class="language-plaintext highlighter-rouge">where()</code> is evaluated.</li>
</ul>

<p>For the <a href="#aggregates">aggregate</a> function, expressions may also refer to the special <code class="language-plaintext highlighter-rouge">$total</code> element, representing the result of the aggregation.</p>

<p>Note that the bracket notation in function signatures indicates optional parameters.</p>

<p>Note also that although all functions return collections, if a given function is defined to return a single element, the return type is simplified to just the type of the single element, rather than the list type.</p>

<h3 id="existence">Existence</h3>

<h4 id="empty--boolean">empty() : Boolean</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> if the input collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>) and <code class="language-plaintext highlighter-rouge">false</code> otherwise.</p>

<h4 id="existscriteria--expression--boolean">exists([criteria : expression]) : Boolean</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> if the input collection has any elements (optionally filtered by the criteria), and <code class="language-plaintext highlighter-rouge">false</code> otherwise.
This is the opposite of <code class="language-plaintext highlighter-rouge">empty()</code>, and as such is a shorthand for <code class="language-plaintext highlighter-rouge">empty().not()</code>. If the input collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>Using the optional criteria can be considered a shorthand for <code class="language-plaintext highlighter-rouge">where(criteria).exists()</code>.</p>

<p>Note that a common term for this function is <em>any</em>.</p>

<p>The following examples illustrate some potential uses of the <code class="language-plaintext highlighter-rouge">exists()</code> function:</p>

<pre><code class="language-fhirpath">Patient.name.exists()
Patient.identifier.exists(use = 'official')
Patient.telecom.exists(system = 'phone' and use = 'mobile')
Patient.generalPractitioner.exists(resolve() is Practitioner) // this example is wrong
</code></pre>

<p>The first example returns <code class="language-plaintext highlighter-rouge">true</code> if the <code class="language-plaintext highlighter-rouge">Patient</code> has any <code class="language-plaintext highlighter-rouge">name</code> elements.</p>

<p>The second example returns <code class="language-plaintext highlighter-rouge">true</code> if the <code class="language-plaintext highlighter-rouge">Patient</code> has any <code class="language-plaintext highlighter-rouge">identifier</code> elements that have a <code class="language-plaintext highlighter-rouge">use</code> element equal to <code class="language-plaintext highlighter-rouge">'official'</code>.</p>

<p>The third example returns <code class="language-plaintext highlighter-rouge">true</code> if the <code class="language-plaintext highlighter-rouge">Patient</code> has any <code class="language-plaintext highlighter-rouge">telecom</code> elements that have a <code class="language-plaintext highlighter-rouge">system</code> element equal to <code class="language-plaintext highlighter-rouge">'phone'</code> and a <code class="language-plaintext highlighter-rouge">use</code> element equal to <code class="language-plaintext highlighter-rouge">'mobile'</code>.</p>

<p>And finally, the fourth example returns <code class="language-plaintext highlighter-rouge">true</code> if the <code class="language-plaintext highlighter-rouge">Patient</code> has any <code class="language-plaintext highlighter-rouge">generalPractitioner</code> elements of type <code class="language-plaintext highlighter-rouge">Practitioner</code>.</p>

<h4 id="allcriteria--expression--boolean">all(criteria : expression) : Boolean</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> if for every element in the input collection, <code class="language-plaintext highlighter-rouge">criteria</code> evaluates to <code class="language-plaintext highlighter-rouge">true</code>. Otherwise, the result is <code class="language-plaintext highlighter-rouge">false</code>. If the input collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is <code class="language-plaintext highlighter-rouge">true</code>.</p>

<pre><code class="language-fhirpath">generalPractitioner.all($this.resolve() is Practitioner)
</code></pre>

<p>This example returns true if all of the <code class="language-plaintext highlighter-rouge">generalPractitioner</code> elements are of type <code class="language-plaintext highlighter-rouge">Practitioner</code>.</p>

<h4 id="alltrue--boolean">allTrue() : Boolean</h4>

<p>Takes a collection of Boolean values and returns <code class="language-plaintext highlighter-rouge">true</code> if all the items are <code class="language-plaintext highlighter-rouge">true</code>. If any items are <code class="language-plaintext highlighter-rouge">false</code>, the result is <code class="language-plaintext highlighter-rouge">false</code>. If the input is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is <code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>The following example returns <code class="language-plaintext highlighter-rouge">true</code> if all of the components of the Observation have a value greater than 90 mm[Hg]:</p>

<pre><code class="language-fhirpath">Observation.select(component.value &gt; 90 'mm[Hg]').allTrue()
</code></pre>

<h4 id="anytrue--boolean">anyTrue() : Boolean</h4>

<p>Takes a collection of Boolean values and returns <code class="language-plaintext highlighter-rouge">true</code> if any of the items are <code class="language-plaintext highlighter-rouge">true</code>. If all the items are <code class="language-plaintext highlighter-rouge">false</code>, or if the input is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>The following example returns <code class="language-plaintext highlighter-rouge">true</code> if any of the components of the Observation have a value greater than 90 mm[Hg]:</p>

<pre><code class="language-fhirpath">Observation.select(component.value &gt; 90 'mm[Hg]').anyTrue()
</code></pre>

<h4 id="allfalse--boolean">allFalse() : Boolean</h4>

<p>Takes a collection of Boolean values and returns <code class="language-plaintext highlighter-rouge">true</code> if all the items are <code class="language-plaintext highlighter-rouge">false</code>. If any items are <code class="language-plaintext highlighter-rouge">true</code>, the result is <code class="language-plaintext highlighter-rouge">false</code>. If the input is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is <code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>The following example returns <code class="language-plaintext highlighter-rouge">true</code> if none of the components of the Observation have a value greater than 90 mm[Hg]:</p>

<pre><code class="language-fhirpath">Observation.select(component.value &gt; 90 'mm[Hg]').allFalse()
</code></pre>

<h4 id="anyfalse--boolean">anyFalse() : Boolean</h4>

<p>Takes a collection of Boolean values and returns <code class="language-plaintext highlighter-rouge">true</code> if any of the items are <code class="language-plaintext highlighter-rouge">false</code>. If all the items are <code class="language-plaintext highlighter-rouge">true</code>, or if the input is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>The following example returns <code class="language-plaintext highlighter-rouge">true</code> if any of the components of the Observation have a value that is not greater than 90 mm[Hg]:</p>

<pre><code class="language-fhirpath">Observation.select(component.value &gt; 90 'mm[Hg]').anyFalse()
</code></pre>

<h4 id="subsetofother--collection--boolean">subsetOf(other : collection) : Boolean</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> if all items in the input collection are members of the collection passed as the <code class="language-plaintext highlighter-rouge">other</code> argument. Membership is determined using the <a href="#equals">equals</a> (<code class="language-plaintext highlighter-rouge">=</code>) operation.</p>

<p>Conceptually, this function is evaluated by testing each element in the input collection for membership in the <code class="language-plaintext highlighter-rouge">other</code> collection, with a default of <code class="language-plaintext highlighter-rouge">true</code>. This means that if the input collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is <code class="language-plaintext highlighter-rouge">true</code>, otherwise if the <code class="language-plaintext highlighter-rouge">other</code> collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>The following example returns true if the tags defined in any contained resource are a subset of the tags defined in the MedicationRequest resource:</p>

<pre><code class="language-fhirpath">MedicationRequest.contained.meta.tag.subsetOf(MedicationRequest.meta.tag)
</code></pre>

<h4 id="supersetofother--collection--boolean">supersetOf(other : collection) : Boolean</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> if all items in the collection passed as the <code class="language-plaintext highlighter-rouge">other</code> argument are members of the input collection. Membership is determined using the <a href="#equals">equals</a> (<code class="language-plaintext highlighter-rouge">=</code>) operation.</p>

<p>Conceptually, this function is evaluated by testing each element in the <code class="language-plaintext highlighter-rouge">other</code> collection for membership in the input collection, with a default of <code class="language-plaintext highlighter-rouge">true</code>. This means that if the <code class="language-plaintext highlighter-rouge">other</code> collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is <code class="language-plaintext highlighter-rouge">true</code>, otherwise if the input collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>The following example returns true if the tags defined in any contained resource are a superset of the tags defined in the MedicationRequest resource:</p>

<pre><code class="language-fhirpath">MedicationRequest.contained.meta.tag.supersetOf(MedicationRequest.meta.tag)
</code></pre>

<h4 id="count--integer">count() : Integer</h4>

<p>Returns the integer count of the number of items in the input collection. Returns 0 when the input collection is empty.</p>

<h4 id="distinct--collection">distinct() : collection</h4>

<p>Returns a collection containing only the unique items in the input collection. To determine whether two items are the same, the <a href="#equals">equals</a> (<code class="language-plaintext highlighter-rouge">=</code>) operator is used, as defined below.</p>

<p>If the input collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is empty.</p>

<p>Note that the order of elements in the input collection is not guaranteed to be preserved in the result.</p>

<p>The following example returns the distinct list of tags on the given Patient:</p>

<pre><code class="language-fhirpath">Patient.meta.tag.distinct()
</code></pre>

<h4 id="isdistinct--boolean">isDistinct() : Boolean</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> if all the items in the input collection are distinct. To determine whether two items are distinct, the <a href="#equals">equals</a> (<code class="language-plaintext highlighter-rouge">=</code>) operator is used, as defined below.</p>

<p>Conceptually, this function is shorthand for a comparison of the <code class="language-plaintext highlighter-rouge">count()</code> of the input collection against the <code class="language-plaintext highlighter-rouge">count()</code> of the <code class="language-plaintext highlighter-rouge">distinct()</code> of the input collection:</p>

<pre><code class="language-fhirpath">X.count() = X.distinct().count()
</code></pre>

<p>This means that if the input collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is true.</p>

<h3 id="filtering-and-projection">Filtering and projection</h3>

<h4 id="wherecriteria--expression--collection">where(criteria : expression) : collection</h4>

<p>Returns a collection containing only those elements in the input collection for which the stated <code class="language-plaintext highlighter-rouge">criteria</code> expression evaluates to <code class="language-plaintext highlighter-rouge">true</code>. Elements for which the expression evaluates to <code class="language-plaintext highlighter-rouge">false</code> or empty (<code class="language-plaintext highlighter-rouge">{ }</code>) are not included in the result.</p>

<p>If the input collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is empty.</p>

<p>If the result of evaluating the condition is other than a single boolean value, the evaluation will end and signal an error to the calling environment, consistent with singleton evaluation of collections behavior.</p>

<p>The following example returns the list of <code class="language-plaintext highlighter-rouge">telecom</code> elements that have a <code class="language-plaintext highlighter-rouge">use</code> element with the value of <code class="language-plaintext highlighter-rouge">'official'</code>:</p>

<pre><code class="language-fhirpath">Patient.telecom.where(use = 'official')
</code></pre>

<h4 id="selectprojection-expression--collection">select(projection: expression) : collection</h4>

<p>Evaluates the <code class="language-plaintext highlighter-rouge">projection</code> expression for each item in the input collection. The result of each evaluation is added to the output collection. If the evaluation results in a collection with multiple items, all items are added to the output collection (collections resulting from evaluation of <code class="language-plaintext highlighter-rouge">projection</code> are <em>flattened</em>). This means that if the evaluation for an element results in the empty collection (<code class="language-plaintext highlighter-rouge">{ }</code>), no element is added to the result, and that if the input collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is empty as well.</p>

<pre><code class="language-fhirpath">Bundle.entry.select(resource as Patient)
</code></pre>

<p>This example results in a collection with only the patient resources from the bundle.</p>

<pre><code class="language-fhirpath">Bundle.entry.select((resource as Patient).telecom.where(system = 'phone'))
</code></pre>

<p>This example results in a collection with all the telecom elements with system of <code class="language-plaintext highlighter-rouge">phone</code> for all the patients in the bundle.</p>

<pre><code class="language-fhirpath">Patient.name.where(use = 'usual').select(given.first() + ' ' + family)
</code></pre>

<p>This example returns a collection containing, for each "usual" name for the Patient, the concatenation of the first given and family names.</p>

<h4 id="repeatprojection-expression--collection">repeat(projection: expression) : collection</h4>

<p>A version of <code class="language-plaintext highlighter-rouge">select</code> that will repeat the <code class="language-plaintext highlighter-rouge">projection</code> and add items to the output collection only if they are not already in the output collection as determined by the <a href="#equals">equals</a> (<code class="language-plaintext highlighter-rouge">=</code>) operator.</p>

<p>This can be evaluated by adding all elements in the input collection to an input queue, then for each item in the input queue evaluate the repeat expression. If the result of the repeat expression is not in the output collection, add it to both the output collection and also the input queue. Processing continues until the input queue is empty.</p>

<p>This function can be used to traverse a tree and selecting only specific children:</p>

<pre><code class="language-fhirpath">ValueSet.expansion.repeat(contains)
</code></pre>

<p>Will repeat finding children called <code class="language-plaintext highlighter-rouge">contains</code>, until no new nodes are found.</p>

<pre><code class="language-fhirpath">Questionnaire.repeat(item)
</code></pre>

<p>Will repeat finding children called <code class="language-plaintext highlighter-rouge">item</code>, until no new nodes are found.</p>

<p>Note that this is slightly different from:</p>

<pre><code class="language-fhirpath">Questionnaire.descendants().select(item)
</code></pre>

<p>which would find <em>any</em> descendants called <code class="language-plaintext highlighter-rouge">item</code>, not just the ones nested inside other <code class="language-plaintext highlighter-rouge">item</code> elements.</p>

<p>The order of items returned by the <code class="language-plaintext highlighter-rouge">repeat()</code> function is undefined.</p>

<h4 id="oftypetype--type-specifier--collection">ofType(type : <em>type specifier</em>) : collection</h4>

<p>Returns a collection that contains all items in the input collection that are of the given type or a subclass thereof. If the input collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is empty. The <code class="language-plaintext highlighter-rouge">type</code> argument is an identifier that must resolve to the name of a type in a model. For implementations with compile-time typing, this requires special-case handling when processing the argument to treat it as type specifier rather than an identifier expression:</p>

<pre><code class="language-fhirpath">Bundle.entry.resource.ofType(Patient)
</code></pre>

<p>In the above example, the symbol <code class="language-plaintext highlighter-rouge">Patient</code> must be treated as a type identifier rather than a reference to a Patient in context.</p>

<h3 id="subsetting">Subsetting</h3>

<h4 id="-index--integer---collection">[ index : Integer ] : collection</h4>

<p>The indexer operation returns a collection with only the <code class="language-plaintext highlighter-rouge">index</code>-th item (0-based index). If the input collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), or the index lies outside the boundaries of the input collection, an empty collection is returned.</p>

<blockquote>
  <p><strong>Note:</strong> Unless specified otherwise by the underlying Object Model, the first item in a collection has index 0. Note that if the underlying model specifies that a collection is 1-based (the only reasonable alternative to 0-based collections), <em>any collections generated from operations on the 1-based list are 0-based</em>.</p>
</blockquote>

<p>The following example returns the element in the <code class="language-plaintext highlighter-rouge">name</code> collection of the Patient with index 0:</p>

<pre><code class="language-fhirpath">Patient.name[0]
</code></pre>

<h4 id="single--collection">single() : collection</h4>

<p>Will return the single item in the input if there is just one item. If the input collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is empty. If there are multiple items, an error is signaled to the evaluation environment. This function is useful for ensuring that an error is returned if an assumption about cardinality is violated at run-time.</p>

<p>The following example returns the name of the Patient if there is one. If there are no names, an empty collection, and if there are multiple names, an error is signaled to the evaluation environment:</p>

<pre><code class="language-fhirpath">Patient.name.single()
</code></pre>

<h4 id="first--collection">first() : collection</h4>

<p>Returns a collection containing only the first item in the input collection. This function is equivalent to <code class="language-plaintext highlighter-rouge">item[0]</code>, so it will return an empty collection if the input collection has no items.</p>

<h4 id="last--collection">last() : collection</h4>

<p>Returns a collection containing only the last item in the input collection. Will return an empty collection if the input collection has no items.</p>

<h4 id="tail--collection">tail() : collection</h4>

<p>Returns a collection containing all but the first item in the input collection. Will return an empty collection if the input collection has no items, or only one item.</p>

<h4 id="skipnum--integer--collection">skip(num : Integer) : collection</h4>

<p>Returns a collection containing all but the first <code class="language-plaintext highlighter-rouge">num</code> items in the input collection. Will return an empty collection if there are no items remaining after the indicated number of items have been skipped, or if the input collection is empty. If <code class="language-plaintext highlighter-rouge">num</code> is less than or equal to zero, the input collection is simply returned.</p>

<h4 id="takenum--integer--collection">take(num : Integer) : collection</h4>

<p>Returns a collection containing the first <code class="language-plaintext highlighter-rouge">num</code> items in the input collection, or less if there are less than <code class="language-plaintext highlighter-rouge">num</code> items. If num is less than or equal to 0, or if the input collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), <code class="language-plaintext highlighter-rouge">take</code> returns an empty collection.</p>

<h4 id="intersectother-collection--collection">intersect(other: collection) : collection</h4>

<p>Returns the set of elements that are in both collections. Duplicate items will be eliminated by this function. Order of items is not guaranteed to be preserved in the result of this function.</p>

<h4 id="excludeother-collection--collection">exclude(other: collection) : collection</h4>

<p>Returns the set of elements that are not in the <code class="language-plaintext highlighter-rouge">other</code> collection. Duplicate items will not be eliminated by this function, and order will be preserved.</p>

<p>e.g. <code class="language-plaintext fhirpath highlighter-rouge">(1 | 2 | 3).exclude(2)</code> returns <code class="language-plaintext highlighter-rouge">(1 | 3)</code>.</p>

<h3 id="combining">Combining</h3>

<h4 id="unionother--collection"><a name="unionother-collection"></a>union(other : collection)</h4>

<p>Merge the two collections into a single collection, eliminating any duplicate values (using <a href="#equals">equals</a> (<code class="language-plaintext highlighter-rouge">=</code>) to determine equality). There is no expectation of order in the resulting collection.</p>

<p>In other words, this function returns the distinct list of elements from both inputs. For example, consider two lists of integers <code class="language-plaintext highlighter-rouge">A: 1, 1, 2, 3</code> and <code class="language-plaintext highlighter-rouge">B: 2, 3</code>:</p>

<pre><code class="language-fhirpath">A.union( B ) // 1, 2, 3
A.union( { } ) // 1, 2, 3
</code></pre>

<p>This function can also be invoked using the <code class="language-plaintext highlighter-rouge">|</code> operator.</p>

<p>e.g. <code class="language-plaintext fhirpath highlighter-rouge">x.union(y)</code> is synonymous with <code class="language-plaintext fhirpath highlighter-rouge">x | y</code></p>

<p>e.g. <code class="language-plaintext fhirpath highlighter-rouge">name.select(use.union(given))</code> is the same as <code class="language-plaintext fhirpath highlighter-rouge">name.select(use | given)</code>, noting that the union function does not introduce an iteration context, in this example the select introduces the iteration context on the name property.</p>

<h4 id="combineother--collection--collection">combine(other : collection) : collection</h4>

<p>Merge the input and other collections into a single collection without eliminating duplicate values. Combining an empty collection with a non-empty collection will return the non-empty collection. There is no expectation of order in the resulting collection.</p>

<h3 id="conversion">Conversion</h3>

<p>FHIRPath defines both <em>implicit</em> and <em>explicit</em> conversion. Implicit conversions occur automatically, as opposed to explicit conversions that require the function be called explicitly. Implicit conversion is performed when an operator or function is used with a compatible type. For example:</p>

<pre><code class="language-fhirpath">5 + 10.0
</code></pre>

<p>In the above expression, the addition operator expects either two Integers, or two Decimals, so implicit conversion is used to convert the integer to a decimal, resulting in decimal addition.</p>

<p>The following table lists the possible conversions supported, and whether the conversion is implicit or explicit:</p>

<table class="grid">
  <thead>
    <tr>
      <th>From\To</th>
      <th>Boolean</th>
      <th>Integer</th>
      <th>Long <em class="stu-bg">(STU)</em></th>
      <th>Decimal</th>
      <th>Quantity</th>
      <th>String</th>
      <th>Date</th>
      <th>DateTime</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Boolean</strong></td>
      <td>N/A</td>
      <td>Explicit</td>
      <td><em class="stu-bg">Explicit</em></td>
      <td>Explicit</td>
      <td>-</td>
      <td>Explicit</td>
      <td>-</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td><strong>Integer</strong></td>
      <td>Explicit</td>
      <td>N/A</td>
      <td><em class="stu-bg">Implicit</em></td>
      <td>Implicit</td>
      <td>Implicit</td>
      <td>Explicit</td>
      <td>-</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td><strong>Long</strong> <em class="stu-bg">(STU)</em></td>
      <td><em class="stu-bg">Explicit</em></td>
      <td><em class="stu-bg">Explicit</em></td>
      <td><em class="stu-bg">N/A</em></td>
      <td><em class="stu-bg">Implicit</em></td>
      <td><em class="stu-bg">-</em></td>
      <td><em class="stu-bg">Explicit</em></td>
      <td><em class="stu-bg">-</em></td>
      <td><em class="stu-bg">-</em></td>
      <td><em class="stu-bg">-</em></td>
    </tr>
    <tr>
      <td><strong>Decimal</strong></td>
      <td>Explicit</td>
      <td>-</td>
      <td><em class="stu-bg">-</em></td>
      <td>N/A</td>
      <td>Implicit</td>
      <td>Explicit</td>
      <td>-</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td><strong>Quantity</strong></td>
      <td>-</td>
      <td>-</td>
      <td><em class="stu-bg">-</em></td>
      <td>-</td>
      <td>N/A</td>
      <td>Explicit</td>
      <td>-</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td><strong>String</strong></td>
      <td>Explicit</td>
      <td>Explicit</td>
      <td><em class="stu-bg">Explicit</em></td>
      <td>Explicit</td>
      <td>Explicit</td>
      <td>N/A</td>
      <td>Explicit</td>
      <td>Explicit</td>
      <td>Explicit</td>
    </tr>
    <tr>
      <td><strong>Date</strong></td>
      <td>-</td>
      <td>-</td>
      <td><em class="stu-bg">-</em></td>
      <td>-</td>
      <td>-</td>
      <td>Explicit</td>
      <td>N/A</td>
      <td>Implicit</td>
      <td>-</td>
    </tr>
    <tr>
      <td><strong>DateTime</strong></td>
      <td>-</td>
      <td>-</td>
      <td><em class="stu-bg">-</em></td>
      <td>-</td>
      <td>-</td>
      <td>Explicit</td>
      <td>Explicit</td>
      <td>N/A</td>
      <td>-</td>
    </tr>
    <tr>
      <td><strong>Time</strong></td>
      <td>-</td>
      <td>-</td>
      <td><em class="stu-bg">-</em></td>
      <td>-</td>
      <td>-</td>
      <td>Explicit</td>
      <td>-</td>
      <td>-</td>
      <td>N/A</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>Implicit - Values of the type in the From column will be implicitly converted to values of the type in the To column when necessary</li>
  <li>Explicit - Values of the type in the From column can be explicitly converted using a function defined in this section</li>
  <li>N/A - Not applicable</li>
  <li>- No conversion is defined</li>
</ul>

<p>The functions in this section operate on collections with a single item. If there is more than one item, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p><a name="iif"></a></p>
<h4 id="iifcriterion-expression-true-result-collection--otherwise-result-collection--collection">iif(criterion: expression, true-result: collection [, otherwise-result: collection]) : collection</h4>

<p>The <code class="language-plaintext highlighter-rouge">iif</code> function in FHIRPath is an <em>immediate if</em>, also known as a conditional operator (such as C's <code class="language-plaintext highlighter-rouge">? :</code> operator).</p>

<p>The <code class="language-plaintext highlighter-rouge">criterion</code> expression is expected to evaluate to a Boolean.</p>

<p>If <code class="language-plaintext highlighter-rouge">criterion</code> is true, the function returns the value of the <code class="language-plaintext highlighter-rouge">true-result</code> argument.</p>

<p>If <code class="language-plaintext highlighter-rouge">criterion</code> is <code class="language-plaintext highlighter-rouge">false</code> or an empty collection, the function returns <code class="language-plaintext highlighter-rouge">otherwise-result</code>, unless the optional <code class="language-plaintext highlighter-rouge">otherwise-result</code> is not given, in which case the function returns an empty collection.</p>

<p>Note that short-circuit behavior is expected in this function. In other words, <code class="language-plaintext highlighter-rouge">true-result</code> should only be evaluated if the <code class="language-plaintext highlighter-rouge">criterion</code> evaluates to true, and <code class="language-plaintext highlighter-rouge">otherwise-result</code> should only be evaluated otherwise. For implementations, this means delaying evaluation of the arguments.</p>

<h4 id="boolean-conversion-functions">Boolean Conversion Functions</h4>

<h5 id="toboolean--boolean">toBoolean() : Boolean</h5>

<p>If the input collection contains a single item, this function will return a single boolean if:</p>

<ul>
  <li>the item is a Boolean</li>
  <li>the item is an Integer and is equal to one of the possible integer representations of Boolean values</li>
  <li>the item is a Decimal that is equal to one of the possible decimal representations of Boolean values</li>
  <li>the item is a String that is equal to one of the possible string representations of Boolean values</li>
</ul>

<p>If the item is not one the above types, or the item is a String, Integer, or Decimal, but is not equal to one of the possible values convertible to a Boolean, the result is empty.</p>

<p>The following table describes the possible values convertible to an Boolean:</p>

<table class="grid">
  <thead>
    <tr>
      <th>Type</th>
      <th>Representation</th>
      <th>Result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>String</strong></td>
      <td><code class="language-plaintext highlighter-rouge">'true'</code>, <code class="language-plaintext highlighter-rouge">'t'</code>, <code class="language-plaintext highlighter-rouge">'yes'</code>, <code class="language-plaintext highlighter-rouge">'y'</code>, <code class="language-plaintext highlighter-rouge">'1'</code>, <code class="language-plaintext highlighter-rouge">'1.0'</code></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">'false'</code>, <code class="language-plaintext highlighter-rouge">'f'</code>, <code class="language-plaintext highlighter-rouge">'no'</code>, <code class="language-plaintext highlighter-rouge">'n'</code>, <code class="language-plaintext highlighter-rouge">'0'</code>, <code class="language-plaintext highlighter-rouge">'0.0'</code></td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
    </tr>
    <tr>
      <td><strong>Integer</strong></td>
      <td><code class="language-plaintext highlighter-rouge">1</code></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">0</code></td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
    </tr>
    <tr>
      <td><strong>Decimal</strong></td>
      <td><code class="language-plaintext highlighter-rouge">1.0</code></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">0.0</code></td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
    </tr>
  </tbody>
</table>

<p>Note for the purposes of string representations, case is ignored (so that both <code class="language-plaintext highlighter-rouge">'T'</code> and <code class="language-plaintext highlighter-rouge">'t'</code> are considered <code class="language-plaintext highlighter-rouge">true</code>).</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<h5 id="convertstoboolean--boolean">convertsToBoolean() : Boolean</h5>

<p>If the input collection contains a single item, this function will return true if:</p>

<ul>
  <li>the item is a Boolean</li>
  <li>the item is an Integer that is equal to one of the possible integer representations of Boolean values</li>
  <li>the item is a Decimal that is equal to one of the possible decimal representations of Boolean values</li>
  <li>the item is a String that is equal to one of the possible string representations of Boolean values</li>
</ul>

<p>If the item is not one of the above types, or the item is a String, Integer, or Decimal, but is not equal to one of the possible values convertible to a Boolean, the result is false.</p>

<p>Possible values for Integer, Decimal, and String are described in the toBoolean() function.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<h4 id="integer-conversion-functions">Integer Conversion Functions</h4>

<h5 id="tointeger--integer">toInteger() : Integer</h5>

<p>If the input collection contains a single item, this function will return a single integer if:</p>

<ul>
  <li>the item is an Integer</li>
  <li>the item is a String and is convertible to an integer</li>
  <li>the item is a Boolean, where <code class="language-plaintext highlighter-rouge">true</code> results in a 1 and <code class="language-plaintext highlighter-rouge">false</code> results in a 0.</li>
</ul>

<p>If the item is not one the above types, the result is empty.</p>

<p>If the item is a String, but the string is not convertible to an integer (using the regex format <code class="language-plaintext highlighter-rouge">(\+|-)?\d+</code>), the result is empty.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<h5 id="convertstointeger--boolean">convertsToInteger() : Boolean</h5>

<p>If the input collection contains a single item, this function will return true if:</p>

<ul>
  <li>the item is an Integer</li>
  <li>the item is a String and is convertible to an Integer</li>
  <li>the item is a Boolean</li>
</ul>

<p>If the item is not one of the above types, or the item is a String, but is not convertible to an Integer (using the regex format <code class="language-plaintext highlighter-rouge">(\+|-)?\d+</code>), the result is false.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<h5 id="tolong--long">toLong() : Long</h5>
<blockquote class="stu-note">
  <p><strong>Note:</strong> The contents of this section are Standard for Trial Use (STU)</p>
</blockquote>

<p class="stu">If the input collection contains a single item, this function will return a single integer if:</p>
<ul class="stu">
  <li>the item is an Integer or Long</li>
  <li>the item is a String and is convertible to a 64 bit integer</li>
  <li>the item is a Boolean, where <code class="language-plaintext highlighter-rouge">true</code> results in a 1 and <code class="language-plaintext highlighter-rouge">false</code> results in a 0.</li>
</ul>

<p class="stu">If the item is not one the above types, the result is empty.</p>

<p class="stu">If the item is a String, but the string is not convertible to a 64 bit integer (using the regex format <code class="language-plaintext highlighter-rouge">(\+|-)?\d+</code>), the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<h5 class="stu" id="convertstolong--boolean">convertsToLong() : Boolean</h5>

<p class="stu">If the input collection contains a single item, this function will return true if:</p>

<ul class="stu">
  <li>the item is an Integer or Long</li>
  <li>the item is a String and is convertible to a Long</li>
  <li>the item is a Boolean</li>
</ul>

<p class="stu">If the item is not one of the above types, or the item is a String, but is not convertible to an Integer (using the regex format <code class="language-plaintext highlighter-rouge">(\+|-)?\d+</code>), the result is false.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<h4 id="date-conversion-functions">Date Conversion Functions</h4>

<h5 id="todate--date">toDate() : Date</h5>

<p>If the input collection contains a single item, this function will return a single date if:</p>

<ul>
  <li>the item is a Date</li>
  <li>the item is a DateTime</li>
  <li>the item is a String and is convertible to a Date</li>
</ul>

<p>If the item is not one of the above types, the result is empty.</p>

<p>If the item is a String, but the string is not convertible to a Date (using the format <strong>YYYY-MM-DD</strong>), the result is empty.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<h5 id="convertstodate--boolean">convertsToDate() : Boolean</h5>

<p>If the input collection contains a single item, this function will return true if:</p>

<ul>
  <li>the item is a Date</li>
  <li>the item is a DateTime</li>
  <li>the item is a String and is convertible to a Date</li>
</ul>

<p>If the item is not one of the above types, or is not convertible to a Date (using the format <strong>YYYY-MM-DD</strong>), the result is false.</p>

<p>If the item contains a partial date (e.g. <code class="language-plaintext highlighter-rouge">'2012-01'</code>), the result is a partial date.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<h4 id="datetime-conversion-functions">DateTime Conversion Functions</h4>

<h5 id="todatetime--datetime">toDateTime() : DateTime</h5>

<p>If the input collection contains a single item, this function will return a single datetime if:</p>

<ul>
  <li>the item is a DateTime</li>
  <li>the item is a Date, in which case the result is a DateTime with the year, month, and day of the Date, and the time components empty (not set to zero)</li>
  <li>the item is a String and is convertible to a DateTime</li>
</ul>

<p>If the item is not one of the above types, the result is empty.</p>

<p>If the item is a String, but the string is not convertible to a DateTime (using the format <strong>YYYY-MM-DDThh:mm:ss.fff(+|-)hh:mm</strong>), the result is empty.</p>

<p>If the item contains a partial datetime (e.g. <code class="language-plaintext highlighter-rouge">'2012-01-01T10:00'</code>), the result is a partial datetime.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<h5 id="convertstodatetime--boolean">convertsToDateTime() : Boolean</h5>

<p>If the input collection contains a single item, this function will return true if:</p>

<ul>
  <li>the item is a DateTime</li>
  <li>the item is a Date</li>
  <li>the item is a String and is convertible to a DateTime</li>
</ul>

<p>If the item is not one of the above types, or is not convertible to a DateTime (using the format <strong>YYYY-MM-DDThh:mm:ss.fff(+|-)hh:mm</strong>), the result is false.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<h4 id="decimal-conversion-functions">Decimal Conversion Functions</h4>

<h5 id="todecimal--decimal">toDecimal() : Decimal</h5>

<p>If the input collection contains a single item, this function will return a single decimal if:</p>

<ul>
  <li>the item is an Integer or Decimal</li>
  <li>the item is a String and is convertible to a Decimal</li>
  <li>the item is a Boolean, where <code class="language-plaintext highlighter-rouge">true</code> results in a <code class="language-plaintext highlighter-rouge">1.0</code> and <code class="language-plaintext highlighter-rouge">false</code> results in a <code class="language-plaintext highlighter-rouge">0.0</code>.</li>
</ul>

<p>If the item is not one of the above types, the result is empty.</p>

<p>If the item is a String, but the string is not convertible to a Decimal (using the regex format <code class="language-plaintext highlighter-rouge">(\+|-)?\d+(\.\d+)?</code>), the result is empty.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<h5 id="convertstodecimal--boolean">convertsToDecimal() : Boolean</h5>

<p>If the input collection contains a single item, this function will true if:</p>

<ul>
  <li>the item is an Integer or Decimal</li>
  <li>the item is a String and is convertible to a Decimal</li>
  <li>the item is a Boolean</li>
</ul>

<p>If the item is not one of the above types, or is not convertible to a Decimal (using the regex format <code class="language-plaintext highlighter-rouge">(\+|-)?\d+(\.\d+)?</code>), the result is false.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<h4 id="quantity-conversion-functions">Quantity Conversion Functions</h4>

<h5 id="toquantityunit--string--quantity">toQuantity([unit : String]) : Quantity</h5>

<p>If the input collection contains a single item, this function will return a single quantity if:</p>

<ul>
  <li>the item is an Integer, or Decimal, where the resulting quantity will have the default unit (<code class="language-plaintext highlighter-rouge">'1'</code>)</li>
  <li>the item is a Quantity</li>
  <li>the item is a String and is convertible to a Quantity</li>
  <li>the item is a Boolean, where <code class="language-plaintext highlighter-rouge">true</code> results in the quantity <code class="language-plaintext highlighter-rouge">1.0 '1'</code>, and <code class="language-plaintext highlighter-rouge">false</code> results in the quantity <code class="language-plaintext highlighter-rouge">0.0 '1'</code></li>
</ul>

<p>If the item is not one of the above types, the result is empty.</p>

<p>If the item is a String, but the string is not convertible to a Quantity using the following regex format:</p>

<pre><code class="language-regex">(?'value'(\+|-)?\d+(\.\d+)?)\s*('(?'unit'[^']+)'|(?'time'[a-zA-Z]+))?
</code></pre>

<p>then the result is empty. For example, the following are valid quantity strings:</p>

<pre><code class="language-fhirpath">'4 days'
'10 \'mg[Hg]\''
</code></pre>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<p>If the <code class="language-plaintext highlighter-rouge">unit</code> argument is provided, it must be the string representation of a UCUM code (or a FHIRPath calendar duration keyword), and is used to determine whether the input quantity can be converted to the given unit, according to the unit conversion rules specified by UCUM. If the input quantity can be converted, the result is the converted quantity, otherwise, the result is empty.</p>

<p>For calendar durations, FHIRPath defines the following conversion factors:</p>

<table class="grid">
  <thead>
    <tr>
      <th>Calendar duration</th>
      <th>Conversion factor</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">1 year</code></td>
      <td><code class="language-plaintext highlighter-rouge">12 months</code> or <code class="language-plaintext highlighter-rouge">365 days</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">1 month</code></td>
      <td><code class="language-plaintext highlighter-rouge">30 days</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">1 day</code></td>
      <td><code class="language-plaintext highlighter-rouge">24 hours</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">1 hour</code></td>
      <td><code class="language-plaintext highlighter-rouge">60 minutes</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">1 minute</code></td>
      <td><code class="language-plaintext highlighter-rouge">60 seconds</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">1 second</code></td>
      <td><code class="language-plaintext highlighter-rouge">1 's'</code></td>
    </tr>
  </tbody>
</table>

<p>Note that calendar duration conversion factors are only used when time-valued quantities appear in unanchored calculations. See <a href="#datetime-arithmetic">Date/Time Arithmetic</a> for more information on using time-valued quantities in FHIRPath.</p>

<p>If <code class="language-plaintext highlighter-rouge">q</code> is a Quantity of <code class="language-plaintext highlighter-rouge">'kg'</code> and one wants to convert to a Quantity in <code class="language-plaintext highlighter-rouge">'g'</code> (grams):</p>
<pre><code class="language-fhirpath">q.toQuantity('g') // changes the value and units in the quantity according to UCUM conversion rules
</code></pre>

<blockquote>
  <p>Implementations are not required to support a complete UCUM implementation, and may return empty (<code class="language-plaintext highlighter-rouge">{ }</code>) when the <code class="language-plaintext highlighter-rouge">unit</code> argument is used and it is different than the input quantity unit.</p>
</blockquote>

<h5 id="convertstoquantityunit--string--boolean">convertsToQuantity([unit : String]) : Boolean</h5>

<p>If the input collection contains a single item, this function will return true if:</p>

<ul>
  <li>the item is an Integer, Decimal, or Quantity</li>
  <li>the item is a String that is convertible to a Quantity</li>
  <li>the item is a Boolean</li>
</ul>

<p>If the item is not one of the above types, or is not convertible to a Quantity using the following regex format:</p>

<pre><code class="language-regex">(?'value'(\+|-)?\d+(\.\d+)?)\s*('(?'unit'[^']+)'|(?'time'[a-zA-Z]+))?
</code></pre>

<p>then the result is false.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<p>If the <code class="language-plaintext highlighter-rouge">unit</code> argument is provided, it must be the string representation of a UCUM code (or a FHIRPath calendar duration keyword), and is used to determine whether the input quantity can be converted to the given unit, according to the unit conversion rules specified by UCUM. If the input quantity can be converted, the result is true, otherwise, the result is false.</p>

<blockquote>
  <p>Implementations are not required to support a complete UCUM implementation, and may return false when the <code class="language-plaintext highlighter-rouge">unit</code> argument is used and it is different than the input quantity unit.</p>
</blockquote>

<h4 id="string-conversion-functions">String Conversion Functions</h4>

<h5 id="tostring--string">toString() : String</h5>

<p>If the input collection contains a single item, this function will return a single String if:</p>

<ul>
  <li>the item in the input collection is a String</li>
  <li>the item in the input collection is an Integer, Decimal, Date, Time, DateTime, or Quantity the output will contain its String representation</li>
  <li>the item is a Boolean, where <code class="language-plaintext highlighter-rouge">true</code> results in <code class="language-plaintext highlighter-rouge">'true'</code> and <code class="language-plaintext highlighter-rouge">false</code> in <code class="language-plaintext highlighter-rouge">'false'</code>.</li>
</ul>

<p>If the item is not one of the above types, the result is false.</p>

<p>The String representation uses the following formats:</p>

<table class="grid">
  <thead>
    <tr>
      <th>Type</th>
      <th>Representation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Boolean</strong></td>
      <td><code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code></td>
    </tr>
    <tr>
      <td><strong>Integer</strong></td>
      <td><code class="language-plaintext highlighter-rouge">(\+|-)?\d+</code></td>
    </tr>
    <tr>
      <td><strong>Decimal</strong></td>
      <td><code class="language-plaintext highlighter-rouge">(\+|-)?\d+(.\d+)?</code></td>
    </tr>
    <tr>
      <td><strong>Quantity</strong></td>
      <td><code class="language-plaintext highlighter-rouge">(\+|-)?\d+(.\d+)? '.*'</code>    e.g. <code class="language-plaintext fhirpath highlighter-rouge">(4 days).toString()</code> returns <code class="language-plaintext highlighter-rouge">4 'd'</code> because the FHIRPath literal temporal units are short-hands for the UCUM equivalents.</td>
    </tr>
    <tr>
      <td><strong>Date</strong></td>
      <td><strong>YYYY-MM-DD</strong></td>
    </tr>
    <tr>
      <td><strong>DateTime</strong></td>
      <td><strong>YYYY-MM-DDThh:mm:ss.fff(+|-)hh:mm</strong></td>
    </tr>
    <tr>
      <td><strong>Time</strong></td>
      <td><strong>hh:mm:ss.fff(+|-)hh:mm</strong></td>
    </tr>
  </tbody>
</table>

<p>Note that for partial dates and times, the result will only be specified to the level of precision in the value being converted.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<h5 id="convertstostring--string">convertsToString() : String</h5>

<p>If the input collection contains a single item, this function will return true if:</p>

<ul>
  <li>the item is a String</li>
  <li>the item is an Integer, Decimal, Date, Time, or DateTime</li>
  <li>the item is a Boolean</li>
  <li>the item is a Quantity</li>
</ul>

<p>If the item is not one of the above types, the result is false.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<h4 id="time-conversion-functions">Time Conversion Functions</h4>

<h5 id="totime--time">toTime() : Time</h5>

<p>If the input collection contains a single item, this function will return a single time if:</p>

<ul>
  <li>the item is a Time</li>
  <li>the item is a String and is convertible to a Time</li>
</ul>

<p>If the item is not one of the above types, the result is empty.</p>

<p>If the item is a String, but the string is not convertible to a Time (using the format <strong>hh:mm:ss.fff(+|-)hh:mm</strong>), the result is empty.</p>

<p>If the item contains a partial time (e.g. <code class="language-plaintext highlighter-rouge">'10:00'</code>), the result is a partial time.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<h5 id="convertstotime--boolean">convertsToTime() : Boolean</h5>

<p>If the input collection contains a single item, this function will return true if:</p>

<ul>
  <li>the item is a Time</li>
  <li>the item is a String and is convertible to a Time</li>
</ul>

<p>If the item is not one of the above types, or is not convertible to a Time (using the format <strong>hh:mm:ss.fff(+|-)hh:mm</strong>), the result is false.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If the input collection is empty, the result is empty.</p>

<h3 id="string-manipulation">String Manipulation</h3>

<p>The functions in this section operate on collections with a single item. If there is more than one item, or an item that is not a String, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>To use these functions over a collection with multiple items, one may use filters like <code class="language-plaintext highlighter-rouge">where()</code> and <code class="language-plaintext highlighter-rouge">select()</code>:</p>

<pre><code class="language-fhirpath">Patient.name.given.select(substring(0))
</code></pre>

<p>This example returns a collection containing the first character of all the given names for a patient.</p>

<h4 id="indexofsubstring--string--integer">indexOf(substring : String) : Integer</h4>

<p>Returns the 0-based index of the first position <code class="language-plaintext highlighter-rouge">substring</code> is found in the input string, or -1 if it is not found.</p>

<p>If <code class="language-plaintext highlighter-rouge">substring</code> is an empty string (<code class="language-plaintext highlighter-rouge">''</code>), the function returns 0.</p>

<p>If the input or <code class="language-plaintext highlighter-rouge">substring</code> is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is empty (<code class="language-plaintext highlighter-rouge">{ }</code>).</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre><code class="language-fhirpath">'abcdefg'.indexOf('bc') // 1
'abcdefg'.indexOf('x') // -1
'abcdefg'.indexOf('abcdefg') // 0
</code></pre>

<h4 id="lastindexofsubstring--string--integer">lastIndexOf(substring : String) : Integer</h4>

<blockquote class="stu-note">
  <p><strong>Note:</strong> The contents of this section are Standard for Trial Use (STU)</p>
</blockquote>

<p class="stu">Returns the 0-based index of the last position <code class="language-plaintext highlighter-rouge">substring</code> is found in the input string, or -1 if it is not found.</p>

<p class="stu">If <code class="language-plaintext highlighter-rouge">substring</code> is an empty string (<code class="language-plaintext highlighter-rouge">''</code>), the function returns 0.</p>

<p class="stu">If the input or <code class="language-plaintext highlighter-rouge">substring</code> is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is empty (<code class="language-plaintext highlighter-rouge">{ }</code>).</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">'abcdefg'.lastIndexOf('bc') // 1
'abcdefg'.lastIndexOf('x') // -1
'abcdefg'.lastIndexOf('abcdefg') // 0
'abc abc'.lastIndexOf('a') // 4
</code></pre>

<h4 id="substringstart--integer--length--integer--string">substring(start : Integer [, length : Integer]) : String</h4>

<p>Returns the part of the string starting at position <code class="language-plaintext highlighter-rouge">start</code> (zero-based). If <code class="language-plaintext highlighter-rouge">length</code> is given, will return at most <code class="language-plaintext highlighter-rouge">length</code> number of characters from the input string.</p>

<p>If <code class="language-plaintext highlighter-rouge">start</code> lies outside the length of the string, the function returns empty (<code class="language-plaintext highlighter-rouge">{ }</code>). If there are less remaining characters in the string than indicated by <code class="language-plaintext highlighter-rouge">length</code>, the function returns just the remaining characters.</p>

<p>If the input or <code class="language-plaintext highlighter-rouge">start</code> is empty, the result is empty.</p>

<p>If an empty <code class="language-plaintext highlighter-rouge">length</code> is provided, the behavior is the same as if <code class="language-plaintext highlighter-rouge">length</code> had not been provided.</p>

<p>If a negative or zero <code class="language-plaintext highlighter-rouge">length</code> is provided, the function returns an empty string (<code class="language-plaintext highlighter-rouge">''</code>).</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre><code class="language-fhirpath">'abcdefg'.substring(3) // 'defg'
'abcdefg'.substring(1, 2) // 'bc'
'abcdefg'.substring(6, 2) // 'g'
'abcdefg'.substring(7, 1) // { } (start position is outside the string)
'abcdefg'.substring(-1, 1) // { } (start position is outside the string,
                           //     this can happen when the -1 was the result of a calculation rather than explicitly provided)
'abcdefg'.substring(3, 0) // '' (empty string)
'abcdefg'.substring(3, -1) // '' (empty string)
'abcdefg'.substring(-1, -1) // {} (start position is outside the string)
</code></pre>

<h4 id="startswithprefix--string--boolean">startsWith(prefix : String) : Boolean</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> when the input string starts with the given <code class="language-plaintext highlighter-rouge">prefix</code>.</p>

<p>If <code class="language-plaintext highlighter-rouge">prefix</code> is the empty string (<code class="language-plaintext highlighter-rouge">''</code>), the result is <code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>If the input collection is empty, the result is empty.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre><code class="language-fhirpath">'abcdefg'.startsWith('abc') // true
'abcdefg'.startsWith('xyz') // false
</code></pre>

<h4 id="endswithsuffix--string--boolean">endsWith(suffix : String) : Boolean</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> when the input string ends with the given <code class="language-plaintext highlighter-rouge">suffix</code>.</p>

<p>If <code class="language-plaintext highlighter-rouge">suffix</code> is the empty string (<code class="language-plaintext highlighter-rouge">''</code>), the result is <code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>If the input collection is empty, the result is empty.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre><code class="language-fhirpath">'abcdefg'.endsWith('efg') // true
'abcdefg'.endsWith('abc') // false
</code></pre>

<h4 id="containssubstring--string--boolean">contains(substring : String) : Boolean</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> when the given <code class="language-plaintext highlighter-rouge">substring</code> is a substring of the input string.</p>

<p>If <code class="language-plaintext highlighter-rouge">substring</code> is the empty string (<code class="language-plaintext highlighter-rouge">''</code>), the result is <code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>If the input collection is empty, the result is empty.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre><code class="language-fhirpath">'abc'.contains('b') // true
'abc'.contains('bc') // true
'abc'.contains('d') // false
</code></pre>

<blockquote>
  <p><strong>Note:</strong> The <code class="language-plaintext highlighter-rouge">.contains()</code> function described here is a string function that looks for a substring in a string. This is different than the <code class="language-plaintext highlighter-rouge">contains</code> operator, which is a list operator that looks for an element in a list.</p>
</blockquote>

<h4 id="upper--string">upper() : String</h4>

<p>Returns the input string with all characters converted to upper case.</p>

<p>If the input collection is empty, the result is empty.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre><code class="language-fhirpath">'abcdefg'.upper() // 'ABCDEFG'
'AbCdefg'.upper() // 'ABCDEFG'
</code></pre>

<h4 id="lower--string">lower() : String</h4>

<p>Returns the input string with all characters converted to lower case.</p>

<p>If the input collection is empty, the result is empty.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre><code class="language-fhirpath">'ABCDEFG'.lower() // 'abcdefg'
'aBcDEFG'.lower() // 'abcdefg'
</code></pre>

<h4 id="replacepattern--string-substitution--string--string">replace(pattern : String, substitution : String) : String</h4>

<p>Returns the input string with all instances of <code class="language-plaintext highlighter-rouge">pattern</code> replaced with <code class="language-plaintext highlighter-rouge">substitution</code>. If the substitution is the empty string (<code class="language-plaintext highlighter-rouge">''</code>), instances of <code class="language-plaintext highlighter-rouge">pattern</code> are removed from the result. If <code class="language-plaintext highlighter-rouge">pattern</code> is the empty string (<code class="language-plaintext highlighter-rouge">''</code>), every character in the input string is surrounded by the substitution, e.g. <code class="language-plaintext fhirpath highlighter-rouge">'abc'.replace('','x')</code> becomes <code class="language-plaintext highlighter-rouge">'xaxbxcx'</code>.</p>

<p>If the input collection, <code class="language-plaintext highlighter-rouge">pattern</code>, or <code class="language-plaintext highlighter-rouge">substitution</code> are empty, the result is empty (<code class="language-plaintext highlighter-rouge">{ }</code>).</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre><code class="language-fhirpath">'abcdefg'.replace('cde', '123') // 'ab123fg'
'abcdefg'.replace('cde', '') // 'abfg'
'abc'.replace('', 'x') // 'xaxbxcx'
</code></pre>

<h4 id="matchesregex--string--boolean">matches(regex : String) : Boolean</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> when the value matches the given regular expression. Regular expressions should function consistently, regardless of any culture- and locale-specific settings in the environment, should be case-sensitive, use 'single line' mode and allow Unicode characters.
The start/end of line markers <code class="language-plaintext highlighter-rouge">^</code>, <code class="language-plaintext highlighter-rouge">$</code> can be used to match the entire string.</p>

<p>If the input collection or <code class="language-plaintext highlighter-rouge">regex</code> are empty, the result is empty (<code class="language-plaintext highlighter-rouge">{ }</code>).</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre><code class="language-fhirpath">'http://fhir.org/guides/cqf/common/Library/FHIR-ModelInfo|4.0.1'.matches('Library') // returns true
'N8000123123'.matches('^N[0-9]{8}$') // returns false as the string is not an 8 char number (it has 10)
'N8000123123'.matches('N[0-9]{8}') // returns true as the string has an 8 number sequence in it starting with `N`
</code></pre>

<h4 id="matchesfullregex--string--boolean">matchesFull(regex : String) : Boolean</h4>

<blockquote class="stu-note">
  <p><strong>Note:</strong> The contents of this section are Standard for Trial Use (STU)</p>
</blockquote>

<p class="stu">Returns <code class="language-plaintext highlighter-rouge">true</code> when the value completely matches the given regular expression (implying that the start/end of line markers <code class="language-plaintext highlighter-rouge">^</code>, <code class="language-plaintext highlighter-rouge">$</code> are always surrounding the regex expression provided).</p>
<p class="stu">Regular expressions should function consistently, regardless of any culture- and locale-specific settings in the environment, should be case-sensitive, use 'single line' mode and allow Unicode characters.</p>

<p class="stu">If the input collection or <code class="language-plaintext highlighter-rouge">regex</code> are empty, the result is empty (<code class="language-plaintext highlighter-rouge">{ }</code>).</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">'http://fhir.org/guides/cqf/common/Library/FHIR-ModelInfo|4.0.1'.matchesFull('Library') // returns false
'N8000123123'.matchesFull('N[0-9]{8}') // returns false as the string is not an 8 char number (it has 10)
'N8000123123'.matchesFull('N[0-9]{10}') // returns true as the string has an 10 number sequence in it starting with `N`
</code></pre>

<h4 id="replacematchesregex--string-substitution-string--string">replaceMatches(regex : String, substitution: String) : String</h4>

<p>Matches the input using the regular expression in <code class="language-plaintext highlighter-rouge">regex</code> and replaces each match with the <code class="language-plaintext highlighter-rouge">substitution</code> string. The substitution may refer to identified match groups in the regular expression.</p>

<p>If the input collection, <code class="language-plaintext highlighter-rouge">regex</code>, or <code class="language-plaintext highlighter-rouge">substitution</code> are empty, the result is empty (<code class="language-plaintext highlighter-rouge">{ }</code>).</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>This example of <code class="language-plaintext highlighter-rouge">replaceMatches()</code> will convert a string with a date formatted as MM/dd/yy to dd-MM-yy:</p>

<pre><code class="language-fhirpath">'11/30/1972'.replaceMatches('\\b(?&lt;month&gt;\\d{1,2})/(?&lt;day&gt;\\d{1,2})/(?&lt;year&gt;\\d{2,4})\\b',
       '${day}-${month}-${year}')
</code></pre>

<blockquote>
  <p><strong>Note:</strong> Platforms will typically use native regular expression implementations. These are typically fairly similar, but there will always be small differences. As such, FHIRPath does not prescribe a particular dialect, but recommends the use of the <a href="#PCRE">[PCRE]</a> flavor as the dialect most likely to be broadly supported and understood.</p>
</blockquote>

<h4 id="length--integer">length() : Integer</h4>

<p>Returns the length of the input string. If the input collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is empty.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<h4 id="tochars--collection">toChars() : collection</h4>

<p>Returns the list of characters in the input string. If the input collection is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is empty.</p>

<p>If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre><code class="language-fhirpath">'abc'.toChars() // { 'a', 'b', 'c' }
</code></pre>

<h3 id="additional-string-functions">Additional String Functions</h3>

<blockquote class="stu-note">
  <p><strong>Note:</strong> The contents of this section are Standard for Trial Use (STU)</p>
</blockquote>

<h4 class="stu" id="encodeformat--string--string">encode(format : String) : String</h4>

<p class="stu">The encode function takes a singleton string and returns the result of encoding that string in the given format. The format parameter defines the encoding format. Available formats are:</p>

<table class="grid stu">
  <tbody>
    <tr>
      <td>hex</td>
      <td>The string is encoded using hexadecimal characters (base 16) in lowercase</td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <td>base64</td>
      <td>The string is encoded using standard base64 encoding, using A-Z, a-z, 0-9, +, and /, output padded with =)</td>
    </tr>
    <tr>
      <td>urlbase64</td>
      <td>The string is encoded using url base 64 encoding, using A-Z, a-z, 0-9, -, and _, output padded with =)</td>
    </tr>
  </tfoot>
</table>

<p class="stu">Base64 encodings are described in <a href="https://tools.ietf.org/html/rfc4648#section-4">RFC4648</a>.</p>

<p class="stu">If the input is empty, the result is empty.</p>

<p class="stu">If no format is specified, the result is empty.</p>

<h4 class="stu" id="decodeformat--string--string">decode(format : String) : String</h4>

<p class="stu">The decode function takes a singleton encoded string and returns the result of decoding that string according to the given format. The format parameter defines the encoding format. Available formats are listed in the encode function.</p>

<p class="stu">If the input is empty, the result is empty.</p>

<p class="stu">If no format is specified, the result is empty.</p>

<h4 class="stu" id="escapetarget--string--string">escape(target : String) : String</h4>

<p class="stu">The escape function takes a singleton string and escapes it for a given target, as specified in the following table:</p>

<table class="grid stu">
  <tbody>
    <tr>
      <td>html</td>
      <td>The string is escaped such that it can appear as valid HTML content (at least open bracket (<code class="language-plaintext highlighter-rouge">&lt;</code>), ampersand (<code class="language-plaintext highlighter-rouge">&amp;</code>), and quotes (<code class="language-plaintext highlighter-rouge">"</code>), but ideally anything with a character encoding above 127)</td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <td>json</td>
      <td>The string is escaped such that it can appear as a valid JSON string (quotes (<code class="language-plaintext highlighter-rouge">"</code>) are escaped as (<code class="language-plaintext highlighter-rouge">\"</code>)); additional escape characters are described in the <a href="#string">String</a> escape section</td>
    </tr>
  </tfoot>
</table>

<p class="stu">If the input is empty, the result is empty.</p>

<p class="stu">If no target is specified, the result is empty.</p>

<h4 class="stu" id="unescapetarget--string--string">unescape(target : String) : String</h4>

<p class="stu">The unescape function takes a singleton string and unescapes it for a given target. The available targets are specified in the escape function description.</p>

<p class="stu">If the input is empty, the result is empty.</p>

<p class="stu">If no target is specified, the result is empty.</p>

<h4 class="stu" id="trim--string">trim() : String</h4>

<p class="stu">The trim function trims whitespace characters from the beginning and ending of the input string, with whitespace characters as defined in the <a href="#whitespace">Whitespace</a> lexical category.</p>

<p class="stu">If the input is empty, the result is empty.</p>

<h4 class="stu" id="splitseparator-string--collection">split(separator: String) : collection</h4>

<p class="stu">The split function splits a singleton input string into a list of strings, using the given separator.</p>

<p class="stu">If the input is empty, the result is empty.</p>

<p class="stu">If the input string does not contain any appearances of the separator, the result is the input string.</p>

<p class="stu">The following example illustrates the behavior of the <code class="language-plaintext highlighter-rouge">.split</code> operator:</p>

<pre class="stu"><code class="language-fhirpath">('A,B,C').split(',') // { 'A', 'B', 'C' }
('ABC').split(',') // { 'ABC' }
'A,,C'.split(',') // { 'A', '', 'C' }
</code></pre>

<h4 class="stu" id="joinseparator-string--string">join([separator: String]) : String</h4>

<p class="stu">The join function takes a collection of strings and <em>joins</em> them into a single string, optionally using the given separator.</p>

<p class="stu">If the input is empty, the result is empty.</p>

<p class="stu">If no separator is specified, the strings are directly concatenated.</p>

<p class="stu">The following example illustrates the behavior of the <code class="language-plaintext highlighter-rouge">.join</code> operator:</p>

<pre class="stu"><code class="language-fhirpath">('A' | 'B' | 'C').join() // 'ABC'
('A' | 'B' | 'C').join(',') // 'A,B,C'
</code></pre>

<h3 id="math">Math</h3>

<blockquote class="stu-note">
  <p><strong>Note:</strong> The contents of this section are Standard for Trial Use (STU)</p>
</blockquote>

<p class="stu">The functions in this section operate on collections with a single item. Unless otherwise noted, if there is more than one item, or the item is not compatible with the expected type, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p class="stu">Note also that although all functions return collections, if a given function is defined to return a single element, the return type in the description of the function is simplified to just the type of the single element, rather than the list type.</p>

<p class="stu">The math functions in this section enable FHIRPath to be used not only for path selection, but for providing a platform-independent representation of calculation logic in artifacts such as questionnaires and documentation templates. For example:</p>

<pre class="stu"><code class="language-fhirpath">(%weight/(%height.power(2))).round(1)
</code></pre>

<p class="stu">This example from a questionnaire calculates the Body Mass Index (BMI) based on the responses to the weight and height elements. For more information on the use of FHIRPath in questionnaires, see the <a href="http://hl7.org/fhir/uv/sdc/">Structured Data Capture</a> (SDC) implementation guide.</p>

<h4 class="stu" id="abs--integer--decimal--quantity">abs() : Integer | Decimal | Quantity</h4>

<p class="stu">Returns the absolute value of the input. When taking the absolute value of a quantity, the unit is unchanged.</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">(-5).abs() // 5
(-5.5).abs() // 5.5
(-5.5 'mg').abs() // 5.5 'mg'
</code></pre>

<h4 class="stu" id="ceiling--integer">ceiling() : Integer</h4>

<p class="stu">Returns the first integer greater than or equal to the input.</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">1.ceiling() // 1
1.1.ceiling() // 2
(-1.1).ceiling() // -1
</code></pre>

<h4 class="stu" id="exp--decimal">exp() : Decimal</h4>

<p class="stu">Returns <em>e</em> raised to the power of the input.</p>

<p class="stu">If the input collection contains an Integer, it will be implicitly converted to a Decimal and the result will be a Decimal.</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">0.exp() // 1.0
(-0.0).exp() // 1.0
</code></pre>

<h4 class="stu" id="floor--integer">floor() : Integer</h4>

<p class="stu">Returns the first integer less than or equal to the input.</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">1.floor() // 1
2.1.floor() // 2
(-2.1).floor() // -3
</code></pre>

<h4 class="stu" id="ln--decimal">ln() : Decimal</h4>

<p class="stu">Returns the natural logarithm of the input (i.e. the logarithm base <em>e</em>).</p>

<p class="stu">When used with an Integer, it will be implicitly converted to a Decimal.</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">1.ln() // 0.0
1.0.ln() // 0.0
</code></pre>

<h4 class="stu" id="logbase--decimal--decimal">log(base : Decimal) : Decimal</h4>

<p class="stu">Returns the logarithm base <code class="language-plaintext highlighter-rouge">base</code> of the input number.</p>

<p class="stu">When used with Integers, the arguments will be implicitly converted to Decimal.</p>

<p class="stu">If <code class="language-plaintext highlighter-rouge">base</code> is empty, the result is empty.</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">16.log(2) // 4.0
100.0.log(10.0) // 2.0
</code></pre>

<h4 class="stu" id="powerexponent--integer--decimal--integer--decimal">power(exponent : Integer | Decimal) : Integer | Decimal</h4>

<p class="stu">Raises a number to the <code class="language-plaintext highlighter-rouge">exponent</code> power. If this function is used with Integers, the result is an Integer. If the function is used with Decimals, the result is a Decimal. If the function is used with a mixture of Integer and Decimal, the Integer is implicitly converted to a Decimal and the result is a Decimal.</p>

<p class="stu">If the power cannot be represented (such as the -1 raised to the 0.5), the result is empty.</p>

<p class="stu">If the input is empty, or exponent is empty, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">2.power(3) // 8
2.5.power(2) // 6.25
(-1).power(0.5) // empty ({ })
</code></pre>

<h4 id="roundprecision--integer--decimal">round([precision : Integer]) : Decimal</h4>

<blockquote class="stu-note">
  <p><strong>Note:</strong> The contents of this section are Standard for Trial Use (STU)</p>

  <p><a href="https://chat.fhir.org/#narrow/stream/179266-fhirpath/topic/round.28.29.20for.20negative.20numbers">Discussion on this topic</a> If you have specific proposals or feedback please log a change request.</p>
</blockquote>

<p class="stu">Rounds the decimal to the nearest whole number using a traditional round (i.e. 0.5 or higher will round to 1). If specified, the precision argument determines the decimal place at which the rounding will occur. If not specified, the rounding will default to 0 decimal places.</p>

<p class="stu">If specified, the number of digits of precision must be &gt;= 0 or the evaluation will end and signal an error to the calling environment.</p>

<p class="stu">If the input collection contains a single item of type Integer, it will be implicitly converted to a Decimal.</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">1.round() // 1
3.14159.round(3) // 3.142
</code></pre>

<h4 id="sqrt--decimal">sqrt() : Decimal</h4>

<blockquote class="stu-note">
  <p><strong>Note:</strong> The contents of this section are Standard for Trial Use (STU)</p>
</blockquote>

<p class="stu">Returns the square root of the input number as a Decimal.</p>

<p class="stu">If the square root cannot be represented (such as the square root of -1), the result is empty.</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p class="stu">Note that this function is equivalent to raising a number of the power of 0.5 using the power() function.</p>

<pre class="stu"><code class="language-fhirpath">81.sqrt() // 9.0
(-1).sqrt() // empty
</code></pre>

<h4 class="stu" id="truncate--integer">truncate() : Integer</h4>

<p class="stu">Returns the integer portion of the input.</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">101.truncate() // 101
1.00000001.truncate() // 1
(-1.56).truncate() // -1
</code></pre>

<h3 id="tree-navigation">Tree navigation</h3>

<h4 id="children--collection">children() : collection</h4>

<p>Returns a collection with all immediate child nodes of all items in the input collection. Note that the ordering of the children is undefined and using functions like <code class="language-plaintext highlighter-rouge">first()</code> on the result may return different results on different platforms.</p>

<h4 id="descendants--collection">descendants() : collection</h4>

<p>Returns a collection with all descendant nodes of all items in the input collection. The result does not include the nodes in the input collection themselves. This function is a shorthand for <code class="language-plaintext highlighter-rouge">repeat(children())</code>. Note that the ordering of the children is undefined and using functions like <code class="language-plaintext highlighter-rouge">first()</code> on the result may return different results on different platforms.</p>

<blockquote>
  <p><strong>Note:</strong> Many of these functions will result in a set of nodes of different underlying types. It may be necessary to use <code class="language-plaintext highlighter-rouge">ofType()</code> as described in the previous section to maintain type safety. See <a href="#type-safety-and-strict-evaluation">Type safety and strict evaluation</a> for more information about type safe use of FHIRPath expressions.</p>
</blockquote>

<h3 id="utility-functions">Utility functions</h3>

<h4 id="tracename--string--projection-expression--collection">trace(name : String [, projection: Expression]) : collection</h4>

<p>Adds a String representation of the input collection to the diagnostic log, using the <code class="language-plaintext highlighter-rouge">name</code> argument as the name in the log. This log should be made available to the user in some appropriate fashion. Does not change the input, so returns the input collection as output.</p>

<p>If the <code class="language-plaintext highlighter-rouge">projection</code> argument is used, the trace would log the result of evaluating the project expression on the input, but still return the input to the trace function unchanged.</p>

<pre><code class="language-fhirpath">contained.where(criteria).trace('unmatched', id).empty()
</code></pre>

<p>The above example traces only the id elements of the result of the where.</p>

<h4 id="current-date-and-time-functions">Current date and time functions</h4>

<p>The following functions return the current date and time. The timestamp that these functions use is an implementation decision, and implementations should consider providing options appropriate for their environment. In the simplest case, the local server time is used as the timestamp for these function.</p>

<p>To ensure deterministic evaluation, these operators should return the same value regardless of how many times they are evaluated within any given expression (i.e. now() should always return the same DateTime in a given expression, timeOfDay() should always return the same Time in a given expression, and today() should always return the same Date in a given expression.)</p>

<h5 id="now--datetime">now() : DateTime</h5>

<p>Returns the current date and time, including timezone offset.</p>

<h5 id="timeofday--time">timeOfDay() : Time</h5>

<p>Returns the current time.</p>

<h5 id="today--date">today() : Date</h5>

<p>Returns the current date.</p>

<p><a name="definevariable"></a></p>
<h4 id="definevariablename-string--expr-expression">defineVariable(name: String [, expr: expression])</h4>
<blockquote class="stu-note">
  <p><strong>Note:</strong> The contents of this section are Standard for Trial Use (STU)</p>
</blockquote>

<p class="stu">Defines a variable named <code class="language-plaintext highlighter-rouge">name</code> that is accessible in subsequent expressions and has the value of <code class="language-plaintext highlighter-rouge">expr</code> if present, otherwise the value of the input collection. In either case the function does not change the input and the output is the same as the input collection.</p>

<p class="stu">If the name already exists in the current expression scope, the evaluation will end and signal an error to the calling environment. Note that functions that take an <code class="language-plaintext highlighter-rouge">expression</code> as an argument establish a scope for the iteration variables ($this and $index). If a variable is defined within such an expression, it is only available within that expression scope.</p>

<p class="stu">Example:</p>
<pre class="stu"><code class="language-fhirpath">group.select(
  defineVariable('grp')
  .select(
    element.select(
      defineVariable('src')
      .target.select(
        %grp.source &amp; '#' &amp; %src.code
        &amp; ' ' &amp; equivalence &amp; ' '
        &amp; %grp.target &amp; '#' &amp; code
      )
    )
  )
)
</code></pre>

<blockquote class="stu">
  <p><strong>Note:</strong> this would be implemented using expression scoping on the variable stack and after expression completion the temporary variable would be popped off the stack.</p>
</blockquote>

<h4 class="stu" id="lowboundaryprecision-integer-decimal--date--datetime--time">lowBoundary([precision: Integer]): Decimal | Date | DateTime | Time</h4>

<p class="stu">The least possible value of the input to the specified precision.</p>

<p class="stu">The function can only be used with Decimal, Date, DateTime, and Time values, and returns the same type as the value in the input collection.</p>

<p class="stu">If no precision is specified, the greatest precision of the type of the input value is used (i.e. at least 8 for Decimal, 4 for Date, at least 17 for DateTime, and at least 9 for Time).</p>

<p class="stu">If the precision is greater than the maximum possible precision of the implementation, the result is empty <em>(CQL returns null)</em>.</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">1.587.lowBoundary(8) // 1.58700000
@2014.lowBoundary(6) // @2014-01
@2014-01-01T08.lowBoundary(17) // @2014-01-01T08:00:00.000
@T10:30.lowBoundary(9) // @T10:30:00.000
</code></pre>

<h4 class="stu" id="highboundaryprecision-integer-decimal--date--datetime--time">highBoundary([precision: Integer]): Decimal | Date | DateTime | Time</h4>

<p class="stu">The greatest possible value of the input to the specified precision.</p>

<p class="stu">The function can only be used with Decimal, Date, DateTime, and Time values, and returns the same type as the value in the input collection.</p>

<p class="stu">If no precision is specified, the greatest precision of the type of the input value is used (i.e. at least 8 for Decimal, 4 for Date, at least 17 for DateTime, and at least 9 for Time).</p>

<p class="stu">If the precision is greater than the maximum possible precision of the implementation, the result is empty <em>(CQL returns null)</em>.</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">1.587.highBoundary(8) // 1.58799999
@2014.highBoundary(6) // @2014-12
@2014-01-01T08.highBoundary(17) // @2014-01-01T08:59:59.999
@T10:30.highBoundary(9) // @T10:30:59.999
</code></pre>

<h4 class="stu" id="precision--integer">precision() : Integer</h4>

<p class="stu">If the input collection contains a single item, this function will return the number of digits of precision.</p>

<p class="stu">The function can only be used with Decimal, Date, DateTime, and Time values.</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p class="stu">For Decimal values, the function returns the number of digits of precision after the decimal place in the input value.</p>

<pre class="stu"><code class="language-fhirpath">1.58700.precision() // 5
</code></pre>

<p class="stu">For Date and DateTime values, the function returns the number of digits of precision in the input value.</p>

<pre class="stu"><code class="language-fhirpath">@2014.precision() // 4
@2014-01-05T10:30:00.000.precision() // 17
@T10:30.precision() // 4
@T10:30:00.000.precision() // 9
</code></pre>

<h4 class="stu" id="extract-datedatetimetime-components">Extract Date/DateTime/Time components</h4>

<h5 class="stu" id="yearof-integer">yearOf(): Integer</h5>
<p class="stu">If the input collection contains a single Date or DateTime, this function will return the year component.</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">@2014-01-05T10:30:00.000.yearOf() // 2014
</code></pre>

<h5 class="stu" id="monthof-integer">monthOf(): Integer</h5>

<p class="stu">If the input collection contains a single Date or DateTime, this function will return the month component.</p>

<p class="stu">If the input collection is empty, or the month is not present in the value, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">@2014-01-05T10:30:00.000.monthOf() // 1
</code></pre>

<p class="stu">If the component isn't present in the value, then the result is empty</p>
<pre class="stu"><code class="language-fhirpath">@2012.monthOf() // {} an empty collection
</code></pre>

<h5 class="stu" id="dayof-integer">dayOf(): Integer</h5>

<p class="stu">If the input collection contains a single Date or DateTime, this function will return the day component.</p>

<p class="stu">If the input collection is empty, or the day is not present in the value, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">@2014-01-05T10:30:00.000.dayOf() // 5
</code></pre>

<h5 class="stu" id="hourof-integer">hourOf(): Integer</h5>

<p class="stu">If the input collection contains a single Date, DateTime or Time, this function will return the hour component.</p>

<p class="stu">If the input collection is empty, or the hour is not present in the value, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">@2012-01-01T03:30:40.002-07:00.hourOf() // 3
@2012-01-01T16:30:40.002-07:00.hourOf() // 16
</code></pre>

<h5 class="stu" id="minuteof-integer">minuteOf(): Integer</h5>

<p class="stu">If the input collection contains a single Date, DateTime or Time, this function will return the minute component.</p>

<p class="stu">If the input collection is empty, or the minute is not present in the value, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">@2012-01-01T12:30:40.002-07:00.minuteOf() // 30
</code></pre>

<h5 class="stu" id="secondof-integer">secondOf(): Integer</h5>

<p class="stu">If the input collection contains a single Date, DateTime or Time, this function will return the second component.</p>

<p class="stu">If the input collection is empty, or the second is not present in the value, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">@2012-01-01T12:30:40.002-07:00.secondOf() // 40
</code></pre>

<h5 class="stu" id="millisecondof-integer">millisecondOf(): Integer</h5>

<p class="stu">If the input collection contains a single Date, DateTime or Time, this function will return the millisecond component.</p>

<p class="stu">If the input collection is empty, or the millisecond is not present in the value, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">@2012-01-01T12:30:00.002-07:00.millisecondOf() // 2
</code></pre>

<h5 class="stu" id="timezoneoffsetof-decimal">timezoneOffsetOf(): Decimal</h5>

<p class="stu">If the input collection contains a single DateTime, this function will return the timezone offset component.</p>

<p class="stu">If the input collection is empty, or the timezone offset is not present in the value, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">@2012-01-01T12:30:00.000-07:00.timezoneOffsetOf() // -7.0
</code></pre>

<h5 class="stu" id="dateof-date">dateOf(): Date</h5>

<p class="stu">If the input collection contains a single Date or DateTime, this function will return the date component (up to the precision present in the input value).</p>

<p class="stu">If the input collection is empty, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">@2012-01-01T12:30:00.000-07:00.dateOf() // @2012-01-01
</code></pre>

<h5 class="stu" id="timeof-time">timeOf(): Time</h5>

<p class="stu">If the input collection contains a single DateTime, this function will return the time component.</p>

<p class="stu">If the input collection is empty, or the time is not present in the value, the result is empty.</p>

<p class="stu">If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.</p>

<pre class="stu"><code class="language-fhirpath">@2012-01-01T12:30:00.000-07:00.timeOf() // @T12:30:00.000
</code></pre>

<h2 id="operations">Operations</h2>

<p>Operators are allowed to be used between any kind of path expressions (e.g. expr op expr). Like functions, operators will generally propagate an empty collection in any of their operands. This is true even when comparing two empty collections using the equality operators, e.g.</p>

<pre><code class="language-fhirpath">{} = {}
true &gt; {}
{} != 'dummy'
</code></pre>

<p>all result in <code class="language-plaintext highlighter-rouge">{}</code>.</p>

<h3 id="equality">Equality</h3>

<h4 id="-equals"><a name="equals"></a>= (Equals)</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> if the left collection is equal to the right collection:</p>

<p>As noted above, if either operand is an empty collection, the result is an empty collection. Otherwise:</p>

<p>If both operands are collections with a single item, they must be of the same type (or be implicitly convertible to the same type), and:</p>

<ul>
  <li>For primitives:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">String</code>: comparison is based on Unicode values</li>
      <li><code class="language-plaintext highlighter-rouge">Integer</code>: values must be exactly equal</li>
      <li><code class="language-plaintext highlighter-rouge">Decimal</code>: values must be equal, trailing zeroes after the decimal are ignored</li>
      <li><code class="language-plaintext highlighter-rouge">Boolean</code>: values must be the same</li>
      <li><code class="language-plaintext highlighter-rouge">Date</code>: must be exactly the same</li>
      <li><code class="language-plaintext highlighter-rouge">DateTime</code>: must be exactly the same, respecting the timezone offset (though +00:00 = -00:00 = Z)</li>
      <li><code class="language-plaintext highlighter-rouge">Time</code>: must be exactly the same</li>
    </ul>
  </li>
  <li>For complex types, equality requires all child properties to be equal, recursively.</li>
</ul>

<p>If both operands are collections with multiple items:</p>

<ul>
  <li>Each item must be equal</li>
  <li>Comparison is order dependent</li>
</ul>

<p>Otherwise, equals returns <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>Note that this implies that if the collections have a different number of items to compare, the result will be <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>Typically, this operator is used with single fixed values as operands. This means that <code class="language-plaintext fhirpath highlighter-rouge">Patient.telecom.system = 'phone'</code> will result in an error if there is more than one <code class="language-plaintext highlighter-rouge">telecom</code> with a <code class="language-plaintext highlighter-rouge">use</code>. Typically, you'd want <code class="language-plaintext fhirpath highlighter-rouge">Patient.telecom.where(system = 'phone')</code></p>

<p>If one or both of the operands is the empty collection, this operation returns an empty collection.</p>

<h5 id="quantity-equality">Quantity Equality</h5>

<p>When comparing quantities for equality, the dimensions of each quantity must be the same, but not necessarily the unit. For example, units of <code class="language-plaintext highlighter-rouge">'cm'</code> and <code class="language-plaintext highlighter-rouge">'m'</code> can be compared, but units of <code class="language-plaintext highlighter-rouge">'cm2'</code> and <code class="language-plaintext highlighter-rouge">'cm'</code> cannot. The comparison will be made using the most granular unit of either input. Attempting to operate on quantities with invalid units will result in empty (<code class="language-plaintext highlighter-rouge">{ }</code>).</p>

<p>For time-valued quantities, note that calendar durations and definite quantity durations above days (and weeks) are considered un-comparable:</p>

<pre><code class="language-fhirpath">1 year = 1 'a' // {} an empty collection
1 second = 1 's' // true
</code></pre>

<p>Implementations are not required to fully support operations on units, but they must at least respect units, recognizing when units differ.</p>

<p>Implementations that do support units shall do so as specified by <a href="#UCUM">[UCUM]</a>, as well as the calendar durations as defined in the toQuantity function.</p>

<h5 id="datetime-equality">Date/Time Equality</h5>

<p>For <code class="language-plaintext highlighter-rouge">Date</code>, <code class="language-plaintext highlighter-rouge">DateTime</code> and <code class="language-plaintext highlighter-rouge">Time</code> equality, the comparison is performed by considering each precision in order, beginning with years (or hours for time values), and respecting timezone offsets. If the values are the same, comparison proceeds to the next precision; if the values are different, the comparison stops and the result is <code class="language-plaintext highlighter-rouge">false</code>. If one input has a value for the precision and the other does not, the comparison stops and the result is empty (<code class="language-plaintext highlighter-rouge">{ }</code>); if neither input has a value for the precision, or the last precision has been reached, the comparison stops and the result is <code class="language-plaintext highlighter-rouge">true</code>. For the purposes of comparison, seconds and milliseconds are considered a single precision using a decimal, with decimal equality semantics.</p>

<p>For example:</p>

<pre><code class="language-fhirpath">@2012 = @2012 // returns true
@2012 = @2013 // returns false
@2012-01 = @2012 // returns empty ({ })
@2012-01-01T10:30 = @2012-01-01T10:30 // returns true
@2012-01-01T10:30 = @2012-01-01T10:31 // returns false
@2012-01-01T10:30:31 = @2012-01-01T10:30 // returns empty ({ })
@2012-01-01T10:30:31.0 = @2012-01-01T10:30:31 // returns true
@2012-01-01T10:30:31.1 = @2012-01-01T10:30:31 // returns false
</code></pre>

<p>For <code class="language-plaintext highlighter-rouge">DateTime</code> values that do not have a timezone offsets, whether or not to provide a default timezone offset is a policy decision. In the simplest case, no default timezone offset is provided, but some implementations may use the client's or the evaluating system's timezone offset.</p>

<p>To support comparison of DateTime values, either both values have no timezone offset specified, or both values are converted to a common timezone offset. The timezone offset to use is an implementation decision. In the simplest case, it's the timezone offset of the local server. The following examples illustrate expected behavior:</p>

<pre><code class="language-fhirpath">@2017-11-05T01:30:00.0-04:00 &gt; @2017-11-05T01:15:00.0-05:00 // false
@2017-11-05T01:30:00.0-04:00 &lt; @2017-11-05T01:15:00.0-05:00 // true
@2017-11-05T01:30:00.0-04:00 = @2017-11-05T01:15:00.0-05:00 // false
@2017-11-05T01:30:00.0-04:00 = @2017-11-05T00:30:00.0-05:00 // true
</code></pre>

<p>Additional functions to support more sophisticated timezone offset comparison (such as .toUTC()) may be defined in a future version.</p>

<h4 id="-equivalent">~ (Equivalent)</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> if the collections are the same. In particular, comparing empty collections for equivalence <code class="language-plaintext fhirpath highlighter-rouge">{ } ~ { }</code> will result in <code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>If both operands are collections with a single item, they must be of the same type (or implicitly convertible to the same type), and:</p>

<ul>
  <li>For primitives
    <ul>
      <li><code class="language-plaintext highlighter-rouge">String</code>: the strings must be the same, ignoring case and locale, and normalizing whitespace (see <a href="#string-equivalence">String Equivalence</a> for more details).</li>
      <li><code class="language-plaintext highlighter-rouge">Integer</code>: exactly equal</li>
      <li><code class="language-plaintext highlighter-rouge">Decimal</code>: values must be equal, comparison is done on values rounded to the precision of the least precise operand. Trailing zeroes after the decimal are ignored in determining precision.</li>
      <li><code class="language-plaintext highlighter-rouge">Date</code>, <code class="language-plaintext highlighter-rouge">DateTime</code> and <code class="language-plaintext highlighter-rouge">Time</code>: values must be equal, except that if the input values have different levels of precision, the comparison returns <code class="language-plaintext highlighter-rouge">false</code>, not empty (<code class="language-plaintext highlighter-rouge">{ }</code>).</li>
      <li><code class="language-plaintext highlighter-rouge">Boolean</code>: the values must be the same</li>
    </ul>
  </li>
  <li>For complex types, equivalence requires all child properties to be equivalent, recursively.</li>
</ul>

<p>If both operands are collections with multiple items:</p>

<ul>
  <li>Each item must be equivalent</li>
  <li>Comparison is not order dependent</li>
</ul>

<p>Note that this implies that if the collections have a different number of items to compare, or if one input is a value and the other is empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result will be <code class="language-plaintext highlighter-rouge">false</code>.</p>

<h5 id="quantity-equivalence">Quantity Equivalence</h5>

<p>When comparing quantities for equivalence, the dimensions of each quantity must be the same, but not necessarily the unit. For example, units of <code class="language-plaintext highlighter-rouge">'cm'</code> and <code class="language-plaintext highlighter-rouge">'m'</code> can be compared, but units of <code class="language-plaintext highlighter-rouge">'cm2'</code> and <code class="language-plaintext highlighter-rouge">'cm'</code> cannot. The comparison will be made using the most granular unit of either input. Attempting to operate on quantities with invalid units will result in <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>For time-valued quantities, calendar durations and definite quantity durations are considered equivalent:</p>

<pre><code class="language-fhirpath">1 year ~ 1 'a' // true
1 second ~ 1 's' // true
</code></pre>

<p>Implementations are not required to fully support operations on units, but they must at least respect units, recognizing when units differ.</p>

<p>Implementations that do support units shall do so as specified by <a href="#UCUM">[UCUM]</a> as well as the calendar durations as defined in the toQuantity function.</p>

<h5 id="datetime-equivalence">Date/Time Equivalence</h5>

<p>For <code class="language-plaintext highlighter-rouge">Date</code>, <code class="language-plaintext highlighter-rouge">DateTime</code> and <code class="language-plaintext highlighter-rouge">Time</code> equivalence, the comparison is the same as for equality, with the exception that if the input values have different levels of precision, the result is <code class="language-plaintext highlighter-rouge">false</code>, rather than empty (<code class="language-plaintext highlighter-rouge">{ }</code>). As with equality, the second and millisecond precisions are considered a single precision using a decimal, with decimal equivalence semantics.</p>

<p>For example:</p>

<pre><code class="language-fhirpath">@2012 ~ @2012 // returns true
@2012 ~ @2013 // returns false
@2012-01 ~ @2012 // returns false as well
@2012-01-01T10:30 ~ @2012-01-01T10:30 // returns true
@2012-01-01T10:30 ~ @2012-01-01T10:31 // returns false
@2012-01-01T10:30:31 ~ @2012-01-01T10:30 // returns false as well
@2012-01-01T10:30:31.0 ~ @2012-01-01T10:30:31 // returns true
@2012-01-01T10:30:31.1 ~ @2012-01-01T10:30:31 // returns false
</code></pre>

<h5 id="string-equivalence">String Equivalence</h5>

<p>For strings, equivalence returns true if the strings are the same value while ignoring case and locale, and normalizing whitespace. Normalizing whitespace means that all whitespace characters are treated as equivalent, with whitespace characters as defined in the <a href="#whitespace">Whitespace</a> lexical category.</p>

<h4 id="-not-equals">!= (Not Equals)</h4>

<p>The converse of the equals operator, returning <code class="language-plaintext highlighter-rouge">true</code> if equal returns <code class="language-plaintext highlighter-rouge">false</code>; <code class="language-plaintext highlighter-rouge">false</code> if equal returns <code class="language-plaintext highlighter-rouge">true</code>; and empty (<code class="language-plaintext highlighter-rouge">{ }</code>) if equal returns empty. In other words, <code class="language-plaintext fhirpath highlighter-rouge">A != B</code> is short-hand for <code class="language-plaintext fhirpath highlighter-rouge">(A = B).not()</code>.</p>

<h4 id="-not-equivalent">!~ (Not Equivalent)</h4>

<p>The converse of the equivalent operator, returning <code class="language-plaintext highlighter-rouge">true</code> if equivalent returns <code class="language-plaintext highlighter-rouge">false</code> and <code class="language-plaintext highlighter-rouge">false</code> is equivalent returns <code class="language-plaintext highlighter-rouge">true</code>. In other words, <code class="language-plaintext fhirpath highlighter-rouge">A !~ B</code> is short-hand for <code class="language-plaintext fhirpath highlighter-rouge">(A ~ B).not()</code>.</p>

<h3 id="comparison">Comparison</h3>

<ul>
  <li>The comparison operators are defined for strings, integers, decimals, quantities, dates, datetimes and times.</li>
  <li>If one or both of the arguments is an empty collection, a comparison operator will return an empty collection.</li>
  <li>Both arguments must be collections with single values, and the evaluator will throw an error if either collection has more than one item.</li>
  <li>Both arguments must be of the same type (or implicitly convertible to the same type), and the evaluator will throw an error if the types differ.</li>
  <li>When comparing integers and decimals, the integer will be converted to a decimal to make comparison possible.</li>
  <li>String ordering is strictly lexical and is based on the Unicode value of the individual characters.</li>
</ul>

<p>When comparing quantities, the dimensions of each quantity must be the same, but not necessarily the unit. For example, units of <code class="language-plaintext highlighter-rouge">'cm'</code> and <code class="language-plaintext highlighter-rouge">'m'</code> can be compared, but units of <code class="language-plaintext highlighter-rouge">'cm2'</code> and <code class="language-plaintext highlighter-rouge">'cm'</code> cannot. The comparison will be made using the most granular unit of either input. Attempting to operate on quantities with invalid units will result in empty (<code class="language-plaintext highlighter-rouge">{ }</code>).</p>

<p>For time-valued quantities, note that calendar durations and definite quantity durations above days (and weeks) are considered un-comparable:</p>

<pre><code class="language-fhirpath">1 year &gt; 1 `a` // { } (empty)
10 seconds &gt; 1 's' // true
</code></pre>

<p>Implementations are not required to fully support operations on units, but they must at least respect units, recognizing when units differ.</p>

<p>Implementations that do support units shall do so as specified by <a href="#UCUM">[UCUM]</a> as well as the calendar durations as defined in the toQuantity function.</p>

<p>For partial Date, DateTime, and Time values, the comparison is performed by comparing the values at each precision, beginning with years, and proceeding to the finest precision specified in either input, and respecting timezone offsets. If one value is specified to a different level of precision than the other, the result is empty (<code class="language-plaintext highlighter-rouge">{ }</code>) to indicate that the result of the comparison is unknown. As with equality and equivalence, the second and millisecond precisions are considered a single precision using a decimal, with decimal comparison semantics.</p>

<p>See the <a href="#equals">Equals</a> operator for discussion on respecting timezone offsets in comparison operations.</p>

<h4 id="-greater-than">&gt; (Greater Than)</h4>

<p>The greater than operator (<code class="language-plaintext highlighter-rouge">&gt;</code>) returns true if the first operand is strictly greater than the second. The operands must be of the same type, or convertible to the same type using an implicit conversion.</p>

<pre><code class="language-fhirpath">10 &gt; 5 // true
10 &gt; 5.0 // true; note the 10 is converted to a decimal to perform the comparison
'abc' &gt; 'ABC' // true
4 'm' &gt; 4 'cm' // true (or { } if the implementation does not support unit conversion)
@2018-03-01 &gt; @2018-01-01 // true
@2018-03 &gt; @2018-03-01 // empty ({ })
@2018-03-01T10:30:00 &gt; @2018-03-01T10:00:00 // true
@2018-03-01T10 &gt; @2018-03-01T10:30 // empty ({ })
@2018-03-01T10:30:00 &gt; @2018-03-01T10:30:00.0 // false
@T10:30:00 &gt; @T10:00:00 // true
@T10 &gt; @T10:30 // empty ({ })
@T10:30:00 &gt; @T10:30:00.0 // false
</code></pre>

<h4 id="-less-than">&lt; (Less Than)</h4>

<p>The less than operator (<code class="language-plaintext highlighter-rouge">&lt;</code>) returns true if the first operand is strictly less than the second. The operands must be of the same type, or convertible to the same type using implicit conversion.</p>

<pre><code class="language-fhirpath">10 &lt; 5 // false
10 &lt; 5.0 // false; note the 10 is converted to a decimal to perform the comparison
'abc' &lt; 'ABC' // false
4 'm' &lt; 4 'cm' // false (or { } if the implementation does not support unit conversion)
@2018-03-01 &lt; @2018-01-01 // false
@2018-03 &lt; @2018-03-01 // empty ({ })
@2018-03-01T10:30:00 &lt; @2018-03-01T10:00:00 // false
@2018-03-01T10 &lt; @2018-03-01T10:30 // empty ({ })
@2018-03-01T10:30:00 &lt; @2018-03-01T10:30:00.0 // false
@T10:30:00 &lt; @T10:00:00 // false
@T10 &lt; @T10:30 // empty ({ })
@T10:30:00 &lt; @T10:30:00.0 // false
</code></pre>

<h4 id="-less-or-equal">&lt;= (Less or Equal)</h4>

<p>The less or equal operator (<code class="language-plaintext highlighter-rouge">\&lt;=</code>) returns true if the first operand is less than or equal to the second. The operands must be of the same type, or convertible to the same type using implicit conversion.</p>

<pre><code class="language-fhirpath">10 &lt;= 5 // true
10 &lt;= 5.0 // true; note the 10 is converted to a decimal to perform the comparison
'abc' &lt;= 'ABC' // true
4 'm' &lt;= 4 'cm' // false (or { } if the implementation does not support unit conversion)
@2018-03-01 &lt;= @2018-01-01 // false
@2018-03 &lt;= @2018-03-01 // empty ({ })
@2018-03-01T10:30:00 &lt;= @2018-03-01T10:00:00 // false
@2018-03-01T10 &lt;= @2018-03-01T10:30 // empty ({ })
@2018-03-01T10:30:00 &lt;= @2018-03-01T10:30:00.0 // true
@T10:30:00 &lt;= @T10:00:00 // false
@T10 &lt;= @T10:30 // empty ({ })
@T10:30:00 &lt;= @T10:30:00.0 // true
</code></pre>

<h4 id="-greater-or-equal">&gt;= (Greater or Equal)</h4>

<p>The greater or equal operator (<code class="language-plaintext highlighter-rouge">&gt;=</code>) returns true if the first operand is greater than or equal to the second. The operands must be of the same type, or convertible to the same type using implicit conversion.</p>

<pre><code class="language-fhirpath">10 &gt;= 5 // false
10 &gt;= 5.0 // false; note the 10 is converted to a decimal to perform the comparison
'abc' &gt;= 'ABC' // false
4 'm' &gt;= 4 'cm' // true (or { } if the implementation does not support unit conversion)
@2018-03-01 &gt;= @2018-01-01 // true
@2018-03 &gt;= @2018-03-01 // empty ({ })
@2018-03-01T10:30:00 &gt;= @2018-03-01T10:00:00 // true
@2018-03-01T10 &gt;= @2018-03-01T10:30 // empty ({ })
@2018-03-01T10:30:00 &gt;= @2018-03-01T10:30:00.0 // true
@T10:30:00 &gt;= @T10:00:00 // true
@T10 &gt;= @T10:30 // empty ({ })
@T10:30:00 &gt;= @T10:30:00.0 // true
</code></pre>

<h3 id="types">Types</h3>

<h4 id="is-type-specifier">is <em>type specifier</em></h4>

<p>If the left operand is a collection with a single item and the second operand is a type identifier, this operator returns <code class="language-plaintext highlighter-rouge">true</code> if the type of the left operand is the type specified in the second operand, or a subclass thereof. If the input value is not of the type, this operator returns <code class="language-plaintext highlighter-rouge">false</code>. If the identifier cannot be resolved to a valid type identifier, the evaluator will throw an error. If the input collections contains more than one item, the evaluator will throw an error. In all other cases this operator returns <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>A <em>type specifier</em> is an identifier that must resolve to the name of a type in a model. Type specifiers can have qualifiers, e.g. <code class="language-plaintext highlighter-rouge">FHIR.Patient</code>, where the qualifier is the name of the model.</p>

<pre><code class="language-fhirpath">Bundle.entry.resource.all($this is Observation implies status = 'finished')
</code></pre>

<p>This example returns <code class="language-plaintext highlighter-rouge">true</code> if all Observation resources in the bundle have a status of finished.</p>

<h4 id="istype--type-specifier">is(type : <em>type specifier</em>)</h4>

<p>The <code class="language-plaintext highlighter-rouge">is()</code> function is supported for backwards compatibility with previous implementations of FHIRPath. Just as with the <code class="language-plaintext highlighter-rouge">is</code> keyword, the <code class="language-plaintext highlighter-rouge">type</code> argument is an identifier that must resolve to the name of a type in a model. For implementations with compile-time typing, this requires special-case handling when processing the argument to treat it as a type specifier rather than an identifier expression:</p>

<pre><code class="language-fhirpath">Bundle.entry.resource.all($this.is(Observation) implies status = 'finished')
</code></pre>

<blockquote>
  <p><strong>Note:</strong> The <code class="language-plaintext highlighter-rouge">is()</code> function is defined for backwards compatibility only and may be deprecated in a future release.</p>
</blockquote>

<h4 id="as-type-specifier">as <em>type specifier</em></h4>

<p>If the left operand is a collection with a single item and the second operand is an identifier, this operator returns the value of the left operand if it is of the type specified in the second operand, or a subclass thereof. If the identifier cannot be resolved to a valid type identifier, the evaluator will throw an error. If there is more than one item in the input collection, the evaluator will throw an error. Otherwise, this operator returns the empty collection.</p>

<p>A <em>type specifier</em> is an identifier that must resolve to the name of a type in a model. Type specifiers can have qualifiers, e.g. <code class="language-plaintext highlighter-rouge">FHIR.Patient</code>, where the qualifier is the name of the model.</p>

<pre><code class="language-fhirpath">Observation.component.where(value as Quantity &gt; 30 'mg')
</code></pre>

<h4 id="astype--type-specifier">as(type : <em>type specifier</em>)</h4>

<p>The <code class="language-plaintext highlighter-rouge">as()</code> function is supported for backwards compatibility with previous implementations of FHIRPath. Just as with the <code class="language-plaintext highlighter-rouge">as</code> keyword, the <code class="language-plaintext highlighter-rouge">type</code> argument is an identifier that must resolve to the name of a type in a model. For implementations with compile-time typing, this requires special-case handling when processing the argument to treat is a type specifier rather than an identifier expression:</p>

<pre><code class="language-fhirpath">Observation.component.where(value.as(Quantity) &gt; 30 'mg')
</code></pre>

<blockquote>
  <p><strong>Note:</strong> The <code class="language-plaintext highlighter-rouge">as()</code> function is defined for backwards compatibility only and may be deprecated in a future release.</p>
</blockquote>

<h3 id="collections-1">Collections</h3>

<h4 id="-union-collections">| (union collections)</h4>
<p>Merge the two collections into a single collection, eliminating any duplicate values (using <a href="#equals">equals</a> (<code class="language-plaintext highlighter-rouge">=</code>)) to determine equality). There is no expectation of order in the resulting collection.</p>

<p>See the <a href="#unionother-collection">union</a> function for more detail.</p>

<h4 id="in-membership">in (membership)</h4>
<p>If the left operand is a collection with a single item, this operator returns true if the item is in the right operand using equality semantics. If the left-hand side of the operator is empty, the result is empty, if the right-hand side is empty, the result is false. If the left operand has multiple items, an exception is thrown.</p>

<p>The following example returns true if <code class="language-plaintext highlighter-rouge">'Joe'</code> is in the list of given names for the Patient:</p>

<pre><code class="language-fhirpath">'Joe' in Patient.name.given
</code></pre>

<h4 id="contains-containership">contains (containership)</h4>
<p>If the right operand is a collection with a single item, this operator returns true if the item is in the left operand using equality semantics. If the right-hand side of the operator is empty, the result is empty, if the left-hand side is empty, the result is false. This is the converse operation of in.</p>

<p>The following example returns true if the list of given names for the Patient has <code class="language-plaintext highlighter-rouge">'Joe'</code> in it:</p>

<pre><code class="language-fhirpath">Patient.name.given contains 'Joe'
</code></pre>

<h3 id="boolean-logic">Boolean logic</h3>
<p>For all boolean operators, the collections passed as operands are first evaluated as Booleans (as described in <a href="#singleton-evaluation-of-collections">Singleton Evaluation of Collections</a>). The operators then use three-valued logic to propagate empty operands.</p>

<blockquote>
  <p><strong>Note:</strong> To ensure that FHIRPath expressions can be freely rewritten by underlying implementations, there is no expectation that an implementation respect short-circuit evaluation. With regard to performance, implementations may use short-circuit evaluation to reduce computation, but authors should not rely on such behavior, and implementations must not change semantics with short-circuit evaluation. If short-circuit evaluation is needed to avoid effects (e.g. runtime exceptions), use the <a href="#iif"><code class="language-plaintext highlighter-rouge">iif()</code></a> function.</p>
</blockquote>

<h4 id="and">and</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> if both operands evaluate to <code class="language-plaintext highlighter-rouge">true</code>, <code class="language-plaintext highlighter-rouge">false</code> if either operand evaluates to <code class="language-plaintext highlighter-rouge">false</code>, and the empty collection (<code class="language-plaintext highlighter-rouge">{ }</code>) otherwise.</p>

<table class="grid">
  <thead>
    <tr>
      <th>and</th>
      <th>true</th>
      <th>false</th>
      <th>empty</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>true</strong></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
      <td>empty (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
    </tr>
    <tr>
      <td><strong>false</strong></td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
    </tr>
    <tr>
      <td><strong>empty</strong></td>
      <td>empty (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
      <td>empty (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
    </tr>
  </tbody>
</table>

<h4 id="or">or</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">false</code> if both operands evaluate to <code class="language-plaintext highlighter-rouge">false</code>, <code class="language-plaintext highlighter-rouge">true</code> if either operand evaluates to <code class="language-plaintext highlighter-rouge">true</code>, and empty (<code class="language-plaintext highlighter-rouge">{ }</code>) otherwise:</p>

<table class="grid">
  <thead>
    <tr>
      <th>or</th>
      <th>true</th>
      <th>false</th>
      <th>empty</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>true</strong></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
    </tr>
    <tr>
      <td><strong>false</strong></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
      <td>empty (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
    </tr>
    <tr>
      <td><strong>empty</strong></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
      <td>empty (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
      <td>empty (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
    </tr>
  </tbody>
</table>

<h4 id="not--boolean">not() : Boolean</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> if the input collection evaluates to <code class="language-plaintext highlighter-rouge">false</code>, and <code class="language-plaintext highlighter-rouge">false</code> if it evaluates to <code class="language-plaintext highlighter-rouge">true</code>. Otherwise, the result is empty (<code class="language-plaintext highlighter-rouge">{ }</code>):</p>

<table class="grid">
  <thead>
    <tr>
      <th>not</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>true</strong></td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
    </tr>
    <tr>
      <td><strong>false</strong></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
    </tr>
    <tr>
      <td><strong>empty</strong></td>
      <td>empty (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
    </tr>
  </tbody>
</table>

<h4 id="xor">xor</h4>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> if exactly one of the operands evaluates to <code class="language-plaintext highlighter-rouge">true</code>, <code class="language-plaintext highlighter-rouge">false</code> if either both operands evaluate to <code class="language-plaintext highlighter-rouge">true</code> or both operands evaluate to <code class="language-plaintext highlighter-rouge">false</code>, and the empty collection (<code class="language-plaintext highlighter-rouge">{ }</code>) otherwise:</p>

<table class="grid">
  <thead>
    <tr>
      <th>xor</th>
      <th>true</th>
      <th>false</th>
      <th>empty</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>true</strong></td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
      <td>empty (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
    </tr>
    <tr>
      <td><strong>false</strong></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
      <td>empty (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
    </tr>
    <tr>
      <td><strong>empty</strong></td>
      <td>empty (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
      <td>empty (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
      <td>empty (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
    </tr>
  </tbody>
</table>

<h4 id="implies">implies</h4>

<p>If the left operand evaluates to <code class="language-plaintext highlighter-rouge">true</code>, this operator returns the boolean evaluation of the right operand. If the left operand evaluates to <code class="language-plaintext highlighter-rouge">false</code>, this operator returns <code class="language-plaintext highlighter-rouge">true</code>. Otherwise, this operator returns <code class="language-plaintext highlighter-rouge">true</code> if the right operand evaluates to <code class="language-plaintext highlighter-rouge">true</code>, and the empty collection (<code class="language-plaintext highlighter-rouge">{ }</code>) otherwise.</p>

<table class="grid">
  <thead>
    <tr>
      <th>implies</th>
      <th>true</th>
      <th>false</th>
      <th>empty</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>true</strong></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
      <td>empty (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
    </tr>
    <tr>
      <td><strong>false</strong></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
    </tr>
    <tr>
      <td><strong>empty</strong></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
      <td>empty (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
      <td>empty (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
    </tr>
  </tbody>
</table>

<p>The implies operator is useful for testing conditionals. For example, if a given name is present, then a family name must be as well:</p>

<pre><code class="language-fhirpath">Patient.name.given.exists() implies Patient.name.family.exists()
CareTeam.onBehalfOf.exists() implies (CareTeam.member.resolve() is Practitioner)
StructureDefinition.contextInvariant.exists() implies StructureDefinition.type = 'Extension'
</code></pre>

<p>Note that implies may use short-circuit evaluation in the case that the first operand evaluates to false.</p>

<h3 id="math-1">Math</h3>

<p>The math operators require each operand to be a single element. Both operands must be of the same type, or of compatible types according to the rules for implicit conversion. Each operator below specifies which types are supported.</p>

<p>If there is more than one item, or an incompatible item, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>As with the other operators, the math operators will return an empty collection if one or both of the operands are empty.</p>

<p>When operating on quantities, the dimensions of each quantity must be the same, but not necessarily the unit. For example, units of <code class="language-plaintext highlighter-rouge">'cm'</code> and <code class="language-plaintext highlighter-rouge">'m'</code> can be compared, but units of <code class="language-plaintext highlighter-rouge">'cm2'</code> and  <code class="language-plaintext highlighter-rouge">'cm'</code> cannot. The unit of the result will be the most granular unit of either input. Attempting to operate on quantities with invalid units will result in empty (<code class="language-plaintext highlighter-rouge">{ }</code>).</p>

<p>Implementations are not required to fully support operations on units, but they must at least respect units, recognizing when units differ.</p>

<p>Implementations that do support units shall do so as specified by <a href="#UCUM">[UCUM]</a> as well as the calendar durations as defined in the toQuantity function.</p>

<p>Operations that cause arithmetic overflow or underflow will result in empty (<code class="language-plaintext highlighter-rouge">{ }</code>).</p>

<h4 id="-multiplication">* (multiplication)</h4>

<p>Multiplies both arguments (supported for Integer, Decimal, and Quantity). For multiplication involving quantities, the resulting quantity will have the appropriate unit:</p>

<pre><code class="language-fhirpath">12 'cm' * 3 'cm' // 36 'cm2'
3 'cm' * 12 'cm2' // 36 'cm3'
</code></pre>

<h4 id="-division">/ (division)</h4>

<p>Divides the left operand by the right operand (supported for Integer, Decimal, and Quantity). The result of a division is always Decimal, even if the inputs are both Integer. For integer division, use the <code class="language-plaintext highlighter-rouge">div</code> operator.</p>

<p>If an attempt is made to divide by zero, the result is empty.</p>

<p>For division involving quantities, the resulting quantity will have the appropriate unit:</p>

<pre><code class="language-fhirpath">12 'cm2' / 3 'cm' // 4.0 'cm'
12 / 0 // empty ({ })
</code></pre>

<h4 id="-addition">+ (addition)</h4>

<p>For Integer, Decimal, and quantity, adds the operands. For strings, concatenates the right operand to the left operand.</p>

<p>When adding quantities, the dimensions of each quantity must be the same, but not necessarily the unit.</p>

<pre><code class="language-fhirpath">3 'm' + 3 'cm' // 303 'cm'
</code></pre>

<h4 id="--subtraction">- (subtraction)</h4>

<p>Subtracts the right operand from the left operand (supported for Integer, Decimal, and Quantity).</p>

<p>When subtracting quantities, the dimensions of each quantity must be the same, but not necessarily the unit.</p>

<pre><code class="language-fhirpath">3 'm' - 3 'cm' // 297 'cm'
</code></pre>

<h4 id="div">div</h4>

<p>Performs truncated division of the left operand by the right operand (supported for Integer and Decimal). In other words, the division that ignores any remainder:</p>

<pre><code class="language-fhirpath">5 div 2 // 2
5.5 div 0.7 // 7
5 div 0 // empty ({ })
</code></pre>

<h4 id="mod">mod</h4>

<p>Computes the remainder of the truncated division of its arguments (supported for Integer and Decimal).</p>

<pre><code class="language-fhirpath">5 mod 2 // 1
5.5 mod 0.7 // 0.6
5 mod 0 // empty ({ })
</code></pre>

<h4 id="-string-concatenation">&amp; (String concatenation)</h4>

<p>For strings, will concatenate the strings, where an empty operand is taken to be the empty string. This differs from <code class="language-plaintext highlighter-rouge">+</code> on two strings, which will result in an empty collection when one of the operands is empty. This operator is specifically included to simplify treating an empty collection as an empty string, a common use case in string manipulation.</p>

<pre><code class="language-fhirpath">'ABC' + 'DEF' // 'ABCDEF'
'ABC' + { } + 'DEF' // { }
'ABC' &amp; 'DEF' // 'ABCDEF'
'ABC' &amp; { } &amp; 'DEF' // 'ABCDEF'
</code></pre>

<h3 id="datetime-arithmetic">Date/Time Arithmetic</h3>

<p>Date and time arithmetic operators are used to add time-valued quantities to date/time values. The left operand must be a <code class="language-plaintext highlighter-rouge">Date</code>, <code class="language-plaintext highlighter-rouge">DateTime</code>, or <code class="language-plaintext highlighter-rouge">Time</code> value, and the right operand must be a <code class="language-plaintext highlighter-rouge">Quantity</code> with a time-valued unit:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">year</code>, <code class="language-plaintext highlighter-rouge">years</code></li>
  <li><code class="language-plaintext highlighter-rouge">month</code>, <code class="language-plaintext highlighter-rouge">months</code></li>
  <li><code class="language-plaintext highlighter-rouge">week</code>, <code class="language-plaintext highlighter-rouge">weeks</code></li>
  <li><code class="language-plaintext highlighter-rouge">day</code>, <code class="language-plaintext highlighter-rouge">days</code></li>
  <li><code class="language-plaintext highlighter-rouge">hour</code>, <code class="language-plaintext highlighter-rouge">hours</code></li>
  <li><code class="language-plaintext highlighter-rouge">minute</code>, <code class="language-plaintext highlighter-rouge">minutes</code></li>
  <li><code class="language-plaintext highlighter-rouge">second</code>, <code class="language-plaintext highlighter-rouge">seconds</code>, or <code class="language-plaintext highlighter-rouge">'s'</code></li>
  <li><code class="language-plaintext highlighter-rouge">millisecond</code>, <code class="language-plaintext highlighter-rouge">milliseconds</code>, or <code class="language-plaintext highlighter-rouge">'ms'</code></li>
</ul>

<p>To avoid the potential confusion of calendar-based date/time arithmetic with definite duration date/time arithmetic, FHIRPath defines definite-duration date/time arithmetic for seconds and below, and calendar-based date/time arithmetic for seconds and above. At the second, calendar-based and definite-duration-based date/time arithmetic are identical. If a definite-quantity duration above seconds appears in a date/time arithmetic calculation, the evaluation will end and signal an error to the calling environment.</p>

<p>Within FHIRPath, calculations involving date/times and calendar durations shall use calendar semantics as specified in <a href="#ISO8601">[ISO8601]</a>. Specifically:</p>

<table class="grid">
  <tbody>
    <tr>
      <td>year</td>
      <td>The year, positive or negative, is added to the year component of the date or time value. If the resulting year is out of range, an error is thrown. If the month and day of the date or time value is not a valid date in the resulting year, the last day of the calendar month is used.</td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <td>month</td>
      <td>The month, positive or negative is divided by 12, and the integer portion of the result is added to the year component. The remaining portion of months is added to the month component. If the resulting date is not a valid date in the resulting year, the last day of the resulting calendar month is used.</td>
    </tr>
    <tr>
      <td>week</td>
      <td>The week, positive or negative, is multiplied by 7, and the resulting value is added to the day component, respecting calendar month and calendar year lengths.</td>
    </tr>
    <tr>
      <td>day</td>
      <td>The day, positive or negative, is added to the day component, respecting calendar month and calendar year lengths.</td>
    </tr>
    <tr>
      <td>hour</td>
      <td>The hours, positive or negative, are added to the hour component, with each 24 hour block counting as a calendar day, and respecting calendar month and calendar year lengths.</td>
    </tr>
    <tr>
      <td>minute</td>
      <td>The minutes, positive or negative, are added to the minute component, with each 60 minute block counting as an hour, and respecting calendar month and calendar year lengths.</td>
    </tr>
    <tr>
      <td>second</td>
      <td>The seconds, positive or negative, are added to the second component, with each 60 second block counting as a minute, and respecting calendar month and calendar year lengths.</td>
    </tr>
    <tr>
      <td>millisecond</td>
      <td>The milliseconds, positive or negative, are added to the millisecond component, with each 1000 millisecond block counting as a second, and respecting calendar month and calendar year lengths.</td>
    </tr>
  </tfoot>
</table>

<p>If there is more than one item, or an item of an incompatible type, the evaluation of the expression will end and signal an error to the calling environment.</p>

<p>If either or both arguments are empty (<code class="language-plaintext highlighter-rouge">{ }</code>), the result is empty (<code class="language-plaintext highlighter-rouge">{ }</code>).</p>

<h4 id="-addition-1">+ (addition)</h4>

<p>Returns the value of the given <code class="language-plaintext highlighter-rouge">Date</code>, <code class="language-plaintext highlighter-rouge">DateTime</code>, or <code class="language-plaintext highlighter-rouge">Time</code>, incremented by the time-valued quantity, respecting variable length periods for calendar years and months.</p>

<p>For <code class="language-plaintext highlighter-rouge">Date</code> values, the quantity unit must be one of: <code class="language-plaintext highlighter-rouge">years</code>, <code class="language-plaintext highlighter-rouge">months</code>, <code class="language-plaintext highlighter-rouge">weeks</code>, or <code class="language-plaintext highlighter-rouge">days</code></p>

<p>For <code class="language-plaintext highlighter-rouge">DateTime</code> values, the quantity unit must be one of: <code class="language-plaintext highlighter-rouge">years</code>, <code class="language-plaintext highlighter-rouge">months</code>, <code class="language-plaintext highlighter-rouge">weeks</code>, <code class="language-plaintext highlighter-rouge">days</code>, <code class="language-plaintext highlighter-rouge">hours</code>, <code class="language-plaintext highlighter-rouge">minutes</code>, <code class="language-plaintext highlighter-rouge">seconds</code>, or <code class="language-plaintext highlighter-rouge">milliseconds</code> (or an equivalent unit), or the evaluation will end and signal an error to the calling environment.</p>

<p>For <code class="language-plaintext highlighter-rouge">Time</code> values, the quantity unit must be one of: <code class="language-plaintext highlighter-rouge">hours</code>, <code class="language-plaintext highlighter-rouge">minutes</code>, <code class="language-plaintext highlighter-rouge">seconds</code>, or <code class="language-plaintext highlighter-rouge">milliseconds</code> (or an equivalent unit), or the evaluation will end and signal an error to the calling environment.</p>

<p>For precisions above <code class="language-plaintext highlighter-rouge">seconds</code>, the decimal portion of the time-valued quantity is ignored, since date/time arithmetic above seconds is performed with calendar duration semantics.</p>

<p>For partial date/time values where the time-valued quantity is more precise than the partial date/time, the operation is performed by converting the time-valued quantity to the highest precision in the partial (removing any decimal value off) and then adding to the date/time value. For example:</p>

<pre><code class="language-fhirpath">@2014 + 24 months
@2019-03-01 + 24 months // @2021-03-01
</code></pre>

<p>The first example above will evaluate to the value <code class="language-plaintext highlighter-rouge">@2016</code> even though the date/time value is not specified to the level of precision of the time-valued quantity. The second example will evaluate to <code class="language-plaintext highlighter-rouge">@2021-03-01</code>.</p>

<pre><code class="language-fhirpath">@2014 + 23 months
@2016 + 365 days
</code></pre>

<p>The first example above returns @2015, because 23 months only constitutes one year. The second example returns 2017 because even though 2016 is a leap-year, the time-valued quantity (<code class="language-plaintext highlighter-rouge">365 days</code>) is converted to <code class="language-plaintext highlighter-rouge">1 year</code>, a standard calendar year of 365 days.</p>

<p>Calculations involving weeks are equivalent to multiplying the number of weeks by 7 and performing the calculation for the resulting number of days.</p>

<h4 id="--subtraction-1">- (subtraction)</h4>

<p>Returns the value of the given <code class="language-plaintext highlighter-rouge">Date</code>, <code class="language-plaintext highlighter-rouge">DateTime</code>, or <code class="language-plaintext highlighter-rouge">Time</code>, decremented by the time-valued quantity, respecting variable length periods for calendar years and months.</p>

<p>For <code class="language-plaintext highlighter-rouge">Date</code> values, the quantity unit must be one of: <code class="language-plaintext highlighter-rouge">years</code>, <code class="language-plaintext highlighter-rouge">months</code>, <code class="language-plaintext highlighter-rouge">weeks</code>, or <code class="language-plaintext highlighter-rouge">days</code></p>

<p>For <code class="language-plaintext highlighter-rouge">DateTime</code> values, the quantity unit must be one of: <code class="language-plaintext highlighter-rouge">years</code>, <code class="language-plaintext highlighter-rouge">months</code>, <code class="language-plaintext highlighter-rouge">weeks</code>, <code class="language-plaintext highlighter-rouge">days</code>, <code class="language-plaintext highlighter-rouge">hours</code>, <code class="language-plaintext highlighter-rouge">minutes</code>, <code class="language-plaintext highlighter-rouge">seconds</code>, or <code class="language-plaintext highlighter-rouge">milliseconds</code> (or an equivalent unit), or the evaluation will end and signal an error to the calling environment.</p>

<p>For <code class="language-plaintext highlighter-rouge">Time</code> values, the quantity unit must be one of: <code class="language-plaintext highlighter-rouge">hours</code>, <code class="language-plaintext highlighter-rouge">minutes</code>, <code class="language-plaintext highlighter-rouge">seconds</code>, or <code class="language-plaintext highlighter-rouge">milliseconds</code> (or an equivalent unit), or the evaluation will end and signal an error to the calling environment.</p>

<p>For precisions above <code class="language-plaintext highlighter-rouge">seconds</code>, the decimal portion of the time-valued quantity is ignored, since date/time arithmetic above seconds is performed with calendar duration semantics.</p>

<p>For partial date/time values where the time-valued quantity is more precise than the partial date/time, the operation is performed by converting the time-valued quantity to the highest precision in the partial (removing any decimal value off) and then subtracting from the date/time value. For example:</p>

<pre><code class="language-fhirpath">@2014 - 24 months
@2019-03-01 - 24 months // @2017-03-01
</code></pre>

<p>The first example above will evaluate to the value <code class="language-plaintext highlighter-rouge">@2012</code> even though the date/time value is not specified to the level of precision of the time-valued quantity. The second example will evaluate to <code class="language-plaintext highlighter-rouge">@2017-03-01</code>.</p>

<p>Calculations involving weeks are equivalent to multiplying the number of weeks by 7 and performing the calculation for the resulting number of days.</p>

<h3 id="operator-precedence">Operator precedence</h3>

<p>Precedence of operations, in order from high to low:</p>

<pre><code class="language-txt">#01 . (path/function invocation)
#02 [] (indexer)
#03 unary + and -
#04: *, /, div, mod
#05: +, -, &amp;
#06: is, as
#07: |
#08: &gt;, &lt;, &gt;=, &lt;=
#09: =, ~, !=, !~
#10: in, contains
#11: and
#12: xor, or
#13: implies
</code></pre>

<p>As customary, precedence may be established explicitly using parentheses (<code class="language-plaintext highlighter-rouge">( )</code>).</p>

<p>As an example, consider the following expression:</p>

<pre><code class="language-fhirpath">-7.combine(3)
</code></pre>

<p>Because the invocation operator (<code class="language-plaintext highlighter-rouge">.</code>) has a higher precedence than the unary negation (<code class="language-plaintext highlighter-rouge">-</code>), the unary negation will be applied to the result of the combine of 7 and 3, resulting in an error (because unary negation cannot be applied to a list):</p>

<pre><code class="language-fhirpath">-(7.combine(3)) // ERROR
</code></pre>

<p>Use parentheses to ensure the unary negation applies to the <code class="language-plaintext highlighter-rouge">7</code>:</p>

<pre><code class="language-fhirpath">(-7).combine(3) // { -7, 3 }
</code></pre>

<h2 id="aggregates">Aggregates</h2>

<blockquote class="stu-note">
  <p><strong>Note:</strong> The contents of this section are Standard for Trial Use (STU)</p>
</blockquote>

<p class="stu">FHIRPath supports a general-purpose aggregate function to enable the calculation of aggregates such as sum, min, and max to be expressed:</p>

<h3 class="stu" id="aggregateaggregator--expression--init--value--value">aggregate(aggregator : expression [, init : value]) : value</h3>
<p class="stu">Performs general-purpose aggregation by evaluating the aggregator expression for each element of the input collection. Within this expression, the standard iteration variables of <code class="language-plaintext highlighter-rouge">$this</code> and <code class="language-plaintext highlighter-rouge">$index</code> can be accessed, but also a <code class="language-plaintext highlighter-rouge">$total</code> aggregation variable.</p>

<p class="stu">The value of the <code class="language-plaintext highlighter-rouge">$total</code> variable is set to <code class="language-plaintext highlighter-rouge">init</code>, or empty (<code class="language-plaintext highlighter-rouge">{ }</code>) if no <code class="language-plaintext highlighter-rouge">init</code> value is supplied, and is set to the result of the aggregator expression after every iteration.<br />
The result of the aggregate function is the value of <code class="language-plaintext highlighter-rouge">$total</code> after the last iteration.</p>

<p class="stu">Using this function, sum can be expressed as:</p>

<pre class="stu"><code class="language-fhirpath">value.aggregate($this + $total, 0)
</code></pre>

<p class="stu">Min can be expressed as:</p>

<pre class="stu"><code class="language-fhirpath">value.aggregate(iif($total.empty(), $this, iif($this &lt; $total, $this, $total)))
</code></pre>

<p class="stu">and average would be expressed as:</p>

<pre class="stu"><code class="language-fhirpath">value.aggregate($total + $this, 0) / value.count()
</code></pre>

<h2 id="lexical-elements">Lexical Elements</h2>
<p>FHIRPath defines the following lexical elements:</p>

<table class="grid">
  <thead>
    <tr>
      <th>Element</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Whitespace</strong></td>
      <td>Whitespace defines the separation between tokens in the language</td>
    </tr>
    <tr>
      <td><strong>Comment</strong></td>
      <td>Comments are ignored by the language, allowing for descriptive text</td>
    </tr>
    <tr>
      <td><strong>Literal</strong></td>
      <td>Literals allow basic values to be represented within the language</td>
    </tr>
    <tr>
      <td><strong>Symbol</strong></td>
      <td>Symbols such as <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code>, and <code class="language-plaintext highlighter-rouge">/</code></td>
    </tr>
    <tr>
      <td><strong>Keyword</strong></td>
      <td>Grammar-recognized tokens such as <code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">or</code> and <code class="language-plaintext highlighter-rouge">in</code></td>
    </tr>
    <tr>
      <td><strong>Identifier</strong></td>
      <td>Labels such as type names and property names</td>
    </tr>
  </tbody>
</table>

<h3 id="whitespace">Whitespace</h3>
<p>FHIRPath defines <em>tab</em> (<code class="language-plaintext highlighter-rouge">\t</code>), <em>space</em> (<code class="language-plaintext highlighter-rouge"></code>), <em>line feed</em> (<code class="language-plaintext highlighter-rouge">\n</code>) and <em>carriage return</em> (<code class="language-plaintext highlighter-rouge">\r</code>) as <em>whitespace</em>, meaning they are only used to separate other tokens within the language. Any number of whitespace characters can appear, and the language does not use whitespace for anything other than delimiting tokens.</p>

<h3 id="comments">Comments</h3>
<p>FHIRPath defines two styles of comments, <em>single-line</em>, and <em>multi-line</em>. A single-line comment consists of two forward slashes, followed by any text up to the end of the line:</p>

<pre><code class="language-fhirpath">2 + 2 // This is a single-line comment
</code></pre>

<p>To begin a multi-line comment, the typical forward slash-asterisk token is used. The comment is closed with an asterisk-forward slash, and everything enclosed is ignored:</p>

<pre><code class="language-fhirpath">/*
This is a multi-line comment
Any text enclosed within is ignored
*/
</code></pre>

<h3 id="literals-1">Literals</h3>
<p>Literals provide for the representation of values within FHIRPath. The following types of literals are supported:</p>

<table class="grid">
  <thead>
    <tr>
      <th>Literal</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Empty</strong> (<code class="language-plaintext highlighter-rouge">{ }</code>)</td>
      <td>The empty collection</td>
    </tr>
    <tr>
      <td><strong><a href="#boolean">Boolean</a></strong></td>
      <td>The boolean literals (<code class="language-plaintext highlighter-rouge">true</code> and <code class="language-plaintext highlighter-rouge">false</code>)</td>
    </tr>
    <tr>
      <td><strong><a href="#integer">Integer</a></strong></td>
      <td>Sequences of digits in the range 0..2<sup>32</sup>-1</td>
    </tr>
    <tr>
      <td><strong><a href="#decimal">Decimal</a></strong></td>
      <td>Sequences of digits with a decimal point, in the range (-10<sup>28</sup>+1)/10<sup>8</sup>..(10<sup>28</sup>-1)/10<sup>8</sup></td>
    </tr>
    <tr>
      <td><strong><a href="#string">String</a></strong></td>
      <td>Strings of any character enclosed within single-ticks (<code class="language-plaintext highlighter-rouge">'</code>)</td>
    </tr>
    <tr>
      <td><strong><a href="#date">Date</a></strong></td>
      <td>The at-symbol (<code class="language-plaintext highlighter-rouge">@</code>) followed by a date (<strong>YYYY-MM-DD</strong>)</td>
    </tr>
    <tr>
      <td><strong><a href="#datetime">DateTime</a></strong></td>
      <td>The at-symbol (<code class="language-plaintext highlighter-rouge">@</code>) followed by a datetime (<strong>YYYY-MM-DDThh:mm:ss.fff(+|-)hh:mm</strong>)</td>
    </tr>
    <tr>
      <td><strong><a href="#time">Time</a></strong></td>
      <td>The at-symbol (<code class="language-plaintext highlighter-rouge">@</code>) followed by a time (<strong>Thh:mm:ss.fff(+|-)hh:mm</strong>)</td>
    </tr>
    <tr>
      <td><strong><a href="#quantity">Quantity</a></strong></td>
      <td>An integer or decimal literal followed by a datetime precision specifier, or a <a href="#UCUM">[UCUM]</a> unit specifier</td>
    </tr>
  </tbody>
</table>

<p>For a more detailed discussion of the semantics of each type, refer to the link for each type.</p>

<h3 id="symbols">Symbols</h3>
<p>Symbols provide structure to the language and allow symbolic invocation of common operators such as addition. FHIRPath defines the following symbols:</p>

<table class="grid">
  <thead>
    <tr>
      <th>Symbol</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">()</code></td>
      <td>Parentheses for delimiting groups within expressions</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">[]</code></td>
      <td>Brackets for indexing into lists and strings</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">{}</code></td>
      <td>Braces for delimiting exclusively empty lists</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">.</code></td>
      <td>Period for qualifiers, accessors, and dot-invocation</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">,</code></td>
      <td>Comma for delimiting items in a syntactic list</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">= != \&lt;= &lt; &gt; &gt;=</code></td>
      <td>Comparison operators for comparing values</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">+ - * / \| &amp;</code></td>
      <td>Arithmetic and other operators for performing computation</td>
    </tr>
  </tbody>
</table>

<h3 id="keywords">Keywords</h3>
<p>Keywords are tokens that are recognized by the parser and used to build the various language constructs. FHIRPath defines the following keywords:</p>

<table class="grid">
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">$index</code></td>
      <td><code class="language-plaintext highlighter-rouge">div</code></td>
      <td><code class="language-plaintext highlighter-rouge">milliseconds</code></td>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">$this</code></td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
      <td><code class="language-plaintext highlighter-rouge">minute</code></td>
      <td><code class="language-plaintext highlighter-rouge">week</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">$total</code></td>
      <td><code class="language-plaintext highlighter-rouge">hour</code></td>
      <td><code class="language-plaintext highlighter-rouge">minutes</code></td>
      <td><code class="language-plaintext highlighter-rouge">weeks</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">and</code></td>
      <td><code class="language-plaintext highlighter-rouge">hours</code></td>
      <td><code class="language-plaintext highlighter-rouge">mod</code></td>
      <td><code class="language-plaintext highlighter-rouge">xor</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">as</code></td>
      <td><code class="language-plaintext highlighter-rouge">implies</code></td>
      <td><code class="language-plaintext highlighter-rouge">month</code></td>
      <td><code class="language-plaintext highlighter-rouge">year</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">contains</code></td>
      <td><code class="language-plaintext highlighter-rouge">in</code></td>
      <td><code class="language-plaintext highlighter-rouge">months</code></td>
      <td><code class="language-plaintext highlighter-rouge">years</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">day</code></td>
      <td><code class="language-plaintext highlighter-rouge">is</code></td>
      <td><code class="language-plaintext highlighter-rouge">or</code></td>
      <td><code class="language-plaintext highlighter-rouge">second</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">days</code></td>
      <td><code class="language-plaintext highlighter-rouge">millisecond</code></td>
      <td><code class="language-plaintext highlighter-rouge">seconds</code></td>
      <td> </td>
    </tr>
  </tfoot>
</table>

<p>In general, keywords within FHIRPath are also considered <em>reserved</em> words, meaning that it is illegal to use them as identifiers. FHIRPath keywords are reserved words, with the exception of the following keywords that may also be used as identifiers:</p>

<table class="grid">
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">as</code></td>
      <td><code class="language-plaintext highlighter-rouge">contains</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">is</code></td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>If necessary, identifiers that clash with a reserved word can be delimited using a backtick (<code class="language-plaintext highlighter-rouge">`</code>):</p>

<pre><code class="language-fhirpath">Patient.text.`div`.empty()
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">div</code> element of the <code class="language-plaintext highlighter-rouge">Patient.text</code> must be offset with backticks (<code class="language-plaintext highlighter-rouge">`</code>) because <code class="language-plaintext highlighter-rouge">div</code> is both a keyword and a reserved word.</p>

<h3 id="identifiers">Identifiers</h3>
<p>Identifiers are used as labels to allow expressions to reference elements such as model types and properties. FHIRPath supports two types of identifiers, <em>simple</em> and <em>delimited</em>.</p>

<p>A simple identifier is any alphabetical character or an underscore, followed by any number of alpha-numeric characters or underscores. For example, the following are all valid simple identifiers:</p>

<pre><code class="language-fhirpath">Patient
_id
valueDateTime
_1234
</code></pre>

<p>A delimited identifier is any sequence of characters enclosed in backticks (<code class="language-plaintext highlighter-rouge">`</code>):</p>

<pre><code class="language-fhirpath">`QI-Core Patient`
`US-Core Diagnostic Request`
`us-zip`
</code></pre>

<p>The use of backticks allows identifiers to contains spaces, commas, and other characters that would not be allowed within simple identifiers. This allows identifiers to be more descriptive, and also enables expressions to reference models that have property or type names that are not valid simple identifiers.</p>

<p>FHIRPath <a href="#string">escape sequences</a> for strings also work for delimited identifiers.</p>

<p>When resolving an identifier that is also the root of a FHIRPath expression, it is resolved as a type name first, and if it resolves to a type, it must resolve to the type of the context (or a supertype). Otherwise, it is resolved as a path on the context. If the identifier cannot be resolved, the evaluation will end and signal an error to the calling environment.</p>

<h3 id="case-sensitivity">Case-Sensitivity</h3>
<p>FHIRPath is a case-sensitive language, meaning that case is considered when matching keywords in the language. However, because FHIRPath can be used with different models, the case-sensitivity of type and property names is defined by each model.</p>

<h2 id="environment-variables">Environment variables</h2>

<p>A token introduced by a % refers to a value that is passed into the evaluation engine by the calling environment. Using environment variables, authors can avoid repetition of fixed values and can pass in external values and data.</p>

<p>The following environmental values are set for all contexts:</p>

<pre><code class="language-fhirpath">%ucum       // (string) url for UCUM (http://unitsofmeasure.org, per http://hl7.org/fhir/ucum.html)
%context    // The original node that was passed to the evaluation engine before starting evaluation
</code></pre>

<p>Implementers should note that using additional environment variables is a formal extension point for the language. Various usages of FHIRPath may define their own externals, and implementers should provide some appropriate configuration framework to allow these constants to be provided to the evaluation engine at run-time. E.g.:</p>

<pre><code class="language-fhirpath">%`us-zip` = '[0-9]{5}(-[0-9]{4}){0,1}'
</code></pre>

<p>Note that the identifier portion of the token is allowed to be either a simple identifier (as in <code class="language-plaintext highlighter-rouge">%ucum</code>), or a delimited identifier to allow for alternative characters (as in <code class="language-plaintext highlighter-rouge">%`us-zip`</code>).</p>

<p>Note also that these tokens are not restricted to simple types, and they may have values that are not defined fixed values known prior to evaluation at run-time, though there is no way to define these kind of values in implementation guides.</p>

<p>Attempting to access an undefined environment variable will result in an error, but accessing a defined environment variable that does not have a value specified results in empty (<code class="language-plaintext highlighter-rouge">{ }</code>).</p>

<blockquote>
  <p><strong>Note:</strong> For backwards compatibility with some existing implementations, the token for an environment variable may also be a string, as in <code class="language-plaintext highlighter-rouge">%'us-zip'</code>, with no difference in semantics.</p>
</blockquote>

<h2 id="types-and-reflection">Types and Reflection</h2>

<h3 id="models">Models</h3>

<p>Because FHIRPath is defined to work in multiple contexts, each context provides the definition for the structures available in that context. These structures are the <em>model</em> available for FHIRPath expressions. For example, within FHIR, the FHIR data types and resources are the model. To prevent namespace clashes, the type names within each model are prefixed (or namespaced) with the name of the model. For example, the fully qualified name of the Patient resource in FHIR is <code class="language-plaintext highlighter-rouge">FHIR.Patient</code>. The system types defined within FHIRPath directly are prefixed with the namespace <code class="language-plaintext highlighter-rouge">System</code>.</p>

<p>To allow type names to be referenced in expressions such as the <code class="language-plaintext highlighter-rouge">is</code> and <code class="language-plaintext highlighter-rouge">as</code> operators, the language includes a <em>type specifier</em>, an optionally qualified identifier that must resolve to the name of a model type.</p>

<p>When resolving a type name, the context-specific model is searched first. If no match is found, the <code class="language-plaintext highlighter-rouge">System</code> model (containing only the built-in types defined in the <a href="#literals">Literals</a> section) is searched.</p>

<p>When resolving an identifier that is also the root of a FHIRPath expression, it is resolved as a type name first, and if it resolves to a type, it must resolve to the type of the context (or a supertype). Otherwise, it is resolved as a path on the context.</p>

<h3 id="reflection">Reflection</h3>

<blockquote class="stu-note">
  <p><strong>Note:</strong> The contents of this section are Standard for Trial Use (STU)</p>
</blockquote>

<p class="stu">FHIRPath supports reflection to provide the ability for expressions to access type information describing the structure of values. The <code class="language-plaintext highlighter-rouge">type()</code> function returns the type information for each element of the input collection, using one of the following concrete subtypes of <code class="language-plaintext highlighter-rouge">TypeInfo</code>:</p>

<h4 class="stu" id="primitive-types">Primitive Types</h4>

<p class="stu">For primitive types such as <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">Integer</code>, the result is a <code class="language-plaintext highlighter-rouge">SimpleTypeInfo</code>:</p>

<div class="language-typescript stu highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">SimpleTypeInfo</span> <span class="p">{</span> <span class="nl">namespace</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">baseType</span><span class="p">:</span> <span class="nx">TypeSpecifier</span> <span class="p">}</span>
</code></pre></div></div>

<p class="stu">For example:</p>

<pre class="stu"><code class="language-fhirpath">('John' | 'Mary').type()
</code></pre>

<p class="stu">Results in:</p>
<div class="language-typescript stu highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nx">SimpleTypeInfo</span> <span class="p">{</span> <span class="nl">namespace</span><span class="p">:</span> <span class="dl">'</span><span class="s1">System</span><span class="dl">'</span><span class="p">,</span> <span class="nx">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">String</span><span class="dl">'</span><span class="p">,</span> <span class="nx">baseType</span><span class="p">:</span> <span class="dl">'</span><span class="s1">System.Any</span><span class="dl">'</span> <span class="p">},</span>
  <span class="nx">SimpleTypeInfo</span> <span class="p">{</span> <span class="nl">namespace</span><span class="p">:</span> <span class="dl">'</span><span class="s1">System</span><span class="dl">'</span><span class="p">,</span> <span class="nx">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">String</span><span class="dl">'</span><span class="p">,</span> <span class="nx">baseType</span><span class="p">:</span> <span class="dl">'</span><span class="s1">System.Any</span><span class="dl">'</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 class="stu" id="class-types">Class Types</h4>

<p class="stu">For class types, the result is a <code class="language-plaintext highlighter-rouge">ClassInfo</code>:</p>

<div class="language-typescript stu highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">ClassInfoElement</span> <span class="p">{</span> <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="kd">type</span><span class="p">:</span> <span class="nx">TypeSpecifier</span><span class="p">,</span> <span class="nx">isOneBased</span><span class="p">:</span> <span class="nb">Boolean</span> <span class="p">}</span>
<span class="nx">ClassInfo</span> <span class="p">{</span> <span class="nl">namespace</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">baseType</span><span class="p">:</span> <span class="nx">TypeSpecifier</span><span class="p">,</span> <span class="nx">element</span><span class="p">:</span> <span class="nx">List</span><span class="o">&lt;</span><span class="nx">ClassInfoElement</span><span class="o">&gt;</span> <span class="p">}</span>
</code></pre></div></div>

<p class="stu">For example:</p>

<pre class="stu"><code class="language-fhirpath">Patient.maritalStatus.type()
</code></pre>

<p class="stu">Results in:</p>

<div class="language-typescript stu highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nx">ClassInfo</span> <span class="p">{</span>
    <span class="nl">namespace</span><span class="p">:</span> <span class="dl">'</span><span class="s1">FHIR</span><span class="dl">'</span><span class="p">,</span>
    <span class="nx">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">CodeableConcept</span><span class="dl">'</span><span class="p">,</span>
    <span class="nx">baseType</span><span class="p">:</span> <span class="dl">'</span><span class="s1">FHIR.Element</span><span class="dl">'</span><span class="p">,</span>
    <span class="nx">element</span><span class="p">:</span> <span class="p">{</span>
      <span class="nx">ClassInfoElement</span> <span class="p">{</span> <span class="nl">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">coding</span><span class="dl">'</span><span class="p">,</span> <span class="kd">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">List&lt;Coding&gt;</span><span class="dl">'</span><span class="p">,</span> <span class="nx">isOneBased</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span>
      <span class="nx">ClassInfoElement</span> <span class="p">{</span> <span class="nl">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">text</span><span class="dl">'</span><span class="p">,</span> <span class="kd">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">FHIR.string</span><span class="dl">'</span> <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 class="stu" id="collection-types">Collection Types</h4>

<p class="stu">For collection types, the result is a <code class="language-plaintext highlighter-rouge">ListTypeInfo</code>:</p>

<div class="language-typescript stu highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">ListTypeInfo</span> <span class="p">{</span> <span class="nl">elementType</span><span class="p">:</span> <span class="nx">TypeSpecifier</span> <span class="p">}</span>
</code></pre></div></div>

<p class="stu">For example:</p>

<pre class="stu"><code class="language-fhirpath">Patient.address.type()
</code></pre>

<p class="stu">Results in:</p>
<div class="language-typescript stu highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nx">ListTypeInfo</span> <span class="p">{</span> <span class="nl">elementType</span><span class="p">:</span> <span class="dl">'</span><span class="s1">FHIR.Address</span><span class="dl">'</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 class="stu" id="anonymous-types">Anonymous Types</h4>

<p class="stu">Anonymous types are structured types that have no associated name, only the elements of the structure. For example, in FHIR, the <code class="language-plaintext highlighter-rouge">Patient.contact</code> element has multiple sub-elements, but is not explicitly named. For types such as this, the result is a <code class="language-plaintext highlighter-rouge">TupleTypeInfo</code>:</p>

<div class="language-typescript stu highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">TupleTypeInfoElement</span> <span class="p">{</span> <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="kd">type</span><span class="p">:</span> <span class="nx">TypeSpecifier</span><span class="p">,</span> <span class="nx">isOneBased</span><span class="p">:</span> <span class="nb">Boolean</span> <span class="p">}</span>
<span class="nx">TupleTypeInfo</span> <span class="p">{</span> <span class="nl">element</span><span class="p">:</span> <span class="nx">List</span><span class="o">&lt;</span><span class="nx">TupleTypeInfoElement</span><span class="o">&gt;</span> <span class="p">}</span>
</code></pre></div></div>

<p class="stu">For example:</p>
<pre class="stu"><code class="language-fhirpath">Patient.contact.single().type()
</code></pre>

<p class="stu">Results in:</p>
<div class="language-typescript stu highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nx">TupleTypeInfo</span> <span class="p">{</span>
    <span class="nl">element</span><span class="p">:</span> <span class="p">{</span>
      <span class="nx">TupleTypeInfoElement</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">relationship</span><span class="dl">'</span><span class="p">,</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">List&lt;FHIR.CodeableConcept&gt;</span><span class="dl">'</span><span class="p">,</span> <span class="na">isOneBased</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span>
      <span class="nx">TupleTypeInfoElement</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">,</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">FHIR.HumanName</span><span class="dl">'</span><span class="p">,</span> <span class="na">isOneBased</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span>
      <span class="nx">TupleTypeInfoElement</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">telecom</span><span class="dl">'</span><span class="p">,</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">List&lt;FHIR.ContactPoint&gt;</span><span class="dl">'</span><span class="p">,</span> <span class="na">isOneBased</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span>
      <span class="nx">TupleTypeInfoElement</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">address</span><span class="dl">'</span><span class="p">,</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">FHIR.Address</span><span class="dl">'</span><span class="p">,</span> <span class="na">isOneBased</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span>
      <span class="nx">TupleTypeInfoElement</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">gender</span><span class="dl">'</span><span class="p">,</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">FHIR.code</span><span class="dl">'</span><span class="p">,</span> <span class="na">isOneBased</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span>
      <span class="nx">TupleTypeInfoElement</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">organization</span><span class="dl">'</span><span class="p">,</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">FHIR.Reference</span><span class="dl">'</span><span class="p">,</span> <span class="na">isOneBased</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span>
      <span class="nx">TupleTypeInfoElement</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">period</span><span class="dl">'</span><span class="p">,</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">FHIR.Period</span><span class="dl">'</span><span class="p">,</span> <span class="na">isOneBased</span><span class="p">:</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote class="stu">
  <p><strong>Note:</strong> These structures are a subset of the abstract metamodel used by the <a href="https://github.com/cqframework/clinical_quality_language">Clinical Quality Language Tooling</a>.</p>
</blockquote>

<h2 id="type-safety-and-strict-evaluation">Type safety and strict evaluation</h2>

<p>Strongly typed languages are intended to help authors avoid mistakes by ensuring that the expressions describe meaningful operations. For example, a strongly typed language would typically disallow the expression:</p>

<pre><code class="language-fhirpath">1 + 'John'
</code></pre>

<p>because it performs an invalid operation, namely adding numbers and strings. However, there are cases where the author knows that a particular invocation may be safe, but the compiler is not aware of, or cannot infer, the reason. In these cases, type-safety errors can become an unwelcome burden, especially for experienced developers.</p>

<p>Because FHIRPath may be used in different situations and environments requiring different levels of type safety, implementations may make different choices about how much type checking should be done at compile-time versus run-time, and in what situations. Some implementations requiring a high degree of type-safety may choose to perform strict type-checking at compile-time for all invocations. On the other hand, some implementations may be unconcerned with compile-time versus run-time checking and may choose to defer all correctness checks to run-time.</p>

<p>For example, since some functions and most operators will only accept a single item as input (and throw a run-time exception otherwise):</p>

<pre><code class="language-fhirpath">Patient.name.given + ' ' + Patient.name.family
</code></pre>

<p>will work perfectly fine, as long as the patient has a single name, but will fail otherwise. It is in fact "safer" to formulate such statements as either:</p>

<pre><code class="language-fhirpath">Patient.name.select(given + ' ' + family)
</code></pre>

<p>which would return a collection of concatenated first and last names, one for each name of a patient. Of course, if the patient turns out to have multiple given names, even this statement will fail and the author would need to choose the first name in each collection explicitly:</p>

<pre><code class="language-fhirpath">Patient.name.first().select(given.first() + ' ' + family.first())
</code></pre>

<p>It is clear that, although more robust, the last expression is also much more elaborate, certainly in situations where, because of external constraints, the author is sure names will not repeat, even if the unconstrained object model allows repetition.</p>

<p>Apart from throwing exceptions, unexpected outcomes may result because of the way the equality operators are defined. The expression</p>

<pre><code class="language-fhirpath">Patient.name.given = 'Wouter'
</code></pre>

<p>will return false as soon as a patient has multiple names, even though one of those may well be 'Wouter'. Again, this can be corrected:</p>

<pre><code class="language-fhirpath">Patient.name.where(given = 'Wouter').exists()
</code></pre>

<p>but is still less concise than would be possible if constraints were well known in advance.</p>

<p>In cases where compile-time checking like this is desirable, implementations may choose to protect against such cases by employing strict typing. Based on the definitions of the operators and functions involved in the expression, and given the types of the inputs, a compiler can analyze the expression and determine whether "unsafe" situations can occur.</p>

<p>Unsafe uses are:</p>

<ul>
  <li>A function that requires an input collection with a single item is called on an output that is not guaranteed to have only one item.</li>
  <li>A function is passed an argument that is not guaranteed to be a single value.</li>
  <li>A function is passed an input value or argument that is not of the expected type</li>
  <li>An operator that requires operands to be collections with a single item is called with arguments that are not guaranteed to have only one item.</li>
  <li>An operator has operands that are not of the expected type</li>
  <li>Equality operators are used on operands that are not both collections or collections containing a single item of the same type.</li>
</ul>

<p>There are a few constructs in the FHIRPath language where the compiler cannot determine the type:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">children()</code> and <code class="language-plaintext highlighter-rouge">descendants()</code> functions</li>
  <li>The <code class="language-plaintext highlighter-rouge">resolve()</code> function</li>
  <li>A member which is polymorphic (e.g. a <code class="language-plaintext highlighter-rouge">choice[x]</code> type in FHIR)</li>
</ul>

<p>Note that the <code class="language-plaintext highlighter-rouge">resolve()</code> function is defined by the FHIR context, it is not part of FHIRPath directly. For more information see the <a href="https://hl7.org/fhir/fhirpath.html#functions">FHIRPath</a> section of the FHIR specification.</p>

<p>Authors can use the <code class="language-plaintext highlighter-rouge">as</code> operator or <code class="language-plaintext highlighter-rouge">ofType()</code> function directly after such constructs to inform the compiler of the expected type.</p>

<p>In cases where a compiler finds places where a collection of multiple items can be present while just a single item is expected, the author will need to make explicit how repetitions are dealt with. Depending on the situation one may:</p>

<ul>
  <li>Use <code class="language-plaintext highlighter-rouge">first()</code>, <code class="language-plaintext highlighter-rouge">last()</code> or indexer (<code class="language-plaintext highlighter-rouge">[ ]</code>) to select a single item</li>
  <li>Use <code class="language-plaintext highlighter-rouge">select()</code> and <code class="language-plaintext highlighter-rouge">where()</code> to turn the expression into one that evaluates each of the repeating items individually (as in the examples above)</li>
</ul>

<h2 id="formal-specifications">Formal Specifications</h2>

<h3 id="formal-syntax">Formal Syntax</h3>

<p>The formal syntax for FHIRPath is specified as an <a href="http://www.antlr.org/">Antlr 4.0</a> grammar file (g4) and included in this specification at the following link:</p>

<p><a href="grammar.html">grammar.html</a></p>

<blockquote>
  <p><strong>Note:</strong> If there are discrepancies between this documentation and the grammar included at the above link, the grammar is considered the source of truth.</p>
</blockquote>

<h3 id="model-information">Model Information</h3>

<p>The model information returned by the reflection function <code class="language-plaintext highlighter-rouge">type()</code>  is specified as an XML Schema document (xsd) and included in this specification at the following link:</p>

<p><a href="modelinfo.xsd">modelinfo.xsd</a></p>

<blockquote>
  <p><strong>Note:</strong> The model information file included here is not a normative aspect of the FHIRPath specification. It is the same model information file used by the <a href="http://github.com/cqframework/clinical_quality_language">Clinical Quality Framework Tooling</a> and is included for reference as a simple formalism that meets the requirements described in the normative <a href="#reflection">Reflection</a> section above.</p>
</blockquote>

<p>As discussed in the section on case-sensitivity, each model used within FHIRPath determines whether or not identifiers in the model are case-sensitive. This information is provided as part of the model information and tooling should respect the case-sensitive settings for each model.</p>

<h3 id="uri-and-media-types">URI and Media Types</h3>
<p>To uniquely identify the FHIRPath language, the following URI is defined:</p>

<pre><code class="language-txt">http://hl7.org/fhirpath
</code></pre>

<p>In addition, a media type is defined to support describing FHIRPath content:</p>

<pre><code class="language-txt">text/fhirpath
</code></pre>

<blockquote>
  <p><strong>Note:</strong> The appendices are included for informative purposes and are not a normative part of the specification.</p>
</blockquote>

<p><a name="hl7v2"></a></p>
<h2 class="appendix" id="use-of-fhirpath-on-hl7-version-2-messages">Use of FHIRPath on HL7 Version 2 messages</h2>

<p>FHIRPath can be used against HL7 V2 messages. This UML diagram summarizes the
Object Model on which the FHIRPath statements are written:</p>

<p><img src="v2-class-model.png" alt="Class Model for HL7 V2" height="456&quot;,width=&quot;760" /></p>

<p>In this Object Model:</p>

<ul>
  <li>The object graph always starts with a message.</li>
  <li>Each message has a list of segments.</li>
  <li>In addition, Abstract Message Syntax is available through the groups() function, for use where the message follows the Abstract Message Syntax sufficiently for the parser to reconcile the segment list with the structure.</li>
  <li>The names of the groups are the names published in the specification, e.g. 'PATIENT_OBSERVATION' (with spaces, where present, replaced by underscores. In case of doubt, consult the V2 XML schemas).</li>
  <li>Each Segment has a list of fields, which each have a list of "Cells". This is necessary to allow for repeats, but users are accustomed to just jumping to Element - use the function elements() which returns all repeats with the given index.</li>
  <li>A "cell" can be either an Element, a Component or a Sub-Components. Elements can contain Components, which can contain Sub-Components. Sub-Sub-Components are not allowed.</li>
  <li>Calls may have a simple text content, or a series of (sub-)components. The simple() function returns either the text, if it exists, or the return value of simple() from the first component</li>
  <li>A V2 data type (e.g. ST, SN, CE etc) is a profile on Cell that specifies whether it has simple content, or complex content.</li>
  <li>todo: this object model doesn't make provision for non-syntax escapes in the simple content (e.g. <code class="language-plaintext highlighter-rouge">\.b\</code>).</li>
  <li>all the lists are 1 based. That means the first item in the list is numbered 1, not 0.</li>
</ul>

<p>Some example queries:</p>

<pre><code class="language-fhirpath">Message.segment.where(code = 'PID').field[3].element.first().simple()
</code></pre>

<p>Get the value of the first component in the first repeat of PID-3</p>

<pre><code class="language-fhirpath">Message.segment[2].elements(3).simple()
</code></pre>

<p>Get a collection  with is the string values of all the repeats in the 3rd element of the 2nd segment. Typically, this assumes that there are no repeats, and so this is a simple value.</p>

<pre><code class="language-fhirpath">Message.segment.where(code = 'PID').field[3].element.where(component[4].value = 'MR').simple()
</code></pre>

<p>Pick out the MR number from PID-3 (assuming, in this case, that there's only one PID segment in the message. No good for an A17). Note that this returns the whole Cell - e.g. <code class="language-plaintext highlighter-rouge">|value^^MR|</code>, though often more components will be present)</p>

<pre><code class="language-fhirpath">Message.segment.where(code = 'PID').elements(3).where(component[4].value = 'MR').component[1].text
</code></pre>

<p>Same as the last, but pick out just the MR value</p>

<pre><code class="language-fhirpath">Message.group('PATIENT').group('PATIENT_OBSERVATION').item.ofType(Segment)
  .where(code = 'OBX' and elements(2).exists(components(2) = 'LN')))
</code></pre>

<p>Return any OBXs from the patient observations (and ignore others e.g. in a R01 message) segments that have LOINC codes.
Note that if the parser cannot properly parse the Abstract Message Syntax, group() must fail with an error message.</p>

<h2 class="appendix" id="fhirpath-tooling-and-implementation">FHIRPath Tooling and Implementation</h2>

<p>The list of known tooling and implementation projects for the FHIRPath language has been moved to the <a href="https://confluence.hl7.org/display/FHIRI/FHIRPath+Implementations" target="_blank">HL7 confluence site</a></p>

<h2 class="appendix" id="references">References</h2>

<p><a name="bibliography"></a></p>
<ul>
  <li><a name="ANTLR"></a>[ANTLR] Another Tool for Language Recognition (ANTLR) <a href="http://www.antlr.org/" target="_blank">http://www.antlr.org/</a></li>
  <li><a name="ISO8601"></a>[ISO8601] Date and time format - ISO 8601. <a href="https://www.iso.org/iso-8601-date-and-time-format.html" target="_blank">https://www.iso.org/iso-8601-date-and-time-format.html</a></li>
  <li><a name="CQL"></a>[CQL] HL7 Cross-Paradigm Specification: Clinical Quality Language, Release 1, STU Release 1.3. <a href="http://www.hl7.org/implement/standards/product_brief.cfm?product_id=400" target="_blank">http://www.hl7.org/implement/standards/product_brief.cfm?product_id=400</a></li>
  <li><a name="MOF"></a>[MOF] Meta Object Facility. <a href="https://www.omg.org/spec/MOF/" target="_blank">https://www.omg.org/spec/MOF/</a>, version 2.5.1, November 2016</li>
  <li><a name="XMLRE"></a>[XMLRE] Regular Expressions. XML Schema 1.1. <a href="https://www.w3.org/TR/xmlschema11-2/#regexs" target="_blank">https://www.w3.org/TR/xmlschema11-2/#regexs</a></li>
  <li><a name="PCRE"></a>[PCRE] Pearl-Compatible Regular Expressions. <a href="http://www.pcre.org/" target="_blank">http://www.pcre.org/</a></li>
  <li><a name="UCUM"></a>[UCUM] Unified Code for Units of Measure (UCUM) <a href="http://unitsofmeasure.org/ucum.html" target="_blank">http://unitsofmeasure.org/ucum.html</a>, Version 2.1, Revision 442 (2017-11-21)</li>
  <li><a name="FHIR"></a>[FHIR] HL7 Fast Healthcare Interoperability Resources <a href="http://hl7.org/fhir" target="_blank">http://hl7.org/fhir</a></li>
  <li><a href="grammar.html">grammar.html</a></li>
  <li><a href="modelinfo.xsd">modelinfo.xsd</a></li>
  <li><a name="fluent"></a>[Fluent] Fluent interface pattern. <a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank">https://en.wikipedia.org/wiki/Fluent_interface</a></li>
</ul>

<h2 id="dependencies">Dependencies</h2>

<div><table border="0" cellpadding="0" cellspacing="0" style="border: 0px #F0F0F0 solid; font-size: 11px; font-family: verdana; vertical-align: top;"><tr style="border: 1px #F0F0F0 solid; font-size: 11px; font-family: verdana; vertical-align: top"><th style="vertical-align: top; text-align : left; background-color: white; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px; padding-top: 3px; padding-bottom: 3px" class="hierarchy"><span title="Implementation Guide Reference">IG</span></th><th style="vertical-align: top; text-align : left; background-color: white; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px; padding-top: 3px; padding-bottom: 3px" class="hierarchy"><span title="The NPM Package Id">Package</span></th><th style="vertical-align: top; text-align : left; background-color: white; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px; padding-top: 3px; padding-bottom: 3px" class="hierarchy"><span title="The version of FHIR that the package is based on">FHIR</span></th><th style="vertical-align: top; text-align : left; background-color: white; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px; padding-top: 3px; padding-bottom: 3px" class="hierarchy"><span title="Explains why this dependency exists">Comment</span></th></tr><tr style="border: 0px #F0F0F0 solid; padding:0px; vertical-align: top; background-color: white"><td style="vertical-align: top; text-align : left; background-color: white; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px; white-space: nowrap; background-image: url(/scratch/repo/temp/pagesdata:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAACCAYAAACg/LjIAAAALUlEQVR4Xu3IoREAIAwEwfT6/ddA0GBAxO3NrLlKUj9263wAAAAvrgEAADClAVWFQIBRHMicAAAAAElFTkSuQmCC)" class="hierarchy"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAWCAYAAAABxvaqAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3wYeFzIs1vtcMQAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAAE0lEQVQI12P4//8/AxMDAwNdCABMPwMo2ctnoQAAAABJRU5ErkJggg==" alt="." style="background-color: inherit" class="hierarchy" /><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3QYZCik0qECmbAAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAABtUlEQVQoz2P8//8/Ayb4///v8xfM4iIMzKxoMkwMOMC3DVv/vXmEKY5Dw///Pw8c+Xn2CLEa/r55+/P07t/nrxKl4f/PX6+8g1mlP/44c4eAhn8fP33bsOV1dBoT51V2+z/MohIfeyYy/P2LXcPfFy8/NLb9efTs//utgjUfft35xRUY8Hnm/N/Xb2LT8P//h5ZOnvjoj+11giXcTH//MTLp/v/x9c/z279uXsOi4e/LRwzsbz6vmMyTLM6m9fnXE3Y2l+yv+yez2nL9eX0Wi4afF5eyW4r/+3qYP1Xjz/N3P17ZsRsKMrJd4rL9wcTxDIsGZqEvLEKv2VT/Mgl+/XGbXSB72s/zxXyBYmwqLCxSLFg0sKkHsAg+YJX7xfBTmt204s/NXE4dQTZtT2beH6yqFv9ebkDXwMhnxixrySb68f9fcWYRTSbGA6ya2QwMsixCvxk/djByiWIJVkbBBGaNOoafO5nYWVlkPRjYtP5/388s+JdJkI+R1xquDMl9zOqMQioM7BIMjJ8Z2IUYWOQZeT0Y/u5mEF+G7AdGLMn7712GnycY/v1g+HOZga+WgUkYWRIAe6ip9OnE1GoAAAAASUVORK5CYII=" alt="." style="background-color: white; background-color: inherit" title="NPM Package" class="hierarchy" /> <span title="Canonical: http://hl7.org/fhirpath">FHIRPath Specification</span></td><td style="vertical-align: top; text-align : left; background-color: white; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px" class="hierarchy"><a href="https://simplifier.net/packages/hl7.fhirpath/3.0.0-ballot">hl7.fhirpath#3.0.0-ballot</a></td><td style="vertical-align: top; text-align : left; background-color: white; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px" class="hierarchy"><a href="http://hl7.org/fhir/R4">R4</a></td><td style="vertical-align: top; text-align : left; background-color: white; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px" class="hierarchy"></td></tr>
<tr style="border: 0px #F0F0F0 solid; padding:0px; vertical-align: top; background-color: #F7F7F7"><td style="vertical-align: top; text-align : left; background-color: #F7F7F7; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px; white-space: nowrap; background-image: url(/scratch/repo/temp/pagesdata:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAACCAYAAACg/LjIAAAALUlEQVR4Xu3IoREAIAwEwfT6/ddA0GBAxO3NrLlKUj9263wAAAAvrgEAADClAVWFQIBRHMicAAAAAElFTkSuQmCC)" class="hierarchy"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAWCAYAAAABxvaqAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3wYeFzIs1vtcMQAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAAE0lEQVQI12P4//8/AxMDAwNdCABMPwMo2ctnoQAAAABJRU5ErkJggg==" alt="." style="background-color: inherit" class="hierarchy" /><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAWCAYAAADJqhx8AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3wYeFzI3XJ6V3QAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAANklEQVQ4y+2RsQ0AIAzDav7/2VzQwoCY4iWbZSmo1QGoUgNMghvWaIejPQW/CrrNCylIwcOCDYfLNRcNer4SAAAAAElFTkSuQmCC" alt="." style="background-color: inherit" class="hierarchy" /><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3QYZCik0qECmbAAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAABtUlEQVQoz2P8//8/Ayb4///v8xfM4iIMzKxoMkwMOMC3DVv/vXmEKY5Dw///Pw8c+Xn2CLEa/r55+/P07t/nrxKl4f/PX6+8g1mlP/44c4eAhn8fP33bsOV1dBoT51V2+z/MohIfeyYy/P2LXcPfFy8/NLb9efTs//utgjUfft35xRUY8Hnm/N/Xb2LT8P//h5ZOnvjoj+11giXcTH//MTLp/v/x9c/z279uXsOi4e/LRwzsbz6vmMyTLM6m9fnXE3Y2l+yv+yez2nL9eX0Wi4afF5eyW4r/+3qYP1Xjz/N3P17ZsRsKMrJd4rL9wcTxDIsGZqEvLEKv2VT/Mgl+/XGbXSB72s/zxXyBYmwqLCxSLFg0sKkHsAg+YJX7xfBTmt204s/NXE4dQTZtT2beH6yqFv9ebkDXwMhnxixrySb68f9fcWYRTSbGA6ya2QwMsixCvxk/djByiWIJVkbBBGaNOoafO5nYWVlkPRjYtP5/388s+JdJkI+R1xquDMl9zOqMQioM7BIMjJ8Z2IUYWOQZeT0Y/u5mEF+G7AdGLMn7712GnycY/v1g+HOZga+WgUkYWRIAe6ip9OnE1GoAAAAASUVORK5CYII=" alt="." style="background-color: #F7F7F7; background-color: inherit" title="NPM Package" class="hierarchy" /> <a href="http://terminology.hl7.org/6.2.0" title="Canonical: http://terminology.hl7.org">HL7 Terminology (THO)</a></td><td style="vertical-align: top; text-align : left; background-color: #F7F7F7; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px" class="hierarchy"><a href="https://simplifier.net/packages/hl7.terminology.r4/6.2.0">hl7.terminology.r4#6.2.0</a></td><td style="vertical-align: top; text-align : left; background-color: #F7F7F7; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px" class="hierarchy"><a href="http://hl7.org/fhir/R4">R4</a></td><td style="vertical-align: top; text-align : left; background-color: #F7F7F7; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px" class="hierarchy">Automatically added as a dependency - all IGs depend on HL7 Terminology</td></tr>
<tr style="border: 0px #F0F0F0 solid; padding:0px; vertical-align: top; background-color: white"><td style="vertical-align: top; text-align : left; background-color: white; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px; white-space: nowrap; background-image: url(/scratch/repo/temp/pagesdata:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAACCAYAAACg/LjIAAAAJUlEQVR4Xu3IIQEAAAgDsHd9/w4EQIOamFnaBgAA4MMKAACAKwNp30CqZFfFmwAAAABJRU5ErkJggg==)" class="hierarchy"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAWCAYAAAABxvaqAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3wYeFzIs1vtcMQAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAAE0lEQVQI12P4//8/AxMDAwNdCABMPwMo2ctnoQAAAABJRU5ErkJggg==" alt="." style="background-color: inherit" class="hierarchy" /><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAWCAYAAADJqhx8AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3wYeFzME+lXFigAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAANklEQVQ4y+3OsRUAIAjEUOL+O8cJABttJM11/x1qZAGqRBEVcNIqdWj1efDqQbb3HwwwwEfABmQUHSPM9dtDAAAAAElFTkSuQmCC" alt="." style="background-color: inherit" class="hierarchy" /><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3QYZCik0qECmbAAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAABtUlEQVQoz2P8//8/Ayb4///v8xfM4iIMzKxoMkwMOMC3DVv/vXmEKY5Dw///Pw8c+Xn2CLEa/r55+/P07t/nrxKl4f/PX6+8g1mlP/44c4eAhn8fP33bsOV1dBoT51V2+z/MohIfeyYy/P2LXcPfFy8/NLb9efTs//utgjUfft35xRUY8Hnm/N/Xb2LT8P//h5ZOnvjoj+11giXcTH//MTLp/v/x9c/z279uXsOi4e/LRwzsbz6vmMyTLM6m9fnXE3Y2l+yv+yez2nL9eX0Wi4afF5eyW4r/+3qYP1Xjz/N3P17ZsRsKMrJd4rL9wcTxDIsGZqEvLEKv2VT/Mgl+/XGbXSB72s/zxXyBYmwqLCxSLFg0sKkHsAg+YJX7xfBTmt204s/NXE4dQTZtT2beH6yqFv9ebkDXwMhnxixrySb68f9fcWYRTSbGA6ya2QwMsixCvxk/djByiWIJVkbBBGaNOoafO5nYWVlkPRjYtP5/388s+JdJkI+R1xquDMl9zOqMQioM7BIMjJ8Z2IUYWOQZeT0Y/u5mEF+G7AdGLMn7712GnycY/v1g+HOZga+WgUkYWRIAe6ip9OnE1GoAAAAASUVORK5CYII=" alt="." style="background-color: white; background-color: inherit" title="NPM Package" class="hierarchy" /> <a href="http://hl7.org/fhir/extensions/5.1.0" title="Canonical: http://hl7.org/fhir/extensions">FHIR Extensions Pack</a></td><td style="vertical-align: top; text-align : left; background-color: white; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px" class="hierarchy"><a href="https://simplifier.net/packages/hl7.fhir.uv.extensions.r4/5.1.0">hl7.fhir.uv.extensions.r4#5.1.0</a></td><td style="vertical-align: top; text-align : left; background-color: white; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px" class="hierarchy"><a href="http://hl7.org/fhir/R4">R4</a></td><td style="vertical-align: top; text-align : left; background-color: white; border: 0px #F0F0F0 solid; padding:0px 4px 0px 4px" class="hierarchy">Automatically added as a dependency - all IGs depend on the HL7 Extension Pack</td></tr>
</table></div>
<!--$$3$$-->

<h2 id="cross-version-analysis">Cross Version Analysis</h2>

<p>This is an R4 IG. None of the features it uses are changed in R4B, so it can be used as is with R4B systems. Packages for both <a href="package.r4.tgz">R4 (hl7.fhirpath.r4)</a> and <a href="package.r4b.tgz">R4B (hl7.fhirpath.r4b)</a> are available.<!--$$2$$--></p>

<h2 id="global-profiles">Global Profiles</h2>

<p><i>There are no Global profiles defined</i></p>
<!--$$4$$-->

<h2 id="ip-statements">IP Statements</h2>

<p>This publication includes IP covered under the following statements.</p>
<ul>
<li>The UCUM codes, UCUM table (regardless of format), and UCUM Specification are copyright 1999-2009, Regenstrief Institute, Inc. and the Unified Codes for Units of Measures (UCUM) Organization. All rights reserved. <a href="https://ucum.org/trac/wiki/TermsOfUse">https://ucum.org/trac/wiki/TermsOfUse</a><div id="ipp_1" onclick="if (document.getElementById('ipp2_1').innerHTML != '') {document.getElementById('ipp_1').innerHTML = document.getElementById('ipp2_1').innerHTML; document.getElementById('ipp2_1').innerHTML = ''}"> <span style="cursor: pointer; border: 1px grey solid; background-color: #fcdcb3; padding-left: 3px; padding-right: 3px; color: black">Show Usage</span></div><div id="ipp2_1" style="display: none">
<ul>
<li><a href="http://terminology.hl7.org/6.2.0/CodeSystem-v3-ucum.html">Unified Code for Units of Measure (UCUM)</a>: <a href="Observation-example.html">Observation/example</a></li>
</ul>
</div></li>
<li>This material contains content from <a href="http://loinc.org">LOINC</a>. LOINC is copyright &copy; 1995-2020, Regenstrief Institute, Inc. and the Logical Observation Identifiers Names and Codes (LOINC) Committee and is available at no cost under the <a href="http://loinc.org/license">license</a>. LOINC&reg; is a registered United States trademark of Regenstrief Institute, Inc.<div id="ipp_2" onclick="if (document.getElementById('ipp2_2').innerHTML != '') {document.getElementById('ipp_2').innerHTML = document.getElementById('ipp2_2').innerHTML; document.getElementById('ipp2_2').innerHTML = ''}"> <span style="cursor: pointer; border: 1px grey solid; background-color: #fcdcb3; padding-left: 3px; padding-right: 3px; color: black">Show Usage</span></div><div id="ipp2_2" style="display: none">
<ul>
<li><a href="http://terminology.hl7.org/6.2.0/CodeSystem-v3-loinc.html">LOINC</a>: <a href="Observation-example.html">Observation/example</a></li>
</ul>
</div></li>
<li>This material contains content that is copyright of SNOMED International. Implementers of these specifications must have the appropriate SNOMED CT Affiliate license - for more information contact <a href="https://www.snomed.org/get-snomed">https://www.snomed.org/get-snomed</a> or <a href="mailto:info@snomed.org">info@snomed.org</a>.<div id="ipp_3" onclick="if (document.getElementById('ipp2_3').innerHTML != '') {document.getElementById('ipp_3').innerHTML = document.getElementById('ipp2_3').innerHTML; document.getElementById('ipp2_3').innerHTML = ''}"> <span style="cursor: pointer; border: 1px grey solid; background-color: #fcdcb3; padding-left: 3px; padding-right: 3px; color: black">Show Usage</span></div><div id="ipp2_3" style="display: none">
<ul>
<li><a href="http://hl7.org/fhir/R4/codesystem-snomedct.html">SNOMED Clinical Terms&amp;reg; (SNOMED CT&amp;reg;)</a>: <a href="Questionnaire-3141.html">CQFQuestionnaire2012</a>, <a href="CodeSystem-calendar-units.html">CalendarUnits</a> and <a href="Observation-example.html">Observation/example</a></li>
</ul>
</div></li>
<li>This material derives from the HL7 Terminology (THO). THO is copyright &copy;1989+ Health Level Seven International and is made available under the CC0 designation. For more licensing information see: <a href="https://terminology.hl7.org/license.html">https://terminology.hl7.org/license.html</a><div id="ipp_4" onclick="if (document.getElementById('ipp2_4').innerHTML != '') {document.getElementById('ipp_4').innerHTML = document.getElementById('ipp2_4').innerHTML; document.getElementById('ipp2_4').innerHTML = ''}"> <span style="cursor: pointer; border: 1px grey solid; background-color: #fcdcb3; padding-left: 3px; padding-right: 3px; color: black">Show Usage</span></div><div id="ipp2_4" style="display: none">
<ul>
<li><a href="http://terminology.hl7.org/6.2.0/CodeSystem-data-absent-reason.html">DataAbsentReason</a>: <a href="Questionnaire-3141.html">CQFQuestionnaire2012</a></li>
<li><a href="http://terminology.hl7.org/6.2.0/CodeSystem-observation-category.html">Observation Category Codes</a>: <a href="Observation-example.html">Observation/example</a></li>
<li><a href="http://terminology.hl7.org/6.2.0/CodeSystem-v2-0131.html">contactRole2</a>: <a href="Patient-example.html">Patient/example</a></li>
<li><a href="http://terminology.hl7.org/6.2.0/CodeSystem-v2-0203.html">identifierType</a>: <a href="Patient-example.html">Patient/example</a></li>
</ul>
</div></li>
</ul>
<!--$$1$$-->



</div>
        </div>  <!-- /inner-wrapper -->
      </div>  <!-- /row -->
    </div>  <!-- /container -->
  </div>  <!-- /segment-content -->

  <script type="text/javascript" src="assets/js/jquery.js"> </script>     <!-- note keep space here, otherwise it will be transformed to empty tag -> fails -->
  <script type="text/javascript" src="assets/js/jquery-ui.min.js"> </script>

  <script type="text/javascript" src="assets/js/window-hash.js"> </script>
  <a name="bottom"> </a>
  <div id="segment-footer" igtool="footer" class="segment">  <!-- segment-footer -->
    <div class="container">  <!-- container -->

      <div class="inner-wrapper">
        <p>
          IG &#169; 2014+ <a style="color:var(--footer-hyperlink-text-color)" href="http://www.hl7.org/Special/committees/xml/index.cfm">Implementable Technology Specifications WG</a>.  Package hl7.fhirpath#3.0.0-ballot based on <a style="color: var(--footer-hyperlink-text-color)" href="http://hl7.org/fhir/R4/">FHIR 4.0.1</a>. Generated <span title="Tue, Jan 28, 2025 21:54+0000">2025-01-28</span>
          <br/>
          <span style="color: var(--footer-highlight-text-color)">
                      Links: <a style="color: var(--footer-hyperlink-text-color)" href="toc.html">Table of Contents</a> |
                 <a style="color: var(--footer-hyperlink-text-color)" href="qa.html">QA Report</a>
                 
                
          </span>
        </p>
      </div>  <!-- /inner-wrapper -->
    </div>  <!-- /container -->
  </div>  <!-- /segment-footer -->
  
  <div id="segment-post-footer" class="segment hidden">  <!-- segment-post-footer -->
    <div class="container">  <!-- container -->
    </div>  <!-- /container -->
  </div>  <!-- /segment-post-footer -->

  <!-- JS and analytics only. -->
  <!-- Bootstrap core JavaScript
  ================================================== -->
  <!-- Placed at the end of the document so the pages load faster -->
  <script type="text/javascript" src="assets/js/bootstrap.min.js"> </script>
  <script type="text/javascript" src="assets/js/respond.min.js"> </script>
  <script type="text/javascript" src="assets/js/anchor.min.js"> </script>
  <script type="text/javascript" src="assets/js/clipboard.min.js"> </script>
  <script type="text/javascript" src="assets/js/clipboard-btn.js"> </script>
  <script type="text/javascript" src="assets/js/anchor-hover.js"> </script>
  <!-- Analytics Below
  ================================================== -->
  </body>
</html>

