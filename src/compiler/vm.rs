//! Bytecode Virtual Machine for FHIRPath expressions
//!
//! This module provides a stack-based virtual machine that executes bytecode
//! generated by the expression compiler. The VM is designed for high performance
//! with minimal overhead for simple operations.

use crate::compiler::bytecode::{Bytecode, Instruction};
use crate::evaluator::EvaluationResult;
use crate::model::FhirPathValue;
use crate::registry::{FunctionRegistry, OperatorRegistry};
use std::collections::HashMap;
use std::sync::Arc;

/// Virtual machine execution error types
#[derive(Debug, Clone, PartialEq)]
pub enum VmError {
    /// Stack underflow (not enough values on stack)
    StackUnderflow,
    /// Stack overflow (too many values on stack)
    StackOverflow,
    /// Invalid instruction pointer
    InvalidInstructionPointer(usize),
    /// Invalid constant index
    InvalidConstantIndex(u16),
    /// Invalid string index
    InvalidStringIndex(u16),
    /// Invalid function index
    InvalidFunctionIndex(u16),
    /// Function evaluation error
    FunctionError(String),
    /// Type conversion error
    TypeConversionError(String),
    /// Runtime error during execution
    RuntimeError(String),
    /// Jump target out of bounds
    JumpOutOfBounds(i16),
    /// Maximum execution steps exceeded
    ExecutionLimitExceeded,
}

impl std::fmt::Display for VmError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::StackUnderflow => write!(f, "Stack underflow"),
            Self::StackOverflow => write!(f, "Stack overflow"),
            Self::InvalidInstructionPointer(ip) => write!(f, "Invalid instruction pointer: {}", ip),
            Self::InvalidConstantIndex(idx) => write!(f, "Invalid constant index: {}", idx),
            Self::InvalidStringIndex(idx) => write!(f, "Invalid string index: {}", idx),
            Self::InvalidFunctionIndex(idx) => write!(f, "Invalid function index: {}", idx),
            Self::FunctionError(msg) => write!(f, "Function error: {}", msg),
            Self::TypeConversionError(msg) => write!(f, "Type conversion error: {}", msg),
            Self::RuntimeError(msg) => write!(f, "Runtime error: {}", msg),
            Self::JumpOutOfBounds(offset) => write!(f, "Jump target out of bounds: {}", offset),
            Self::ExecutionLimitExceeded => write!(f, "Execution limit exceeded"),
        }
    }
}

impl std::error::Error for VmError {}

/// Result type for VM operations
pub type VmResult<T> = Result<T, VmError>;

/// Configuration for the virtual machine
#[derive(Debug, Clone)]
pub struct VmConfig {
    /// Maximum stack size to prevent stack overflow
    pub max_stack_size: usize,
    /// Maximum number of execution steps to prevent infinite loops
    pub max_execution_steps: usize,
    /// Enable debug mode for tracing execution
    pub debug_mode: bool,
}

impl Default for VmConfig {
    fn default() -> Self {
        Self {
            max_stack_size: 1024,
            max_execution_steps: 10_000,
            debug_mode: false,
        }
    }
}

/// Variable scope for lambda execution
#[derive(Debug, Clone)]
struct VariableScope {
    variables: HashMap<String, FhirPathValue>,
    parent: Option<Box<VariableScope>>,
}

impl VariableScope {
    fn new() -> Self {
        Self {
            variables: HashMap::new(),
            parent: None,
        }
    }

    fn with_parent(parent: VariableScope) -> Self {
        Self {
            variables: HashMap::new(),
            parent: Some(Box::new(parent)),
        }
    }

    fn set_variable(&mut self, name: String, value: FhirPathValue) {
        self.variables.insert(name, value);
    }

    fn get_variable(&self, name: &str) -> Option<&FhirPathValue> {
        self.variables.get(name).or_else(|| {
            self.parent
                .as_ref()
                .and_then(|parent| parent.get_variable(name))
        })
    }
}

/// Bytecode Virtual Machine
pub struct VirtualMachine {
    /// VM configuration
    config: VmConfig,
    /// Function registry for function calls
    functions: Arc<FunctionRegistry>,
    /// Operator registry for operations
    operators: Arc<OperatorRegistry>,
}

impl VirtualMachine {
    /// Create a new virtual machine
    pub fn new(functions: Arc<FunctionRegistry>, operators: Arc<OperatorRegistry>) -> Self {
        Self {
            config: VmConfig::default(),
            functions,
            operators,
        }
    }

    /// Create a new virtual machine with custom configuration
    pub fn with_config(
        functions: Arc<FunctionRegistry>,
        operators: Arc<OperatorRegistry>,
        config: VmConfig,
    ) -> Self {
        Self {
            config,
            functions,
            operators,
        }
    }

    /// Execute bytecode with the given input value
    pub fn execute(
        &self,
        bytecode: &Bytecode,
        input: &FhirPathValue,
    ) -> EvaluationResult<FhirPathValue> {
        let mut executor = VmExecutor::new(
            &self.config,
            bytecode,
            input,
            &self.functions,
            &self.operators,
        );
        executor.run()
    }
}

/// VM execution context
struct VmExecutor<'a> {
    /// VM configuration
    config: &'a VmConfig,
    /// Bytecode being executed
    bytecode: &'a Bytecode,
    /// Execution stack
    stack: Vec<FhirPathValue>,
    /// Instruction pointer
    ip: usize,
    /// Current input value
    input: &'a FhirPathValue,
    /// Variable scopes stack
    variable_scopes: Vec<VariableScope>,
    /// Function registry
    #[allow(dead_code)]
    functions: &'a FunctionRegistry,
    /// Operator registry
    #[allow(dead_code)]
    operators: &'a OperatorRegistry,
    /// Execution step counter
    step_count: usize,
}

impl<'a> VmExecutor<'a> {
    fn new(
        config: &'a VmConfig,
        bytecode: &'a Bytecode,
        input: &'a FhirPathValue,
        functions: &'a FunctionRegistry,
        operators: &'a OperatorRegistry,
    ) -> Self {
        Self {
            config,
            bytecode,
            stack: Vec::with_capacity(bytecode.max_stack_depth.max(16)),
            ip: 0,
            input,
            variable_scopes: vec![VariableScope::new()],
            functions,
            operators,
            step_count: 0,
        }
    }

    /// Execute the bytecode
    fn run(&mut self) -> EvaluationResult<FhirPathValue> {
        // Don't automatically push input - let bytecode control when it's needed

        while self.ip < self.bytecode.instructions.len() {
            // Check execution limits
            self.step_count += 1;
            if self.step_count > self.config.max_execution_steps {
                return Err(VmError::ExecutionLimitExceeded.into());
            }

            let instruction = &self.bytecode.instructions[self.ip];

            if self.config.debug_mode {
                eprintln!(
                    "IP: {}, Stack: {:?}, Instruction: {:?}",
                    self.ip,
                    self.stack.len(),
                    instruction
                );
            }

            self.execute_instruction(instruction)?;
            self.ip += 1;
        }

        // Result should be the single value left on stack
        if self.stack.len() == 1 {
            Ok(self.stack.pop().unwrap())
        } else if self.stack.is_empty() {
            Ok(FhirPathValue::Empty)
        } else {
            // Multiple values on stack - create a collection
            let values = std::mem::take(&mut self.stack);
            Ok(FhirPathValue::Collection(values.into()))
        }
    }

    /// Execute a single instruction
    fn execute_instruction(&mut self, instruction: &Instruction) -> VmResult<()> {
        match instruction {
            // Stack Operations
            Instruction::PushConstant(idx) => {
                let value = self.get_constant(*idx)?;
                self.push(value.clone())?;
            }
            Instruction::PushInput => {
                self.push(self.input.clone())?;
            }
            Instruction::Duplicate => {
                let value = self.peek()?.clone();
                self.push(value)?;
            }
            Instruction::Pop => {
                self.pop()?;
            }
            Instruction::Swap => {
                let a = self.pop()?;
                let b = self.pop()?;
                self.push(a)?;
                self.push(b)?;
            }

            // Property Access
            Instruction::LoadProperty(idx) | Instruction::FastProperty(idx) => {
                let property_name = self.get_string(*idx)?.to_string();
                let object = self.pop()?;
                let result = self.load_property(&object, &property_name)?;
                self.push(result)?;
            }
            Instruction::LoadIndexedProperty(idx) => {
                let property_name = self.get_string(*idx)?.to_string();
                let index = self.pop()?;
                let object = self.pop()?;
                let result = self.load_indexed_property(&object, &property_name, &index)?;
                self.push(result)?;
            }
            Instruction::IndexAccess => {
                let index = self.pop()?;
                let collection = self.pop()?;
                let result = self.index_access(&collection, &index)?;
                self.push(result)?;
            }

            // Function Calls
            Instruction::CallFunction(func_idx, arity) => {
                self.call_function(*func_idx, *arity)?;
            }
            Instruction::CallMethod(name_idx, arity) => {
                let method_name = self.get_string(*name_idx)?.to_string();
                self.call_method(&method_name, *arity)?;
            }

            // Arithmetic Operations
            Instruction::Add => self.binary_operator_call("+")?,
            Instruction::Subtract => self.binary_operator_call("-")?,
            Instruction::Multiply => self.binary_operator_call("*")?,
            Instruction::Divide => self.binary_operator_call("/")?,
            Instruction::Modulo => self.binary_operator_call("mod")?,
            Instruction::Negate => self.unary_operator_call("-")?,

            // Comparison Operations
            Instruction::Equal => self.binary_operator_call("=")?,
            Instruction::NotEqual => self.binary_operator_call("!=")?,
            Instruction::LessThan => self.binary_operator_call("<")?,
            Instruction::LessThanOrEqual => self.binary_operator_call("<=")?,
            Instruction::GreaterThan => self.binary_operator_call(">")?,
            Instruction::GreaterThanOrEqual => self.binary_operator_call(">=")?,

            // Logical Operations
            Instruction::And => self.logical_op(|a, b| a && b)?,
            Instruction::Or => self.logical_op(|a, b| a || b)?,
            Instruction::Not => self.logical_not()?,

            // Collection Operations
            Instruction::MakeCollection(count) => {
                let mut elements = Vec::with_capacity(*count as usize);
                for _ in 0..*count {
                    elements.push(self.pop()?);
                }
                elements.reverse(); // Restore original order
                self.push(FhirPathValue::Collection(elements.into()))?;
            }
            Instruction::Union => {
                let right = self.pop()?;
                let left = self.pop()?;
                let result = self.union_collections(&left, &right)?;
                self.push(result)?;
            }
            Instruction::Flatten => {
                let collection = self.pop()?;
                let result = self.flatten_collection(&collection)?;
                self.push(result)?;
            }
            Instruction::IsEmpty => {
                let value = self.pop()?;
                let result = FhirPathValue::Boolean(self.is_empty(&value));
                self.push(result)?;
            }
            Instruction::Count => {
                let collection = self.pop()?;
                let count = self.get_count(&collection);
                self.push(FhirPathValue::Integer(count as i64))?;
            }

            // Control Flow
            Instruction::Jump(offset) => {
                self.jump(*offset)?;
            }
            Instruction::JumpIfFalse(offset) => {
                let condition = self.pop()?;
                if !self.is_truthy(&condition) {
                    self.jump(*offset)?;
                }
            }
            Instruction::JumpIfTrue(offset) => {
                let condition = self.pop()?;
                if self.is_truthy(&condition) {
                    self.jump(*offset)?;
                }
            }

            // Lambda Operations
            Instruction::BeginLambda => {
                let parent_scope = self.variable_scopes.last().unwrap().clone();
                self.variable_scopes
                    .push(VariableScope::with_parent(parent_scope));
            }
            Instruction::EndLambda => {
                if self.variable_scopes.len() > 1 {
                    self.variable_scopes.pop();
                }
            }
            Instruction::BindParameter(name_idx) => {
                let param_name = self.get_string(*name_idx)?.to_string();
                let value = self.pop()?;
                if let Some(scope) = self.variable_scopes.last_mut() {
                    scope.set_variable(param_name, value);
                }
            }

            // Variable Operations
            Instruction::LoadVariable(name_idx) => {
                let var_name = self.get_string(*name_idx)?;
                let value = self.get_variable(var_name)?;
                self.push(value)?;
            }
            Instruction::StoreVariable(name_idx) => {
                let var_name = self.get_string(*name_idx)?.to_string();
                let value = self.pop()?;
                if let Some(scope) = self.variable_scopes.last_mut() {
                    scope.set_variable(var_name, value);
                }
            }

            // Type Operations
            Instruction::IsType(type_idx) => {
                let type_name = self.get_string(*type_idx)?.to_string();
                let value = self.pop()?;
                let result = self.is_type(&value, &type_name)?;
                self.push(FhirPathValue::Boolean(result))?;
            }
            Instruction::AsType(type_idx) => {
                let type_name = self.get_string(*type_idx)?.to_string();
                let value = self.pop()?;
                let result = self.as_type(&value, &type_name)?;
                self.push(result)?;
            }

            // Special Operations
            Instruction::Filter => {
                // Filter operation would need special handling with predicate evaluation
                return Err(VmError::RuntimeError(
                    "Filter instruction not fully implemented".to_string(),
                ));
            }
            Instruction::Select => {
                // Select operation would need special handling with transform evaluation
                return Err(VmError::RuntimeError(
                    "Select instruction not fully implemented".to_string(),
                ));
            }
            Instruction::Where => {
                // Where is an alias for Filter
                return Err(VmError::RuntimeError(
                    "Where instruction not fully implemented".to_string(),
                ));
            }

            // Optimization Instructions
            Instruction::Nop => {
                // No operation
            }
            Instruction::Return => {
                // Early return - stop execution
                return Ok(());
            }
            Instruction::FastConstant(idx) => {
                // Same as PushConstant but optimized
                let value = self.get_constant(*idx)?;
                self.push(value.clone())?;
            }

            // Unimplemented
            Instruction::Any | Instruction::All => {
                return Err(VmError::RuntimeError(
                    "Any/All instructions not fully implemented".to_string(),
                ));
            }
        }

        Ok(())
    }

    /// Push a value onto the stack
    fn push(&mut self, value: FhirPathValue) -> VmResult<()> {
        if self.stack.len() >= self.config.max_stack_size {
            return Err(VmError::StackOverflow);
        }
        self.stack.push(value);
        Ok(())
    }

    /// Pop a value from the stack
    fn pop(&mut self) -> VmResult<FhirPathValue> {
        self.stack.pop().ok_or(VmError::StackUnderflow)
    }

    /// Peek at the top stack value without popping
    fn peek(&self) -> VmResult<&FhirPathValue> {
        self.stack.last().ok_or(VmError::StackUnderflow)
    }

    /// Get a constant from the constant pool
    fn get_constant(&self, idx: u16) -> VmResult<&FhirPathValue> {
        self.bytecode
            .constants
            .get(idx as usize)
            .ok_or(VmError::InvalidConstantIndex(idx))
    }

    /// Get a string from the string pool
    fn get_string(&self, idx: u16) -> VmResult<&str> {
        self.bytecode
            .strings
            .get(idx as usize)
            .map(|s| s.as_str())
            .ok_or(VmError::InvalidStringIndex(idx))
    }

    /// Get a variable from the current scope
    fn get_variable(&self, name: &str) -> VmResult<FhirPathValue> {
        if let Some(scope) = self.variable_scopes.last() {
            if let Some(value) = scope.get_variable(name) {
                return Ok(value.clone());
            }
        }

        // Built-in variables
        match name {
            "$this" => Ok(self.input.clone()),
            "$index" => Ok(FhirPathValue::Integer(0)), // Simplified
            "$total" => Ok(FhirPathValue::Integer(1)), // Simplified
            _ => Ok(FhirPathValue::Empty),
        }
    }

    /// Jump to a relative offset
    fn jump(&mut self, offset: i16) -> VmResult<()> {
        // Jump is relative to the next instruction (current IP + 1)
        let new_ip = (self.ip + 1) as i32 + offset as i32;
        if new_ip < 0 || new_ip > self.bytecode.instructions.len() as i32 {
            return Err(VmError::JumpOutOfBounds(offset));
        }
        // Set IP to target - 1 because main loop will increment it
        self.ip = (new_ip as usize).saturating_sub(1);
        Ok(())
    }

    /// Load a property from an object
    fn load_property(&self, object: &FhirPathValue, property: &str) -> VmResult<FhirPathValue> {
        // Simplified property access - real implementation would be more complex
        match object {
            FhirPathValue::Resource(resource) => {
                // Access resource property
                match resource.get_property(property) {
                    Some(value) => Ok(FhirPathValue::from(value.clone())),
                    None => Ok(FhirPathValue::Empty),
                }
            }
            _ => Ok(FhirPathValue::Empty),
        }
    }

    /// Load an indexed property from an object
    fn load_indexed_property(
        &self,
        object: &FhirPathValue,
        property: &str,
        index: &FhirPathValue,
    ) -> VmResult<FhirPathValue> {
        // Get the property first, then index into it
        let property_value = self.load_property(object, property)?;
        self.index_access(&property_value, index)
    }

    /// Access a collection by index
    fn index_access(
        &self,
        collection: &FhirPathValue,
        index: &FhirPathValue,
    ) -> VmResult<FhirPathValue> {
        let idx = match index {
            FhirPathValue::Integer(i) => *i as usize,
            _ => {
                return Err(VmError::TypeConversionError(
                    "Index must be an integer".to_string(),
                ));
            }
        };

        match collection {
            FhirPathValue::Collection(values) => {
                Ok(values.get(idx).cloned().unwrap_or(FhirPathValue::Empty))
            }
            _ => {
                // Single value - index 0 returns the value, others return empty
                if idx == 0 {
                    Ok(collection.clone())
                } else {
                    Ok(FhirPathValue::Empty)
                }
            }
        }
    }

    /// Call a function
    fn call_function(&mut self, func_idx: u16, arity: u8) -> VmResult<()> {
        // Pop arguments from stack
        let mut args = Vec::with_capacity(arity as usize);
        for _ in 0..arity {
            args.push(self.pop()?);
        }
        args.reverse(); // Restore original order

        // Simple function dispatch - real implementation would use function registry
        let result = match func_idx {
            0 => self.builtin_count(&args)?,           // count
            1 => self.builtin_exists(&args)?,          // exists
            2 => self.builtin_empty(&args)?,           // empty
            3 => self.builtin_first(&args)?,           // first
            4 => self.builtin_last(&args)?,            // last
            5 => self.builtin_where(&args)?,           // where (simplified)
            6 => self.builtin_select(&args)?,          // select (simplified)
            7 => self.builtin_define_variable(&args)?, // defineVariable
            _ => return Err(VmError::InvalidFunctionIndex(func_idx)),
        };

        self.push(result)?;
        Ok(())
    }

    /// Call a method
    fn call_method(&mut self, method_name: &str, arity: u8) -> VmResult<()> {
        // Pop arguments and object from stack
        let mut args = Vec::with_capacity(arity as usize);
        for _ in 0..arity {
            args.push(self.pop()?);
        }
        args.reverse(); // Restore original order

        let object = self.pop()?;

        // Simple method dispatch
        let result = match method_name {
            "first" => self.method_first(&object)?,
            "last" => self.method_last(&object)?,
            "count" => FhirPathValue::Integer(self.get_count(&object) as i64),
            "exists" => FhirPathValue::Boolean(!self.is_empty(&object)),
            "empty" => FhirPathValue::Boolean(self.is_empty(&object)),
            _ => {
                return Err(VmError::RuntimeError(format!(
                    "Unknown method: {}",
                    method_name
                )));
            }
        };

        self.push(result)?;
        Ok(())
    }

    /// Call a binary operator
    fn binary_operator_call(&mut self, operator: &str) -> VmResult<()> {
        let right = self.pop()?;
        let left = self.pop()?;

        // Simple implementation for basic operators
        let result = match operator {
            "+" => self.add_values(&left, &right)?,
            "-" => self.subtract_values(&left, &right)?,
            "*" => self.multiply_values(&left, &right)?,
            "/" => self.divide_values(&left, &right)?,
            "mod" => self.modulo_values(&left, &right)?,
            "=" => FhirPathValue::Boolean(self.values_equal(&left, &right)),
            "!=" => FhirPathValue::Boolean(!self.values_equal(&left, &right)),
            "<" => FhirPathValue::Boolean(self.values_less_than(&left, &right)),
            "<=" => FhirPathValue::Boolean(
                self.values_less_than(&left, &right) || self.values_equal(&left, &right),
            ),
            ">" => FhirPathValue::Boolean(self.values_less_than(&right, &left)),
            ">=" => FhirPathValue::Boolean(
                self.values_less_than(&right, &left) || self.values_equal(&left, &right),
            ),
            _ => {
                return Err(VmError::RuntimeError(format!(
                    "Unknown operator: {}",
                    operator
                )));
            }
        };

        self.push(result)?;
        Ok(())
    }

    /// Call a unary operator
    fn unary_operator_call(&mut self, operator: &str) -> VmResult<()> {
        let operand = self.pop()?;

        let result = match operator {
            "-" => self.negate_value(&operand)?,
            _ => {
                return Err(VmError::RuntimeError(format!(
                    "Unknown unary operator: {}",
                    operator
                )));
            }
        };

        self.push(result)?;
        Ok(())
    }

    /// Logical operation
    fn logical_op<F>(&mut self, op: F) -> VmResult<()>
    where
        F: Fn(bool, bool) -> bool,
    {
        let right = self.pop()?;
        let left = self.pop()?;
        let left_bool = self.is_truthy(&left);
        let right_bool = self.is_truthy(&right);
        let result = FhirPathValue::Boolean(op(left_bool, right_bool));
        self.push(result)?;
        Ok(())
    }

    /// Logical NOT operation
    fn logical_not(&mut self) -> VmResult<()> {
        let value = self.pop()?;
        let result = FhirPathValue::Boolean(!self.is_truthy(&value));
        self.push(result)?;
        Ok(())
    }

    /// Check if a value is truthy
    fn is_truthy(&self, value: &FhirPathValue) -> bool {
        match value {
            FhirPathValue::Boolean(b) => *b,
            FhirPathValue::Empty => false,
            FhirPathValue::Collection(values) => !values.is_empty(),
            _ => true,
        }
    }

    /// Check if a value is empty
    fn is_empty(&self, value: &FhirPathValue) -> bool {
        match value {
            FhirPathValue::Empty => true,
            FhirPathValue::Collection(values) => values.is_empty(),
            _ => false,
        }
    }

    /// Get the count of elements in a value
    fn get_count(&self, value: &FhirPathValue) -> usize {
        match value {
            FhirPathValue::Empty => 0,
            FhirPathValue::Collection(values) => values.len(),
            _ => 1,
        }
    }

    /// Union two collections
    fn union_collections(
        &self,
        left: &FhirPathValue,
        right: &FhirPathValue,
    ) -> VmResult<FhirPathValue> {
        let mut result = Vec::new();

        // Add elements from left
        match left {
            FhirPathValue::Collection(values) => result.extend(values.iter().cloned()),
            FhirPathValue::Empty => {}
            value => result.push(value.clone()),
        }

        // Add elements from right
        match right {
            FhirPathValue::Collection(values) => result.extend(values.iter().cloned()),
            FhirPathValue::Empty => {}
            value => result.push(value.clone()),
        }

        Ok(FhirPathValue::Collection(result.into()))
    }

    /// Flatten a nested collection
    fn flatten_collection(&self, collection: &FhirPathValue) -> VmResult<FhirPathValue> {
        let mut result = Vec::new();

        match collection {
            FhirPathValue::Collection(values) => {
                for value in values.iter() {
                    match value {
                        FhirPathValue::Collection(nested) => {
                            result.extend(nested.iter().cloned());
                        }
                        _ => result.push(value.clone()),
                    }
                }
            }
            _ => result.push(collection.clone()),
        }

        Ok(FhirPathValue::Collection(result.into()))
    }

    /// Type checking
    fn is_type(&self, value: &FhirPathValue, type_name: &str) -> VmResult<bool> {
        let result = match type_name {
            "Boolean" => matches!(value, FhirPathValue::Boolean(_)),
            "Integer" => matches!(value, FhirPathValue::Integer(_)),
            "Decimal" => matches!(value, FhirPathValue::Decimal(_)),
            "String" => matches!(value, FhirPathValue::String(_)),
            "Date" => matches!(value, FhirPathValue::Date(_)),
            "DateTime" => matches!(value, FhirPathValue::DateTime(_)),
            "Time" => matches!(value, FhirPathValue::Time(_)),
            "Quantity" => matches!(value, FhirPathValue::Quantity(_)),
            _ => false,
        };
        Ok(result)
    }

    /// Type casting
    fn as_type(&self, value: &FhirPathValue, type_name: &str) -> VmResult<FhirPathValue> {
        // Simplified type casting
        match type_name {
            "String" => Ok(FhirPathValue::String(format!("{:?}", value))),
            "Boolean" => Ok(FhirPathValue::Boolean(self.is_truthy(value))),
            _ => Ok(value.clone()), // No conversion
        }
    }

    // Arithmetic helper methods

    fn add_values(&self, left: &FhirPathValue, right: &FhirPathValue) -> VmResult<FhirPathValue> {
        use rust_decimal::Decimal;
        match (left, right) {
            (FhirPathValue::Integer(a), FhirPathValue::Integer(b)) => {
                Ok(FhirPathValue::Integer(a + b))
            }
            (FhirPathValue::Decimal(a), FhirPathValue::Decimal(b)) => {
                Ok(FhirPathValue::Decimal(a + b))
            }
            (FhirPathValue::Integer(a), FhirPathValue::Decimal(b)) => {
                Ok(FhirPathValue::Decimal(Decimal::from(*a) + b))
            }
            (FhirPathValue::Decimal(a), FhirPathValue::Integer(b)) => {
                Ok(FhirPathValue::Decimal(a + Decimal::from(*b)))
            }
            (FhirPathValue::String(a), FhirPathValue::String(b)) => {
                Ok(FhirPathValue::String(format!("{}{}", a, b)))
            }
            _ => Err(VmError::TypeConversionError(
                "Cannot add these types".to_string(),
            )),
        }
    }

    fn subtract_values(
        &self,
        left: &FhirPathValue,
        right: &FhirPathValue,
    ) -> VmResult<FhirPathValue> {
        use rust_decimal::Decimal;
        match (left, right) {
            (FhirPathValue::Integer(a), FhirPathValue::Integer(b)) => {
                Ok(FhirPathValue::Integer(a - b))
            }
            (FhirPathValue::Decimal(a), FhirPathValue::Decimal(b)) => {
                Ok(FhirPathValue::Decimal(a - b))
            }
            (FhirPathValue::Integer(a), FhirPathValue::Decimal(b)) => {
                Ok(FhirPathValue::Decimal(Decimal::from(*a) - b))
            }
            (FhirPathValue::Decimal(a), FhirPathValue::Integer(b)) => {
                Ok(FhirPathValue::Decimal(a - Decimal::from(*b)))
            }
            _ => Err(VmError::TypeConversionError(
                "Cannot subtract these types".to_string(),
            )),
        }
    }

    fn multiply_values(
        &self,
        left: &FhirPathValue,
        right: &FhirPathValue,
    ) -> VmResult<FhirPathValue> {
        use rust_decimal::Decimal;
        match (left, right) {
            (FhirPathValue::Integer(a), FhirPathValue::Integer(b)) => {
                Ok(FhirPathValue::Integer(a * b))
            }
            (FhirPathValue::Decimal(a), FhirPathValue::Decimal(b)) => {
                Ok(FhirPathValue::Decimal(a * b))
            }
            (FhirPathValue::Integer(a), FhirPathValue::Decimal(b)) => {
                Ok(FhirPathValue::Decimal(Decimal::from(*a) * b))
            }
            (FhirPathValue::Decimal(a), FhirPathValue::Integer(b)) => {
                Ok(FhirPathValue::Decimal(a * Decimal::from(*b)))
            }
            _ => Err(VmError::TypeConversionError(
                "Cannot multiply these types".to_string(),
            )),
        }
    }

    fn divide_values(
        &self,
        left: &FhirPathValue,
        right: &FhirPathValue,
    ) -> VmResult<FhirPathValue> {
        use rust_decimal::Decimal;
        match (left, right) {
            (FhirPathValue::Integer(a), FhirPathValue::Integer(b)) => {
                if *b == 0 {
                    return Err(VmError::RuntimeError("Division by zero".to_string()));
                }
                Ok(FhirPathValue::Decimal(
                    Decimal::from(*a) / Decimal::from(*b),
                ))
            }
            (FhirPathValue::Decimal(a), FhirPathValue::Decimal(b)) => {
                if b.is_zero() {
                    return Err(VmError::RuntimeError("Division by zero".to_string()));
                }
                Ok(FhirPathValue::Decimal(a / b))
            }
            (FhirPathValue::Integer(a), FhirPathValue::Decimal(b)) => {
                if b.is_zero() {
                    return Err(VmError::RuntimeError("Division by zero".to_string()));
                }
                Ok(FhirPathValue::Decimal(Decimal::from(*a) / b))
            }
            (FhirPathValue::Decimal(a), FhirPathValue::Integer(b)) => {
                if *b == 0 {
                    return Err(VmError::RuntimeError("Division by zero".to_string()));
                }
                Ok(FhirPathValue::Decimal(a / Decimal::from(*b)))
            }
            _ => Err(VmError::TypeConversionError(
                "Cannot divide these types".to_string(),
            )),
        }
    }

    fn modulo_values(
        &self,
        left: &FhirPathValue,
        right: &FhirPathValue,
    ) -> VmResult<FhirPathValue> {
        match (left, right) {
            (FhirPathValue::Integer(a), FhirPathValue::Integer(b)) => {
                if *b == 0 {
                    return Err(VmError::RuntimeError("Modulo by zero".to_string()));
                }
                Ok(FhirPathValue::Integer(a % b))
            }
            _ => Err(VmError::TypeConversionError(
                "Modulo only supported for integers".to_string(),
            )),
        }
    }

    fn negate_value(&self, value: &FhirPathValue) -> VmResult<FhirPathValue> {
        match value {
            FhirPathValue::Integer(i) => Ok(FhirPathValue::Integer(-i)),
            FhirPathValue::Decimal(d) => Ok(FhirPathValue::Decimal(-d)),
            _ => Err(VmError::TypeConversionError(
                "Cannot negate this type".to_string(),
            )),
        }
    }

    fn values_equal(&self, left: &FhirPathValue, right: &FhirPathValue) -> bool {
        left == right
    }

    fn values_less_than(&self, left: &FhirPathValue, right: &FhirPathValue) -> bool {
        use rust_decimal::Decimal;
        match (left, right) {
            (FhirPathValue::Integer(a), FhirPathValue::Integer(b)) => a < b,
            (FhirPathValue::Decimal(a), FhirPathValue::Decimal(b)) => a < b,
            (FhirPathValue::Integer(a), FhirPathValue::Decimal(b)) => Decimal::from(*a) < *b,
            (FhirPathValue::Decimal(a), FhirPathValue::Integer(b)) => *a < Decimal::from(*b),
            (FhirPathValue::String(a), FhirPathValue::String(b)) => a < b,
            _ => false,
        }
    }

    // Built-in function implementations (simplified)

    fn builtin_count(&self, args: &[FhirPathValue]) -> VmResult<FhirPathValue> {
        if args.is_empty() {
            return Ok(FhirPathValue::Integer(0));
        }
        let count = self.get_count(&args[0]);
        Ok(FhirPathValue::Integer(count as i64))
    }

    fn builtin_exists(&self, args: &[FhirPathValue]) -> VmResult<FhirPathValue> {
        if args.is_empty() {
            return Ok(FhirPathValue::Boolean(false));
        }
        Ok(FhirPathValue::Boolean(!self.is_empty(&args[0])))
    }

    fn builtin_empty(&self, _args: &[FhirPathValue]) -> VmResult<FhirPathValue> {
        Ok(FhirPathValue::Collection(vec![].into()))
    }

    fn builtin_first(&self, args: &[FhirPathValue]) -> VmResult<FhirPathValue> {
        if args.is_empty() {
            return Ok(FhirPathValue::Empty);
        }
        Ok(self.method_first(&args[0])?)
    }

    fn builtin_last(&self, args: &[FhirPathValue]) -> VmResult<FhirPathValue> {
        if args.is_empty() {
            return Ok(FhirPathValue::Empty);
        }
        Ok(self.method_last(&args[0])?)
    }

    fn builtin_where(&self, _args: &[FhirPathValue]) -> VmResult<FhirPathValue> {
        // Simplified - would need predicate evaluation
        Ok(FhirPathValue::Collection(vec![].into()))
    }

    fn builtin_select(&self, _args: &[FhirPathValue]) -> VmResult<FhirPathValue> {
        // Simplified - would need transform evaluation
        Ok(FhirPathValue::Collection(vec![].into()))
    }

    fn builtin_define_variable(&mut self, args: &[FhirPathValue]) -> VmResult<FhirPathValue> {
        if args.len() >= 2 {
            if let FhirPathValue::String(name) = &args[0] {
                if let Some(scope) = self.variable_scopes.last_mut() {
                    scope.set_variable(name.clone(), args[1].clone());
                }
            }
        }
        Ok(FhirPathValue::Empty)
    }

    // Method implementations

    fn method_first(&self, object: &FhirPathValue) -> VmResult<FhirPathValue> {
        match object {
            FhirPathValue::Collection(values) => {
                Ok(values.first().cloned().unwrap_or(FhirPathValue::Empty))
            }
            _ => Ok(object.clone()),
        }
    }

    fn method_last(&self, object: &FhirPathValue) -> VmResult<FhirPathValue> {
        match object {
            FhirPathValue::Collection(values) => {
                Ok(values.last().cloned().unwrap_or(FhirPathValue::Empty))
            }
            _ => Ok(object.clone()),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compiler::{BytecodeBuilder, Instruction};
    use crate::registry::{FunctionRegistry, OperatorRegistry};

    fn create_test_vm() -> VirtualMachine {
        let functions = Arc::new(FunctionRegistry::new());
        let operators = Arc::new(OperatorRegistry::new());
        VirtualMachine::new(functions, operators)
    }

    #[test]
    fn test_push_constant() {
        let vm = create_test_vm();
        let mut builder = BytecodeBuilder::new();

        builder.push_constant(FhirPathValue::Integer(42));
        let bytecode = builder.finalize().unwrap();

        let input = FhirPathValue::Empty;
        let result = vm.execute(&bytecode, &input).unwrap();

        assert_eq!(result, FhirPathValue::Integer(42));
    }

    #[test]
    fn test_arithmetic_operations() {
        let vm = create_test_vm();
        let mut builder = BytecodeBuilder::new();

        // Push two constants and add them
        builder.push_constant(FhirPathValue::Integer(10));
        builder.push_constant(FhirPathValue::Integer(32));
        builder.emit(Instruction::Add);

        let bytecode = builder.finalize().unwrap();

        let input = FhirPathValue::Empty;
        let result = vm.execute(&bytecode, &input).unwrap();

        assert_eq!(result, FhirPathValue::Integer(42));
    }

    #[test]
    fn test_comparison_operations() {
        let vm = create_test_vm();
        let mut builder = BytecodeBuilder::new();

        // Push two constants and compare them
        builder.push_constant(FhirPathValue::Integer(10));
        builder.push_constant(FhirPathValue::Integer(20));
        builder.emit(Instruction::LessThan);

        let bytecode = builder.finalize().unwrap();

        let input = FhirPathValue::Empty;
        let result = vm.execute(&bytecode, &input).unwrap();

        assert_eq!(result, FhirPathValue::Boolean(true));
    }

    #[test]
    fn test_logical_operations() {
        let vm = create_test_vm();
        let mut builder = BytecodeBuilder::new();

        // Push two booleans and perform AND
        builder.push_constant(FhirPathValue::Boolean(true));
        builder.push_constant(FhirPathValue::Boolean(false));
        builder.emit(Instruction::And);

        let bytecode = builder.finalize().unwrap();

        let input = FhirPathValue::Empty;
        let result = vm.execute(&bytecode, &input).unwrap();

        assert_eq!(result, FhirPathValue::Boolean(false));
    }

    #[test]
    fn test_collection_operations() {
        let vm = create_test_vm();
        let mut builder = BytecodeBuilder::new();

        // Create a collection from multiple values
        builder.push_constant(FhirPathValue::Integer(1));
        builder.push_constant(FhirPathValue::Integer(2));
        builder.push_constant(FhirPathValue::Integer(3));
        builder.emit(Instruction::MakeCollection(3));

        let bytecode = builder.finalize().unwrap();

        let input = FhirPathValue::Empty;
        let result = vm.execute(&bytecode, &input).unwrap();

        match result {
            FhirPathValue::Collection(values) => {
                assert_eq!(values.len(), 3);
                let items: Vec<_> = values.iter().collect();
                assert_eq!(items[0], &FhirPathValue::Integer(1));
                assert_eq!(items[1], &FhirPathValue::Integer(2));
                assert_eq!(items[2], &FhirPathValue::Integer(3));
            }
            _ => panic!("Expected collection"),
        }
    }

    #[test]
    fn test_function_call() {
        let vm = create_test_vm();
        let mut builder = BytecodeBuilder::new();

        // Create a collection and call count() on it
        builder.push_constant(FhirPathValue::Integer(1));
        builder.push_constant(FhirPathValue::Integer(2));
        builder.emit(Instruction::MakeCollection(2));
        builder.emit(Instruction::CallFunction(0, 1)); // count function

        let bytecode = builder.finalize().unwrap();

        let input = FhirPathValue::Empty;
        let result = vm.execute(&bytecode, &input).unwrap();

        assert_eq!(result, FhirPathValue::Integer(2));
    }

    #[test]
    fn test_variable_operations() {
        let vm = create_test_vm();
        let mut builder = BytecodeBuilder::new();

        // Store a variable and load it back
        let var_name_idx = builder.add_string("testVar".to_string());
        builder.push_constant(FhirPathValue::Integer(42));
        builder.emit(Instruction::StoreVariable(var_name_idx));
        builder.emit(Instruction::LoadVariable(var_name_idx));

        let bytecode = builder.finalize().unwrap();

        let input = FhirPathValue::Empty;
        let result = vm.execute(&bytecode, &input).unwrap();

        assert_eq!(result, FhirPathValue::Integer(42));
    }

    #[test]
    fn test_conditional_jump() {
        let vm = create_test_vm();
        let mut builder = BytecodeBuilder::new();

        // Jump over an instruction if condition is false
        builder.push_constant(FhirPathValue::Boolean(false));
        builder.emit(Instruction::JumpIfTrue(2)); // Since condition is false, don't jump
        builder.push_constant(FhirPathValue::Integer(1)); // This should execute
        builder.emit(Instruction::Jump(1)); // Skip the next instruction
        builder.push_constant(FhirPathValue::Integer(2)); // This should be skipped

        let bytecode = builder.finalize().unwrap();

        let input = FhirPathValue::Empty;
        let result = vm.execute(&bytecode, &input).unwrap();

        assert_eq!(result, FhirPathValue::Integer(1));
    }

    #[test]
    fn test_stack_overflow_protection() {
        let vm = VirtualMachine::with_config(
            Arc::new(FunctionRegistry::new()),
            Arc::new(OperatorRegistry::new()),
            VmConfig {
                max_stack_size: 5,
                max_execution_steps: 1000,
                debug_mode: false,
            },
        );

        let mut builder = BytecodeBuilder::new();

        // Try to push more values than the stack limit
        for _ in 0..10 {
            builder.push_constant(FhirPathValue::Integer(1));
        }

        let bytecode = builder.finalize().unwrap();
        let input = FhirPathValue::Empty;
        let result = vm.execute(&bytecode, &input);

        assert!(matches!(result, Err(_))); // Should fail with stack overflow
    }

    #[test]
    fn test_execution_limit() {
        let vm = VirtualMachine::with_config(
            Arc::new(FunctionRegistry::new()),
            Arc::new(OperatorRegistry::new()),
            VmConfig {
                max_stack_size: 1024,
                max_execution_steps: 5,
                debug_mode: false,
            },
        );

        let mut builder = BytecodeBuilder::new();

        // Create a program with more instructions than the limit
        for _ in 0..10 {
            builder.push_constant(FhirPathValue::Integer(1));
        }

        let bytecode = builder.finalize().unwrap();
        let input = FhirPathValue::Empty;
        let result = vm.execute(&bytecode, &input);

        assert!(matches!(result, Err(_))); // Should fail with execution limit exceeded
    }
}
