//! Addition (+) operator implementation
//!
//! Implements FHIRPath addition for numeric types and string concatenation.
//! Uses octofhir_ucum for quantity arithmetic and handles temporal arithmetic.

use async_trait::async_trait;
use rust_decimal::Decimal;
use rust_decimal::prelude::ToPrimitive;
use std::sync::Arc;

use crate::core::temporal::CalendarDuration;
use crate::core::{Collection, FhirPathType, FhirPathValue, Result, TypeSignature};
use crate::evaluator::operator_registry::{
    Associativity, EmptyPropagation, OperationEvaluator, OperatorMetadata, OperatorSignature,
};
use crate::evaluator::{EvaluationContext, EvaluationResult};

/// Addition operator evaluator
pub struct AddOperatorEvaluator {
    metadata: OperatorMetadata,
}

impl AddOperatorEvaluator {
    /// Create a new addition operator evaluator
    pub fn new() -> Self {
        Self {
            metadata: create_add_metadata(),
        }
    }

    /// Create an Arc-wrapped instance for registry registration
    pub fn create() -> Arc<dyn OperationEvaluator> {
        Arc::new(Self::new())
    }

    /// Perform addition on two FhirPathValues
    fn add_values(&self, left: &FhirPathValue, right: &FhirPathValue) -> Option<FhirPathValue> {
        match (left, right) {
            // Integer addition
            (FhirPathValue::Integer(l, _, _), FhirPathValue::Integer(r, _, _)) => {
                Some(FhirPathValue::integer(l + r))
            }

            // Decimal addition
            (FhirPathValue::Decimal(l, _, _), FhirPathValue::Decimal(r, _, _)) => {
                Some(FhirPathValue::decimal(*l + *r))
            }

            // Integer + Decimal = Decimal
            (FhirPathValue::Integer(l, _, _), FhirPathValue::Decimal(r, _, _)) => {
                let left_decimal = Decimal::from(*l);
                Some(FhirPathValue::decimal(left_decimal + *r))
            }
            (FhirPathValue::Decimal(l, _, _), FhirPathValue::Integer(r, _, _)) => {
                let right_decimal = Decimal::from(*r);
                Some(FhirPathValue::decimal(*l + right_decimal))
            }

            // Quantity addition - requires same units or compatible units via UCUM
            (
                FhirPathValue::Quantity {
                    value: lv,
                    unit: lu,
                    ..
                },
                FhirPathValue::Quantity {
                    value: rv,
                    unit: ru,
                    ..
                },
            ) => {
                if lu == ru {
                    // Same units - simple addition
                    Some(FhirPathValue::quantity(*lv + *rv, lu.clone()))
                } else {
                    // Different units - would need UCUM conversion
                    // TODO: Integrate with octofhir_ucum library for unit conversion
                    // For now, return None to indicate incompatible units
                    None
                }
            }

            // Date + Quantity (time-valued) = Date
            (FhirPathValue::Date(date, _, _), FhirPathValue::Quantity { value, unit, .. }) => {
                if let Some(unit_str) = unit {
                    self.add_temporal_quantity(&FhirPathValue::date(date.clone()), *value, unit_str)
                } else {
                    None
                }
            }

            // DateTime + Quantity (time-valued) = DateTime
            (
                FhirPathValue::DateTime(datetime, _, _),
                FhirPathValue::Quantity { value, unit, .. },
            ) => {
                if let Some(unit_str) = unit {
                    self.add_temporal_quantity(
                        &FhirPathValue::datetime(datetime.clone()),
                        *value,
                        unit_str,
                    )
                } else {
                    None
                }
            }

            // Time + Quantity (time-valued) = Time
            (FhirPathValue::Time(time, _, _), FhirPathValue::Quantity { value, unit, .. }) => {
                if let Some(unit_str) = unit {
                    self.add_temporal_quantity(&FhirPathValue::time(time.clone()), *value, unit_str)
                } else {
                    None
                }
            }

            // String concatenation (+ operator acts as concatenation for strings)
            (FhirPathValue::String(l, _, _), FhirPathValue::String(r, _, _)) => {
                Some(FhirPathValue::string(format!("{}{}", l, r)))
            }

            // Invalid combinations
            _ => None,
        }
    }

    /// Add a time-valued quantity to a temporal value
    fn add_temporal_quantity(
        &self,
        temporal: &FhirPathValue,
        quantity_value: Decimal,
        unit: &str,
    ) -> Option<FhirPathValue> {
        use crate::core::CalendarUnit;

        // Parse the calendar unit
        let calendar_unit = CalendarUnit::from_str(unit)?;

        // Per FHIRPath spec: "For precisions above seconds, the decimal portion is ignored"
        // For seconds and milliseconds, we can still handle fractional conversion
        let value = match calendar_unit {
            CalendarUnit::Second | CalendarUnit::Millisecond => {
                if quantity_value.fract() == Decimal::ZERO {
                    quantity_value.to_i64()?
                } else {
                // For fractional values with fixed-duration units, convert to smaller unit
                match calendar_unit {
                    CalendarUnit::Second => {
                        // Convert fractional seconds to milliseconds
                        let ms = quantity_value * Decimal::from(1000);
                        if ms.fract() == Decimal::ZERO {
                            let duration =
                                CalendarDuration::new(ms.to_i64()?, CalendarUnit::Millisecond);
                            return self.apply_calendar_duration(temporal, duration);
                        } else {
                            return None; // Can't handle sub-millisecond precision
                        }
                    }
                    CalendarUnit::Minute => {
                        // Convert fractional minutes to seconds
                        let seconds = quantity_value * Decimal::from(60);
                        if seconds.fract() == Decimal::ZERO {
                            let duration =
                                CalendarDuration::new(seconds.to_i64()?, CalendarUnit::Second);
                            return self.apply_calendar_duration(temporal, duration);
                        } else {
                            // Try milliseconds
                            let ms = seconds * Decimal::from(1000);
                            if ms.fract() == Decimal::ZERO {
                                let duration =
                                    CalendarDuration::new(ms.to_i64()?, CalendarUnit::Millisecond);
                                return self.apply_calendar_duration(temporal, duration);
                            } else {
                                return None; // Can't handle sub-millisecond precision
                            }
                        }
                    }
                    CalendarUnit::Hour => {
                        // Convert fractional hours to minutes
                        let minutes = quantity_value * Decimal::from(60);
                        if minutes.fract() == Decimal::ZERO {
                            let duration =
                                CalendarDuration::new(minutes.to_i64()?, CalendarUnit::Minute);
                            return self.apply_calendar_duration(temporal, duration);
                        } else {
                            // Try seconds
                            let seconds = minutes * Decimal::from(60);
                            if seconds.fract() == Decimal::ZERO {
                                let duration =
                                    CalendarDuration::new(seconds.to_i64()?, CalendarUnit::Second);
                                return self.apply_calendar_duration(temporal, duration);
                            } else {
                                // Try milliseconds
                                let ms = seconds * Decimal::from(1000);
                                if ms.fract() == Decimal::ZERO {
                                    let duration = CalendarDuration::new(
                                        ms.to_i64()?,
                                        CalendarUnit::Millisecond,
                                    );
                                    return self.apply_calendar_duration(temporal, duration);
                                } else {
                                    return None; // Can't handle sub-millisecond precision
                                }
                            }
                        }
                    }
                    CalendarUnit::Day => {
                        // Convert fractional days to hours
                        let hours = quantity_value * Decimal::from(24);
                        if hours.fract() == Decimal::ZERO {
                            let duration =
                                CalendarDuration::new(hours.to_i64()?, CalendarUnit::Hour);
                            return self.apply_calendar_duration(temporal, duration);
                        } else {
                            // Try minutes
                            let minutes = hours * Decimal::from(60);
                            if minutes.fract() == Decimal::ZERO {
                                let duration =
                                    CalendarDuration::new(minutes.to_i64()?, CalendarUnit::Minute);
                                return self.apply_calendar_duration(temporal, duration);
                            } else {
                                // Try seconds
                                let seconds = minutes * Decimal::from(60);
                                if seconds.fract() == Decimal::ZERO {
                                    let duration = CalendarDuration::new(
                                        seconds.to_i64()?,
                                        CalendarUnit::Second,
                                    );
                                    return self.apply_calendar_duration(temporal, duration);
                                } else {
                                    // Try milliseconds (7.7 days = 7.7 * 24 * 60 * 60 * 1000 = 665,280,000 ms)
                                    let ms = seconds * Decimal::from(1000);
                                    if ms.fract() == Decimal::ZERO {
                                        let duration = CalendarDuration::new(
                                            ms.to_i64()?,
                                            CalendarUnit::Millisecond,
                                        );
                                        return self.apply_calendar_duration(temporal, duration);
                                    } else {
                                        return None; // Can't handle sub-millisecond precision
                                    }
                                }
                            }
                        }
                    }
                    CalendarUnit::Week => {
                        // Convert fractional weeks to days
                        let days = quantity_value * Decimal::from(7);
                        if days.fract() == Decimal::ZERO {
                            let duration = CalendarDuration::new(days.to_i64()?, CalendarUnit::Day);
                            return self.apply_calendar_duration(temporal, duration);
                        } else {
                            // Continue converting down the chain like days
                            let hours = days * Decimal::from(24);
                            if hours.fract() == Decimal::ZERO {
                                let duration =
                                    CalendarDuration::new(hours.to_i64()?, CalendarUnit::Hour);
                                return self.apply_calendar_duration(temporal, duration);
                            } else {
                                let minutes = hours * Decimal::from(60);
                                if minutes.fract() == Decimal::ZERO {
                                    let duration = CalendarDuration::new(
                                        minutes.to_i64()?,
                                        CalendarUnit::Minute,
                                    );
                                    return self.apply_calendar_duration(temporal, duration);
                                } else {
                                    let seconds = minutes * Decimal::from(60);
                                    if seconds.fract() == Decimal::ZERO {
                                        let duration = CalendarDuration::new(
                                            seconds.to_i64()?,
                                            CalendarUnit::Second,
                                        );
                                        return self.apply_calendar_duration(temporal, duration);
                                    } else {
                                        let ms = seconds * Decimal::from(1000);
                                        if ms.fract() == Decimal::ZERO {
                                            let duration = CalendarDuration::new(
                                                ms.to_i64()?,
                                                CalendarUnit::Millisecond,
                                            );
                                            return self
                                                .apply_calendar_duration(temporal, duration);
                                        } else {
                                            return None; // Can't handle sub-millisecond precision
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => return None, // Calendar units like month/year don't support fractional values in FHIRPath
                }
            }
        };

        let duration = CalendarDuration::new(value, calendar_unit);
        self.apply_calendar_duration(temporal, duration)
    }

    /// Apply a calendar duration to a temporal value
    fn apply_calendar_duration(
        &self,
        temporal: &FhirPathValue,
        duration: CalendarDuration,
    ) -> Option<FhirPathValue> {
        match temporal {
            FhirPathValue::Date(precision_date, _, _) => duration
                .add_to_date(precision_date)
                .ok()
                .map(FhirPathValue::date),
            FhirPathValue::DateTime(precision_datetime, _, _) => duration
                .add_to_datetime(precision_datetime)
                .ok()
                .map(FhirPathValue::datetime),
            FhirPathValue::Time(precision_time, _, _) => {
                // For time arithmetic, we need to handle time-only duration addition
                self.add_duration_to_time(precision_time, &duration)
            }
            _ => None,
        }
    }

    /// Add a calendar duration to a time value (handles wrapping around 24 hours)
    fn add_duration_to_time(
        &self,
        time: &crate::core::temporal::PrecisionTime,
        duration: &CalendarDuration,
    ) -> Option<FhirPathValue> {
        use crate::core::temporal::PrecisionTime;
        use chrono::Timelike;

        // Only time units make sense for time addition
        let total_ms = duration.to_milliseconds()?;

        // Convert time to total milliseconds since midnight
        let time_ms = time.time.hour() as i64 * 3_600_000
            + time.time.minute() as i64 * 60_000
            + time.time.second() as i64 * 1_000
            + time.time.nanosecond() as i64 / 1_000_000;

        // Add duration and handle wrap-around
        let new_time_ms = (time_ms + total_ms) % (24 * 3_600_000);
        let positive_time_ms = if new_time_ms < 0 {
            new_time_ms + (24 * 3_600_000)
        } else {
            new_time_ms
        };

        // Convert back to time components
        let hours = (positive_time_ms / 3_600_000) as u32;
        let minutes = ((positive_time_ms % 3_600_000) / 60_000) as u32;
        let seconds = ((positive_time_ms % 60_000) / 1_000) as u32;
        let milliseconds = (positive_time_ms % 1_000) as u32;

        // Create new time
        let nanoseconds = milliseconds * 1_000_000;
        let new_time = chrono::NaiveTime::from_hms_nano_opt(hours, minutes, seconds, nanoseconds)?;
        let precision_time = PrecisionTime::new(new_time, time.precision);

        Some(FhirPathValue::time(precision_time))
    }
}

#[async_trait]
impl OperationEvaluator for AddOperatorEvaluator {
    async fn evaluate(
        &self,
        _input: Vec<FhirPathValue>,
        _context: &EvaluationContext,
        left: Vec<FhirPathValue>,
        right: Vec<FhirPathValue>,
    ) -> Result<EvaluationResult> {
        // Empty propagation: if either operand is empty, result is empty
        if left.is_empty() || right.is_empty() {
            return Ok(EvaluationResult {
                value: Collection::empty(),
            });
        }

        // For arithmetic, we use the first elements (singleton evaluation)
        let left_value = left.first().unwrap();
        let right_value = right.first().unwrap();

        match self.add_values(left_value, right_value) {
            Some(result) => Ok(EvaluationResult {
                value: Collection::single(result),
            }),
            None => Ok(EvaluationResult {
                value: Collection::empty(),
            }),
        }
    }

    fn metadata(&self) -> &OperatorMetadata {
        &self.metadata
    }
}

/// Create metadata for the addition operator
fn create_add_metadata() -> OperatorMetadata {
    let signature = TypeSignature::polymorphic(
        vec![FhirPathType::Any, FhirPathType::Any],
        FhirPathType::Any, // Return type depends on operands
    );

    OperatorMetadata {
        name: "+".to_string(),
        description: "Addition for numeric types, temporal arithmetic, and string concatenation"
            .to_string(),
        signature: OperatorSignature {
            signature,
            overloads: vec![
                // Numeric addition
                TypeSignature::new(
                    vec![FhirPathType::Integer, FhirPathType::Integer],
                    FhirPathType::Integer,
                ),
                TypeSignature::new(
                    vec![FhirPathType::Decimal, FhirPathType::Decimal],
                    FhirPathType::Decimal,
                ),
                TypeSignature::new(
                    vec![FhirPathType::Integer, FhirPathType::Decimal],
                    FhirPathType::Decimal,
                ),
                TypeSignature::new(
                    vec![FhirPathType::Decimal, FhirPathType::Integer],
                    FhirPathType::Decimal,
                ),
                TypeSignature::new(
                    vec![FhirPathType::Quantity, FhirPathType::Quantity],
                    FhirPathType::Quantity,
                ),
                // Temporal arithmetic
                TypeSignature::new(
                    vec![FhirPathType::Date, FhirPathType::Quantity],
                    FhirPathType::Date,
                ),
                TypeSignature::new(
                    vec![FhirPathType::DateTime, FhirPathType::Quantity],
                    FhirPathType::DateTime,
                ),
                TypeSignature::new(
                    vec![FhirPathType::Time, FhirPathType::Quantity],
                    FhirPathType::Time,
                ),
                // String concatenation
                TypeSignature::new(
                    vec![FhirPathType::String, FhirPathType::String],
                    FhirPathType::String,
                ),
            ],
        },
        empty_propagation: EmptyPropagation::Propagate,
        deterministic: true,
        precedence: 7, // FHIRPath arithmetic precedence
        associativity: Associativity::Left,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::Collection;

    #[tokio::test]
    async fn test_add_integers() {
        let evaluator = AddOperatorEvaluator::new();
        let context = EvaluationContext::new(
            Collection::empty(),
            std::sync::Arc::new(crate::core::test_utils::create_test_model_provider()),
            None,
        )
        .await;

        let left = vec![FhirPathValue::integer(5)];
        let right = vec![FhirPathValue::integer(3)];

        let result = evaluator
            .evaluate(vec![], &context, left, right)
            .await
            .unwrap();

        assert_eq!(result.value.len(), 1);
        assert_eq!(result.value.first().unwrap().as_integer(), Some(8));
    }

    #[tokio::test]
    async fn test_add_decimals() {
        let evaluator = AddOperatorEvaluator::new();
        let context = EvaluationContext::new(
            Collection::empty(),
            std::sync::Arc::new(crate::core::test_utils::create_test_model_provider()),
            None,
        )
        .await;

        let left = vec![FhirPathValue::decimal(5.5)];
        let right = vec![FhirPathValue::decimal(3.2)];

        let result = evaluator
            .evaluate(vec![], &context, left, right)
            .await
            .unwrap();

        assert_eq!(result.value.len(), 1);
        assert_eq!(
            result.value.first().unwrap().as_decimal(),
            Some(Decimal::from_f64_retain(8.7).unwrap())
        );
    }

    #[tokio::test]
    async fn test_add_integer_decimal() {
        let evaluator = AddOperatorEvaluator::new();
        let context = EvaluationContext::new(
            Collection::empty(),
            std::sync::Arc::new(crate::core::test_utils::create_test_model_provider()),
            None,
        )
        .await;

        let left = vec![FhirPathValue::integer(5)];
        let right = vec![FhirPathValue::decimal(3.5)];

        let result = evaluator
            .evaluate(vec![], &context, left, right)
            .await
            .unwrap();

        assert_eq!(result.value.len(), 1);
        assert_eq!(
            result.value.first().unwrap().as_decimal(),
            Some(Decimal::from_f64_retain(8.5).unwrap())
        );
    }

    #[tokio::test]
    async fn test_add_strings() {
        let evaluator = AddOperatorEvaluator::new();
        let context = EvaluationContext::new(
            Collection::empty(),
            std::sync::Arc::new(crate::core::test_utils::create_test_model_provider()),
            None,
        )
        .await;

        let left = vec![FhirPathValue::string("Hello".to_string())];
        let right = vec![FhirPathValue::string(" World".to_string())];

        let result = evaluator
            .evaluate(vec![], &context, left, right)
            .await
            .unwrap();

        assert_eq!(result.value.len(), 1);
        assert_eq!(
            result.value.first().unwrap().as_string(),
            Some("Hello World".to_string())
        );
    }

    #[tokio::test]
    async fn test_add_quantities_same_unit() {
        let evaluator = AddOperatorEvaluator::new();
        let context = EvaluationContext::new(
            Collection::empty(),
            std::sync::Arc::new(crate::core::test_utils::create_test_model_provider()),
            None,
        )
        .await;

        let left = vec![FhirPathValue::quantity(5.0, "kg".to_string())];
        let right = vec![FhirPathValue::quantity(3.0, "kg".to_string())];

        let result = evaluator
            .evaluate(vec![], &context, left, right)
            .await
            .unwrap();

        assert_eq!(result.value.len(), 1);
        if let FhirPathValue::Quantity { value, unit, .. } = result.value.first().unwrap() {
            assert_eq!(*value, Decimal::from_f64_retain(8.0).unwrap());
            assert_eq!(*unit, "kg");
        } else {
            panic!("Expected quantity result");
        }
    }

    #[tokio::test]
    async fn test_add_empty_propagation() {
        let evaluator = AddOperatorEvaluator::new();
        let context = EvaluationContext::new(
            Collection::empty(),
            std::sync::Arc::new(crate::core::test_utils::create_test_model_provider()),
            None,
        )
        .await;

        let left = vec![FhirPathValue::integer(5)];
        let right = vec![]; // Empty collection

        let result = evaluator
            .evaluate(vec![], &context, left, right)
            .await
            .unwrap();

        assert!(result.value.is_empty());
    }
}
