// Copyright 2024 OctoFHIR Team
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! TUI Utilities and Advanced Features
//! 
//! This module provides advanced functionality for the TUI including:
//! - Real-time syntax highlighting
//! - Context-aware auto-completion
//! - Performance optimizations
//! - Text manipulation utilities

pub mod syntax_highlighter;
pub mod completion_engine;
pub mod text_editor;
pub mod performance;

use std::ops::Range;
use std::sync::Arc;

use ratatui::style::{Color, Style};
use ratatui::text::{Line, Span};

use octofhir_fhirpath::analyzer::StaticAnalyzer;
use octofhir_fhirpath::core::ModelProvider;
use octofhir_fhirpath::diagnostics::AriadneDiagnostic;
use octofhir_fhirpath::registry::FunctionRegistry;

use super::app::{AppState, CompletionItem, CompletionKind};
use super::themes::TuiTheme;

pub use syntax_highlighter::SyntaxHighlighter;
pub use completion_engine::CompletionEngine;
pub use text_editor::TextEditor;
pub use performance::PerformanceTracker;

/// Syntax highlighting system for FHIRPath expressions
pub mod syntax_highlighter {
    use super::*;
    
    /// Real-time syntax highlighter for FHIRPath expressions
    pub struct SyntaxHighlighter {
        theme: Arc<TuiTheme>,
        cache: HighlightCache,
    }
    
    /// Cache for syntax highlighting results
    #[derive(Default)]
    struct HighlightCache {
        last_expression: String,
        last_result: Vec<HighlightedSpan>,
    }
    
    /// A highlighted span of text
    #[derive(Debug, Clone)]
    pub struct HighlightedSpan {
        pub range: Range<usize>,
        pub style: Style,
        pub token_type: String,
    }
    
    impl SyntaxHighlighter {
        /// Create a new syntax highlighter
        pub fn new(theme: Arc<TuiTheme>) -> Self {
            Self {
                theme,
                cache: HighlightCache::default(),
            }
        }
        
        /// Highlight a FHIRPath expression
        pub fn highlight(&mut self, expression: &str) -> Vec<HighlightedSpan> {
            // Check cache first
            if expression == self.cache.last_expression {
                return self.cache.last_result.clone();
            }
            
            // Simple pattern-based highlighting for now
            let mut spans = Vec::new();
            
            // Basic FHIRPath keyword highlighting (will use registry later)
            let _keywords = ["and", "or", "xor", "implies", "is", "as", "div", "mod", "in", "contains"];
            let _functions = ["first", "last", "count", "exists", "empty", "where", "select"];
            
            // For now, just highlight the whole expression as normal text
            // This is a simplified version until we have proper tokenization
            spans.push(HighlightedSpan {
                range: 0..expression.len(),
                style: self.theme.get_syntax_style("identifier"),
                token_type: "identifier".to_string(),
            });
            
            // Update cache
            self.cache.last_expression = expression.to_string();
            self.cache.last_result = spans.clone();
            
            spans
        }
        
        /// Highlight expression with diagnostic overlays
        pub fn highlight_with_diagnostics(
            &mut self,
            expression: &str,
            diagnostics: &[AriadneDiagnostic],
        ) -> Vec<HighlightedSpan> {
            let mut spans = self.highlight(expression);
            
            // Overlay diagnostic highlighting
            for diagnostic in diagnostics {
                let range = &diagnostic.span;
                let severity_str = format!("{:?}", diagnostic.severity).to_lowercase();
                let error_style = self.theme.get_diagnostic_style(&severity_str);
                
                // Find spans that overlap with the diagnostic range
                for span in &mut spans {
                    if spans_overlap(&span.range, range) {
                        span.style = error_style;
                        span.token_type = format!("{:?}_{}", diagnostic.severity, span.token_type);
                    }
                }
            }
            
            spans
        }
        
        /// Convert highlighted spans to ratatui Line
        pub fn spans_to_line<'a>(&self, text: &'a str, spans: &[HighlightedSpan]) -> Line<'a> {
            if spans.is_empty() {
                return Line::from(text);
            }
            
            let mut ratatui_spans = Vec::new();
            let mut last_end = 0;
            
            for span in spans {
                // Add any unhighlighted text before this span
                if span.range.start > last_end {
                    let unhighlighted = &text[last_end..span.range.start];
                    if !unhighlighted.is_empty() {
                        ratatui_spans.push(Span::raw(unhighlighted));
                    }
                }
                
                // Add the highlighted span
                let highlighted_text = &text[span.range.clone()];
                ratatui_spans.push(Span::styled(highlighted_text, span.style));
                
                last_end = span.range.end;
            }
            
            // Add any remaining unhighlighted text
            if last_end < text.len() {
                let remaining = &text[last_end..];
                if !remaining.is_empty() {
                    ratatui_spans.push(Span::raw(remaining));
                }
            }
            
            Line::from(ratatui_spans)
        }
        
        
        /// Update theme
        pub fn set_theme(&mut self, theme: Arc<TuiTheme>) {
            self.theme = theme;
            // Clear cache to force re-highlighting with new theme
            self.cache.last_expression.clear();
        }
    }
    
    /// Check if two ranges overlap
    fn spans_overlap(range1: &Range<usize>, range2: &Range<usize>) -> bool {
        range1.start < range2.end && range2.start < range1.end
    }
}

/// Auto-completion engine for FHIRPath expressions
pub mod completion_engine {
    use super::*;
    
    /// Context-aware completion engine
    pub struct CompletionEngine {
        model_provider: Arc<dyn ModelProvider>,
        function_registry: Option<Arc<FunctionRegistry>>,
        analyzer: Arc<StaticAnalyzer>,
        cache: CompletionCache,
    }
    
    /// Cache for completion results
    #[derive(Default)]
    struct CompletionCache {
        functions: Vec<CompletionItem>,
        properties: std::collections::HashMap<String, Vec<CompletionItem>>,
        keywords: Vec<CompletionItem>,
    }
    
    /// Completion context information
    #[derive(Debug)]
    pub struct CompletionContext {
        pub expression: String,
        pub cursor_position: usize,
        pub current_resource_type: Option<String>,
        pub preceding_path: Vec<String>,
    }
    
    impl CompletionEngine {
        /// Create a new completion engine
        pub async fn new(
            model_provider: Arc<dyn ModelProvider>,
            function_registry: Arc<FunctionRegistry>,
            analyzer: Arc<StaticAnalyzer>,
        ) -> anyhow::Result<Self> {
            let mut engine = Self {
                model_provider,
                function_registry,
                analyzer,
                cache: CompletionCache::default(),
            };
            
            // Pre-populate cache
            engine.populate_function_cache().await?;
            engine.populate_keyword_cache();
            
            Ok(engine)
        }
        
        /// Get completions for the given context
        pub async fn get_completions(
            &mut self,
            context: CompletionContext,
            state: &AppState,
        ) -> anyhow::Result<Vec<CompletionItem>> {
            let mut completions = Vec::new();
            
            // Determine what kind of completion is needed based on context
            let completion_type = self.analyze_completion_context(&context)?;
            
            match completion_type {
                CompletionType::Function => {
                    completions.extend(self.get_function_completions(&context).await?);
                }
                CompletionType::Property => {
                    completions.extend(self.get_property_completions(&context).await?);
                }
                CompletionType::ResourceType => {
                    completions.extend(self.get_resource_type_completions(&context).await?);
                }
                CompletionType::Variable => {
                    completions.extend(self.get_variable_completions(&context, state));
                }
                CompletionType::Keyword => {
                    completions.extend(self.get_keyword_completions(&context));
                }
                CompletionType::Mixed => {
                    // Provide all types of completions, ranked by relevance
                    completions.extend(self.get_function_completions(&context).await?);
                    completions.extend(self.get_property_completions(&context).await?);
                    completions.extend(self.get_variable_completions(&context, state));
                }
            }
            
            // Sort by relevance
            self.rank_completions(&mut completions, &context);
            
            Ok(completions)
        }
        
        /// Analyze context to determine completion type
        fn analyze_completion_context(&self, context: &CompletionContext) -> anyhow::Result<CompletionType> {
            let text_before_cursor = &context.expression[..context.cursor_position];
            
            if text_before_cursor.ends_with('.') {
                Ok(CompletionType::Property)
            } else if text_before_cursor.contains('(') && !text_before_cursor.ends_with(')') {
                Ok(CompletionType::Function)
            } else if text_before_cursor.ends_with('%') {
                Ok(CompletionType::Variable)
            } else if text_before_cursor.is_empty() || text_before_cursor.ends_with(' ') {
                Ok(CompletionType::Mixed)
            } else {
                Ok(CompletionType::Mixed)
            }
        }
        
        /// Get function completions
        async fn get_function_completions(&self, _context: &CompletionContext) -> anyhow::Result<Vec<CompletionItem>> {
            Ok(self.cache.functions.clone())
        }
        
        /// Get property completions
        async fn get_property_completions(&self, context: &CompletionContext) -> anyhow::Result<Vec<CompletionItem>> {
            let resource_type = context.current_resource_type
                .as_deref()
                .unwrap_or("Resource");
            
            if let Some(cached) = self.cache.properties.get(resource_type) {
                return Ok(cached.clone());
            }
            
            // This would integrate with the ModelProvider to get actual properties
            // For now, return empty list
            Ok(Vec::new())
        }
        
        /// Get resource type completions
        async fn get_resource_type_completions(&self, _context: &CompletionContext) -> anyhow::Result<Vec<CompletionItem>> {
            // This would get resource types from ModelProvider
            Ok(vec![
                CompletionItem {
                    text: "Patient".to_string(),
                    display: "Patient".to_string(),
                    kind: CompletionKind::ResourceType,
                    documentation: Some("Patient resource type".to_string()),
                    insert_range: None,
                },
                CompletionItem {
                    text: "Observation".to_string(),
                    display: "Observation".to_string(),
                    kind: CompletionKind::ResourceType,
                    documentation: Some("Observation resource type".to_string()),
                    insert_range: None,
                },
            ])
        }
        
        /// Get variable completions
        fn get_variable_completions(&self, _context: &CompletionContext, state: &AppState) -> Vec<CompletionItem> {
            state.variables.keys()
                .map(|name| CompletionItem {
                    text: format!("%{}", name),
                    display: format!("%{}", name),
                    kind: CompletionKind::Variable,
                    documentation: Some(format!("Variable: {}", name)),
                    insert_range: None,
                })
                .collect()
        }
        
        /// Get keyword completions
        fn get_keyword_completions(&self, _context: &CompletionContext) -> Vec<CompletionItem> {
            self.cache.keywords.clone()
        }
        
        /// Rank completions by relevance
        fn rank_completions(&self, completions: &mut Vec<CompletionItem>, context: &CompletionContext) {
            let partial = self.get_partial_word(context);
            
            completions.sort_by(|a, b| {
                let a_score = self.completion_score(a, &partial);
                let b_score = self.completion_score(b, &partial);
                b_score.partial_cmp(&a_score).unwrap_or(std::cmp::Ordering::Equal)
            });
        }
        
        /// Get partial word being completed
        fn get_partial_word(&self, context: &CompletionContext) -> String {
            let text_before_cursor = &context.expression[..context.cursor_position];
            text_before_cursor.split(|c: char| !c.is_alphanumeric() && c != '_')
                .last()
                .unwrap_or("")
                .to_string()
        }
        
        /// Calculate relevance score for a completion
        fn completion_score(&self, completion: &CompletionItem, partial: &str) -> f64 {
            if partial.is_empty() {
                return match completion.kind {
                    CompletionKind::Function => 1.0,
                    CompletionKind::Property => 0.9,
                    CompletionKind::Variable => 0.8,
                    CompletionKind::Keyword => 0.7,
                    CompletionKind::ResourceType => 0.6,
                    CompletionKind::Operator => 0.5,
                };
            }
            
            let text = completion.text.to_lowercase();
            let partial = partial.to_lowercase();
            
            if text.starts_with(&partial) {
                1.0 + (partial.len() as f64 / text.len() as f64)
            } else if text.contains(&partial) {
                0.5 + (partial.len() as f64 / text.len() as f64)
            } else {
                0.0
            }
        }
        
        /// Pre-populate function cache
        async fn populate_function_cache(&mut self) -> anyhow::Result<()> {
            // Use the actual function registry to get all available functions
            if let Some(registry) = &self.function_registry {
                let functions = registry.list_functions();
                
                for function in functions {
                    let completion = CompletionItem {
                        text: format!("{}()", function.name),
                        display: format!("{}() - {}", function.name, function.description),
                        kind: CompletionKind::Function,
                        documentation: Some(function.description.clone()),
                        insert_range: None,
                    };
                    self.cache.functions.push(completion);
                }
            } else {
                // Fallback to basic function list when registry is not available
                let basic_functions = vec![
                    "first", "last", "count", "empty", "exists", "where", "select", "single"
                ];
                
                for name in basic_functions {
                    let completion = CompletionItem {
                        text: format!("{}()", name),
                        display: format!("{}() - FHIRPath function", name),
                        kind: CompletionKind::Function,
                        documentation: Some(format!("FHIRPath {} function", name)),
                        insert_range: None,
                    };
                    self.cache.functions.push(completion);
                }
            }
            
            Ok(())
        }
        
        /// Pre-populate keyword cache
        fn populate_keyword_cache(&mut self) {
            let keywords = vec![
                ("and", "Logical AND operator"),
                ("or", "Logical OR operator"),
                ("xor", "Logical XOR operator"),
                ("implies", "Logical implication operator"),
                ("is", "Type checking operator"),
                ("as", "Type casting operator"),
                ("div", "Integer division operator"),
                ("mod", "Modulo operator"),
                ("in", "Membership test operator"),
                ("contains", "String/collection contains operator"),
                ("true", "Boolean true literal"),
                ("false", "Boolean false literal"),
                ("null", "Null literal"),
            ];
            
            for (keyword, description) in keywords {
                let completion = CompletionItem {
                    text: keyword.to_string(),
                    display: format!("{} - {}", keyword, description),
                    kind: CompletionKind::Keyword,
                    documentation: Some(description.to_string()),
                    insert_range: None,
                };
                self.cache.keywords.push(completion);
            }
        }
    }
    
    /// Type of completion being requested
    #[derive(Debug, Clone, PartialEq)]
    enum CompletionType {
        Function,
        Property,
        ResourceType,
        Variable,
        Keyword,
        Mixed,
    }
}

/// Text editing utilities for input handling
pub mod text_editor {
    use super::*;
    
    /// Advanced text editor with FHIRPath-aware features
    pub struct TextEditor {
        text: String,
        cursor_position: usize,
        selection: Option<Range<usize>>,
        undo_stack: Vec<EditorState>,
        redo_stack: Vec<EditorState>,
    }
    
    /// Editor state for undo/redo
    #[derive(Debug, Clone)]
    struct EditorState {
        text: String,
        cursor_position: usize,
        selection: Option<Range<usize>>,
    }
    
    impl TextEditor {
        /// Create a new text editor
        pub fn new() -> Self {
            Self {
                text: String::new(),
                cursor_position: 0,
                selection: None,
                undo_stack: Vec::new(),
                redo_stack: Vec::new(),
            }
        }
        
        /// Get current text
        pub fn text(&self) -> &str {
            &self.text
        }
        
        /// Set text content
        pub fn set_text(&mut self, text: String) {
            self.save_state();
            self.text = text;
            self.cursor_position = self.cursor_position.min(self.text.len());
            self.selection = None;
        }
        
        /// Get cursor position
        pub fn cursor_position(&self) -> usize {
            self.cursor_position
        }
        
        /// Set cursor position
        pub fn set_cursor_position(&mut self, position: usize) {
            self.cursor_position = position.min(self.text.len());
            self.selection = None;
        }
        
        /// Insert text at cursor
        pub fn insert_text(&mut self, text: &str) {
            self.save_state();
            
            if let Some(selection) = &self.selection {
                // Replace selection
                self.text.replace_range(selection.clone(), text);
                self.cursor_position = selection.start + text.len();
                self.selection = None;
            } else {
                // Insert at cursor
                self.text.insert_str(self.cursor_position, text);
                self.cursor_position += text.len();
            }
        }
        
        /// Delete character at cursor
        pub fn delete_char(&mut self) {
            if self.cursor_position < self.text.len() {
                self.save_state();
                self.text.remove(self.cursor_position);
            }
        }
        
        /// Delete character before cursor (backspace)
        pub fn backspace(&mut self) {
            if self.cursor_position > 0 {
                self.save_state();
                self.cursor_position -= 1;
                self.text.remove(self.cursor_position);
            }
        }
        
        /// Move cursor left
        pub fn cursor_left(&mut self) {
            if self.cursor_position > 0 {
                self.cursor_position -= 1;
            }
        }
        
        /// Move cursor right
        pub fn cursor_right(&mut self) {
            if self.cursor_position < self.text.len() {
                self.cursor_position += 1;
            }
        }
        
        /// Move cursor to start
        pub fn cursor_home(&mut self) {
            self.cursor_position = 0;
        }
        
        /// Move cursor to end
        pub fn cursor_end(&mut self) {
            self.cursor_position = self.text.len();
        }
        
        /// Move cursor to previous word
        pub fn cursor_word_left(&mut self) {
            if self.cursor_position > 0 {
                let mut pos = self.cursor_position - 1;
                
                // Skip whitespace
                while pos > 0 && self.text.chars().nth(pos).map_or(false, |c| c.is_whitespace()) {
                    pos -= 1;
                }
                
                // Skip to start of word
                while pos > 0 && self.text.chars().nth(pos - 1).map_or(false, |c| c.is_alphanumeric()) {
                    pos -= 1;
                }
                
                self.cursor_position = pos;
            }
        }
        
        /// Move cursor to next word
        pub fn cursor_word_right(&mut self) {
            if self.cursor_position < self.text.len() {
                let mut pos = self.cursor_position;
                let chars: Vec<char> = self.text.chars().collect();
                
                // Skip current word
                while pos < chars.len() && chars[pos].is_alphanumeric() {
                    pos += 1;
                }
                
                // Skip whitespace
                while pos < chars.len() && chars[pos].is_whitespace() {
                    pos += 1;
                }
                
                self.cursor_position = pos;
            }
        }
        
        /// Delete word at cursor
        pub fn delete_word(&mut self) {
            let start = self.cursor_position;
            self.cursor_word_right();
            let end = self.cursor_position;
            
            if start != end {
                self.save_state();
                self.text.drain(start..end);
                self.cursor_position = start;
            }
        }
        
        /// Delete to end of line
        pub fn delete_to_end(&mut self) {
            if self.cursor_position < self.text.len() {
                self.save_state();
                self.text.truncate(self.cursor_position);
            }
        }
        
        /// Clear all text
        pub fn clear(&mut self) {
            if !self.text.is_empty() {
                self.save_state();
                self.text.clear();
                self.cursor_position = 0;
                self.selection = None;
            }
        }
        
        /// Undo last operation
        pub fn undo(&mut self) {
            if let Some(state) = self.undo_stack.pop() {
                let current_state = EditorState {
                    text: self.text.clone(),
                    cursor_position: self.cursor_position,
                    selection: self.selection.clone(),
                };
                self.redo_stack.push(current_state);
                
                self.text = state.text;
                self.cursor_position = state.cursor_position;
                self.selection = state.selection;
            }
        }
        
        /// Redo last undone operation
        pub fn redo(&mut self) {
            if let Some(state) = self.redo_stack.pop() {
                let current_state = EditorState {
                    text: self.text.clone(),
                    cursor_position: self.cursor_position,
                    selection: self.selection.clone(),
                };
                self.undo_stack.push(current_state);
                
                self.text = state.text;
                self.cursor_position = state.cursor_position;
                self.selection = state.selection;
            }
        }
        
        /// Save current state for undo
        fn save_state(&mut self) {
            let state = EditorState {
                text: self.text.clone(),
                cursor_position: self.cursor_position,
                selection: self.selection.clone(),
            };
            self.undo_stack.push(state);
            
            // Limit undo stack size
            if self.undo_stack.len() > 100 {
                self.undo_stack.remove(0);
            }
            
            // Clear redo stack when new changes are made
            self.redo_stack.clear();
        }
    }
    
    impl Default for TextEditor {
        fn default() -> Self {
            Self::new()
        }
    }
}

/// Performance monitoring and optimization
pub mod performance {
    use super::*;
    use std::time::{Duration, Instant};
    
    /// Performance tracking for TUI operations
    pub struct PerformanceTracker {
        metrics: std::collections::HashMap<String, PerformanceMetric>,
        render_times: std::collections::VecDeque<Duration>,
        max_samples: usize,
    }
    
    /// Individual performance metric
    #[derive(Debug, Clone)]
    pub struct PerformanceMetric {
        pub name: String,
        pub total_time: Duration,
        pub count: u64,
        pub average_time: Duration,
        pub min_time: Duration,
        pub max_time: Duration,
        pub last_time: Duration,
    }
    
    impl PerformanceTracker {
        /// Create a new performance tracker
        pub fn new(max_samples: usize) -> Self {
            Self {
                metrics: std::collections::HashMap::new(),
                render_times: std::collections::VecDeque::new(),
                max_samples,
            }
        }
        
        /// Start timing an operation
        pub fn start_timer(&self, _name: &str) -> Timer {
            Timer::new()
        }
        
        /// Record operation completion
        pub fn record(&mut self, name: &str, duration: Duration) {
            let metric = self.metrics.entry(name.to_string()).or_insert_with(|| {
                PerformanceMetric {
                    name: name.to_string(),
                    total_time: Duration::ZERO,
                    count: 0,
                    average_time: Duration::ZERO,
                    min_time: Duration::MAX,
                    max_time: Duration::ZERO,
                    last_time: Duration::ZERO,
                }
            });
            
            metric.total_time += duration;
            metric.count += 1;
            metric.average_time = metric.total_time / metric.count as u32;
            metric.min_time = metric.min_time.min(duration);
            metric.max_time = metric.max_time.max(duration);
            metric.last_time = duration;
        }
        
        /// Record render time
        pub fn record_render_time(&mut self, duration: Duration) {
            self.render_times.push_back(duration);
            if self.render_times.len() > self.max_samples {
                self.render_times.pop_front();
            }
        }
        
        /// Get average render time
        pub fn average_render_time(&self) -> Duration {
            if self.render_times.is_empty() {
                Duration::ZERO
            } else {
                let total: Duration = self.render_times.iter().sum();
                total / self.render_times.len() as u32
            }
        }
        
        /// Get current FPS estimate
        pub fn current_fps(&self) -> f64 {
            let avg_render_time = self.average_render_time();
            if avg_render_time.is_zero() {
                0.0
            } else {
                1000.0 / avg_render_time.as_millis() as f64
            }
        }
        
        /// Get performance summary
        pub fn summary(&self) -> Vec<String> {
            let mut summary = Vec::new();
            
            summary.push(format!("Average FPS: {:.1}", self.current_fps()));
            summary.push(format!("Average render time: {:?}", self.average_render_time()));
            
            for metric in self.metrics.values() {
                summary.push(format!(
                    "{}: avg={:?}, count={}, min={:?}, max={:?}",
                    metric.name,
                    metric.average_time,
                    metric.count,
                    metric.min_time,
                    metric.max_time
                ));
            }
            
            summary
        }
        
        /// Check if performance is acceptable
        pub fn is_performance_acceptable(&self) -> bool {
            self.current_fps() >= 30.0 // Target 30 FPS minimum
        }
    }
    
    /// Timer for measuring operation duration
    pub struct Timer {
        start_time: Instant,
    }
    
    impl Timer {
        fn new() -> Self {
            Self {
                start_time: Instant::now(),
            }
        }
        
        /// Stop timer and get elapsed duration
        pub fn elapsed(self) -> Duration {
            self.start_time.elapsed()
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_text_editor() {
        let mut editor = text_editor::TextEditor::new();
        
        editor.insert_text("Patient.name");
        assert_eq!(editor.text(), "Patient.name");
        assert_eq!(editor.cursor_position(), 12);
        
        editor.cursor_left();
        editor.cursor_left();
        editor.cursor_left();
        editor.cursor_left();
        editor.insert_text("given.");
        assert_eq!(editor.text(), "Patient.given.name");
        
        editor.undo();
        assert_eq!(editor.text(), "Patient.name");
        
        editor.redo();
        assert_eq!(editor.text(), "Patient.given.name");
    }
    
    #[test]
    fn test_performance_tracker() {
        let mut tracker = performance::PerformanceTracker::new(10);
        
        tracker.record("test_op", Duration::from_millis(10));
        tracker.record("test_op", Duration::from_millis(20));
        
        let summary = tracker.summary();
        assert!(!summary.is_empty());
    }
}