// Copyright 2024 OctoFHIR Team
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Lambda implementation of sort function - sorts collection with optional lambda expression

use crate::{
    lambda::{ExpressionEvaluator, LambdaContextBuilder, LambdaFunction, LambdaUtils},
    metadata::{FhirPathType, MetadataBuilder, OperationMetadata, OperationType, TypeConstraint},
    operation::{FhirPathOperation, OperationComplexity},
    operations::EvaluationContext,
};
use async_trait::async_trait;
use octofhir_fhirpath_ast::ExpressionNode;
use octofhir_fhirpath_core::{FhirPathError, Result};
use octofhir_fhirpath_model::{FhirPathValue, Collection};
use std::cmp::Ordering;
use rust_decimal::Decimal;

/// Lambda-based Sort function implementation
///
/// This implementation receives expression trees instead of pre-evaluated values,
/// allowing for proper lambda variable scoping with `$this`, `$index`, etc.
#[derive(Debug, Clone)]
pub struct SortLambdaFunction;

impl SortLambdaFunction {
    pub fn new() -> Self {
        Self
    }

    fn create_metadata() -> OperationMetadata {
        MetadataBuilder::new("sort", OperationType::Function)
            .description("Returns the collection sorted by the specified criteria")
            .example("(3 | 1 | 2).sort()")
            .example("('c' | 'a' | 'b').sort($this)")
            .example("(3 | 1 | 2).sort(-$this)")
            .example("Patient.name.sort(-family, -given.first())")
            .parameter("criteria", TypeConstraint::Any, true) // Optional lambda expression
            .parameter("criteria2", TypeConstraint::Any, true) // Optional second criteria
            .returns(TypeConstraint::Any)
            .build()
    }
}

#[async_trait]
impl FhirPathOperation for SortLambdaFunction {
    fn identifier(&self) -> &str {
        "sort"
    }

    fn operation_type(&self) -> OperationType {
        OperationType::Function
    }

    fn metadata(&self) -> &OperationMetadata {
        static METADATA: std::sync::LazyLock<OperationMetadata> = std::sync::LazyLock::new(|| {
            SortLambdaFunction::create_metadata()
        });
        &METADATA
    }

    async fn evaluate(&self, args: &[FhirPathValue], _context: &EvaluationContext) -> Result<FhirPathValue> {
        // This should not be called for lambda functions, but provide fallback
        // In practice, the engine should call evaluate_lambda instead
        Err(FhirPathError::EvaluationError {
            message: format!(
                "sort() is a lambda function and should be called via evaluate_lambda, not evaluate. Got {} pre-evaluated args.",
                args.len()
            ),
        })
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }

    fn complexity_hint(&self) -> OperationComplexity {
        LambdaFunction::complexity_hint(self)
    }

    fn is_pure(&self) -> bool {
        LambdaFunction::is_pure(self)
    }
}

#[async_trait]
impl LambdaFunction for SortLambdaFunction {
    fn identifier(&self) -> &str {
        "sort"
    }

    async fn evaluate_lambda(
        &self,
        expressions: &[ExpressionNode],
        context: &EvaluationContext,
        evaluator: &dyn ExpressionEvaluator,
    ) -> Result<FhirPathValue> {
        // Get input collection
        let items = match &context.input {
            FhirPathValue::Collection(collection) => collection.iter().cloned().collect::<Vec<_>>(),
            single_item => vec![single_item.clone()],
        };

        if items.is_empty() {
            return Ok(FhirPathValue::Collection(Collection::new()));
        }

        match expressions.len() {
            0 => {
                // Parameterless sort - use natural ordering
                let sorted_items = self.natural_sort(items)?;
                Ok(FhirPathValue::Collection(Collection::from_vec(sorted_items)))
            }
            1 => {
                // Single expression sort
                let sorted_items = self.lambda_sort(items, &[expressions[0].clone()], context, evaluator).await?;
                Ok(FhirPathValue::Collection(Collection::from_vec(sorted_items)))
            }
            2 => {
                // Two-expression sort (multi-criteria)
                let sorted_items = self.lambda_sort(items, expressions, context, evaluator).await?;
                Ok(FhirPathValue::Collection(Collection::from_vec(sorted_items)))
            }
            _ => Err(FhirPathError::InvalidArgumentCount {
                function_name: "sort".to_string(),
                expected: 2,
                actual: expressions.len(),
            }),
        }
    }

    fn expected_expression_count(&self) -> usize {
        0 // Variable number of arguments (0, 1, or 2)
    }

    fn validate_expressions(&self, expressions: &[ExpressionNode]) -> Result<()> {
        if expressions.len() > 2 {
            return Err(FhirPathError::InvalidArgumentCount {
                function_name: "sort".to_string(),
                expected: 2,
                actual: expressions.len(),
            });
        }
        Ok(())
    }

    fn complexity_hint(&self) -> OperationComplexity {
        OperationComplexity::Linear // O(n log n) for sorting
    }

    fn is_pure(&self) -> bool {
        true // sort is a pure function
    }
}

impl SortLambdaFunction {
    /// Natural sort without lambda expression
    fn natural_sort(&self, mut items: Vec<FhirPathValue>) -> Result<Vec<FhirPathValue>> {
        items.sort_by(|a, b| self.compare_values(a, b));
        Ok(items)
    }

    /// Extract sort intent from expression AST
    /// Returns (actual_expression, is_descending)
    fn extract_sort_intent<'a>(&self, expression: &'a ExpressionNode) -> (&'a ExpressionNode, bool) {
        use octofhir_fhirpath_ast::{UnaryOperator};
        
        match expression {
            // Detect negative expressions like -$this, -expression
            ExpressionNode::UnaryOp { op: UnaryOperator::Minus, operand } => {
                // This is a descending sort indicator
                (operand.as_ref(), true)
            },
            // All other expressions are ascending
            _ => (expression, false)
        }
    }

    /// Lambda-based sort with expression evaluation
    async fn lambda_sort(
        &self,
        items: Vec<FhirPathValue>,
        expressions: &[ExpressionNode],
        context: &EvaluationContext,
        evaluator: &dyn ExpressionEvaluator,
    ) -> Result<Vec<FhirPathValue>> {
        // Pre-evaluate sort keys for all items with descending flags
        let mut sort_data = Vec::new();
        
        for (index, item) in items.iter().enumerate() {
            let lambda_context = LambdaContextBuilder::new(context)
                .with_this(item.clone())
                .with_index(index as i64)
                .with_input(item.clone())
                .build();

            let mut sort_keys = Vec::new();
            for expression in expressions {
                // Check if this expression represents descending sort (negative pattern)
                let (actual_expr, is_descending) = self.extract_sort_intent(expression);
                
                let key_result = evaluator
                    .evaluate_expression_with_lambda_vars(
                        actual_expr,
                        context,
                        &[("$this".to_string(), item.clone()), ("$index".to_string(), FhirPathValue::Integer(index as i64))],
                    )
                    .await?;
                
                /* OLD: let key_result = evaluator
                    .evaluate_expression(actual_expr, &lambda_context)
                    .await?;
                
                // Store the key with its descending flag
                sort_keys.push((key_result, is_descending));
            }
            
            sort_data.push((item.clone(), sort_keys));
        }

        // Sort using the pre-evaluated keys with descending flags
        sort_data.sort_by(|(_, keys_a), (_, keys_b)| {
            for ((key_a, desc_a), (key_b, desc_b)) in keys_a.iter().zip(keys_b.iter()) {
                let base_cmp = self.compare_values(key_a, key_b);
                let cmp = match (*desc_a, *desc_b) {
                    (true, true) => base_cmp.reverse(),   // Both descending
                    (true, false) => base_cmp.reverse(),  // First descending
                    (false, true) => base_cmp,            // Second descending
                    (false, false) => base_cmp,           // Neither descending
                };
                if cmp != Ordering::Equal {
                    return cmp;
                }
            }
            Ordering::Equal
        });

        // Extract sorted items
        Ok(sort_data.into_iter().map(|(item, _)| item).collect())
    }

    /// Compare sort keys, handling negative values for descending sort
    fn compare_sort_keys(&self, a: &FhirPathValue, b: &FhirPathValue) -> Ordering {
        // Check for negative values (descending sort)
        let (a_val, a_desc) = self.extract_sort_value(a);
        let (b_val, b_desc) = self.extract_sort_value(b);

        let base_cmp = self.compare_values(&a_val, &b_val);
        
        match (a_desc, b_desc) {
            (true, true) => base_cmp.reverse(),   // Both negative: reverse order
            (true, false) => base_cmp.reverse(),  // First negative: reverse order
            (false, true) => base_cmp,            // Second negative: normal order
            (false, false) => base_cmp,           // Neither negative: normal order
        }
    }

    /// Extract sort value and determine if it's negative (for descending sort)
    fn extract_sort_value(&self, value: &FhirPathValue) -> (FhirPathValue, bool) {
        match value {
            FhirPathValue::Integer(n) if *n < 0 => {
                (FhirPathValue::Integer(-n), true)
            }
            FhirPathValue::Decimal(d) if d.is_sign_negative() => {
                (FhirPathValue::Decimal(-d), true)
            }
            _ => (value.clone(), false)
        }
    }

    /// Compare two FhirPathValue instances for sorting
    fn compare_values(&self, a: &FhirPathValue, b: &FhirPathValue) -> Ordering {
        match (a, b) {
            // Integer comparison
            (FhirPathValue::Integer(a), FhirPathValue::Integer(b)) => a.cmp(b),

            // String comparison
            (FhirPathValue::String(a), FhirPathValue::String(b)) => a.cmp(b),

            // Decimal comparison
            (FhirPathValue::Decimal(a), FhirPathValue::Decimal(b)) => a.cmp(b),

            // Boolean comparison
            (FhirPathValue::Boolean(a), FhirPathValue::Boolean(b)) => a.cmp(b),

            // Date comparison
            (FhirPathValue::Date(a), FhirPathValue::Date(b)) => a.cmp(b),

            // DateTime comparison
            (FhirPathValue::DateTime(a), FhirPathValue::DateTime(b)) => a.cmp(b),

            // Time comparison
            (FhirPathValue::Time(a), FhirPathValue::Time(b)) => a.cmp(b),

            // Mixed numeric types - convert to decimal for comparison
            (FhirPathValue::Integer(a), FhirPathValue::Decimal(b)) => {
                Decimal::from(*a).cmp(b)
            },
            (FhirPathValue::Decimal(a), FhirPathValue::Integer(b)) => {
                a.cmp(&Decimal::from(*b))
            },

            // Single-element collections - unwrap and compare
            (FhirPathValue::Collection(a), FhirPathValue::Collection(b)) => {
                match (a.len(), b.len()) {
                    (1, 1) => self.compare_values(a.first().unwrap(), b.first().unwrap()),
                    (0, 0) => Ordering::Equal,
                    (0, _) => Ordering::Less,
                    (_, 0) => Ordering::Greater,
                    _ => Ordering::Equal, // Multi-element collections are equal for sort purposes
                }
            },
            (FhirPathValue::Collection(a), other) if a.len() == 1 => {
                self.compare_values(a.first().unwrap(), other)
            },
            (other, FhirPathValue::Collection(b)) if b.len() == 1 => {
                self.compare_values(other, b.first().unwrap())
            },

            // Empty values
            (FhirPathValue::Empty, FhirPathValue::Empty) => Ordering::Equal,
            (FhirPathValue::Empty, _) => Ordering::Less,
            (_, FhirPathValue::Empty) => Ordering::Greater,

            // Different types - use type precedence
            _ => self.type_precedence(a).cmp(&self.type_precedence(b)),
        }
    }

    /// Define type precedence for mixed-type sorting
    fn type_precedence(&self, value: &FhirPathValue) -> u8 {
        match value {
            FhirPathValue::Empty => 0,
            FhirPathValue::Boolean(_) => 1,
            FhirPathValue::Integer(_) => 2,
            FhirPathValue::Decimal(_) => 3,
            FhirPathValue::String(_) => 4,
            FhirPathValue::Date(_) => 5,
            FhirPathValue::DateTime(_) => 6,
            FhirPathValue::Time(_) => 7,
            FhirPathValue::Collection(_) => 8,
            _ => 9,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use octofhir_fhirpath_model::MockModelProvider;
    use std::sync::Arc;

    fn create_test_context(input: FhirPathValue) -> EvaluationContext {
        let registry = Arc::new(crate::FhirPathRegistry::new());
        let model_provider = Arc::new(MockModelProvider::new());
        EvaluationContext::new(input, registry, model_provider)
    }

    #[tokio::test]
    async fn test_sort_lambda_natural() {
        let sort_fn = SortLambdaFunction::new();
        let input = FhirPathValue::Collection(Collection::from_vec(vec![
            FhirPathValue::Integer(3),
            FhirPathValue::Integer(1),
            FhirPathValue::Integer(2),
        ]));

        let context = create_test_context(input);
        
        // Mock evaluator for parameterless sort
        struct MockEvaluator;
        #[async_trait]
        impl ExpressionEvaluator for MockEvaluator {
            async fn evaluate_expression(
                &self,
                _expression: &ExpressionNode,
                _context: &EvaluationContext,
            ) -> Result<FhirPathValue> {
                Ok(FhirPathValue::Empty)
            }
        }

        let evaluator = MockEvaluator;
        let result = sort_fn
            .evaluate_lambda(&[], &context, &evaluator)
            .await
            .unwrap();

        match result {
            FhirPathValue::Collection(items) => {
                assert_eq!(items.len(), 3);
                assert_eq!(items.iter().nth(0).unwrap(), &FhirPathValue::Integer(1));
                assert_eq!(items.iter().nth(1).unwrap(), &FhirPathValue::Integer(2));
                assert_eq!(items.iter().nth(2).unwrap(), &FhirPathValue::Integer(3));
            },
            _ => panic!("Expected collection result"),
        }
    }

    #[tokio::test]
    async fn test_sort_lambda_with_negative() {
        use octofhir_fhirpath_ast::*;
        
        let sort_fn = SortLambdaFunction::new();
        let input = FhirPathValue::Collection(Collection::from_vec(vec![
            FhirPathValue::Integer(1),
            FhirPathValue::Integer(3), 
            FhirPathValue::Integer(2),
        ]));

        let context = create_test_context(input);
        
        // Create expression for -$this (descending sort)
        let this_expr = ExpressionNode::Variable("$this".to_string());
        let negative_expr = ExpressionNode::UnaryOp {
            op: UnaryOperator::Minus,
            operand: Box::new(this_expr),
        };

        // Mock evaluator that returns negative values for descending sort
        struct MockEvaluator;
        #[async_trait]
        impl ExpressionEvaluator for MockEvaluator {
            async fn evaluate_expression(
                &self,
                _expression: &ExpressionNode,
                context: &EvaluationContext,
            ) -> Result<FhirPathValue> {
                // Return negative of the input for descending sort
                match &context.input {
                    FhirPathValue::Integer(n) => Ok(FhirPathValue::Integer(-n)),
                    other => Ok(other.clone()),
                }
            }
        }

        let evaluator = MockEvaluator;
        let result = sort_fn
            .evaluate_lambda(&[negative_expr], &context, &evaluator)
            .await
            .unwrap();

        match result {
            FhirPathValue::Collection(items) => {
                assert_eq!(items.len(), 3);
                assert_eq!(items.iter().nth(0).unwrap(), &FhirPathValue::Integer(3));
                assert_eq!(items.iter().nth(1).unwrap(), &FhirPathValue::Integer(2));
                assert_eq!(items.iter().nth(2).unwrap(), &FhirPathValue::Integer(1));
            },
            _ => panic!("Expected collection result"),
        }
    }
}